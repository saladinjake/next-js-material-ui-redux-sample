"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nuka-carousel";
exports.ids = ["vendor-chunks/nuka-carousel"];
exports.modules = {

/***/ "(ssr)/./node_modules/nuka-carousel/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/nuka-carousel/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Alignment: () => (/* binding */ Alignment),\n/* harmony export */   Directions: () => (/* binding */ Directions),\n/* harmony export */   NextButton: () => (/* binding */ NextButton),\n/* harmony export */   PagingDots: () => (/* binding */ PagingDots),\n/* harmony export */   Positions: () => (/* binding */ Positions),\n/* harmony export */   PreviousButton: () => (/* binding */ PreviousButton),\n/* harmony export */   ScrollMode: () => (/* binding */ ScrollMode),\n/* harmony export */   \"default\": () => (/* binding */ Carousel)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __pow = Math.pow;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __spreadValues = (a, b)=>{\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));\n// src/carousel.tsx\n\n// src/slide.tsx\n\n// src/hooks/use-slide-intersection-observer.ts\n\nvar useSlideIntersectionObserver = (elementRef, rootRef, callback)=>{\n    const [entry, setEntry] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(callback);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        callbackRef.current = callback;\n    }, [\n        callback\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const node = elementRef == null ? void 0 : elementRef.current;\n        const root = rootRef == null ? void 0 : rootRef.current;\n        if (!window.IntersectionObserver || !node || !root) return;\n        const observer = new IntersectionObserver((entries)=>{\n            entries.forEach((entry2)=>{\n                setEntry(entry2);\n                callbackRef.current(entry2);\n            });\n        }, {\n            threshold: [\n                0.05,\n                0.95\n            ],\n            root\n        });\n        observer.observe(node);\n        return ()=>observer.disconnect();\n    }, [\n        elementRef,\n        rootRef\n    ]);\n    return entry;\n};\n// src/slide.tsx\n\nvar getSlideWidth = (count, wrapAround)=>`${wrapAround ? 100 / (3 * count) : 100 / count}%`;\nvar getSlideStyles = (count, isCurrentSlide, isVisibleSlide, wrapAround, cellSpacing, animation, speed, zoomScale, adaptiveHeight, initializedAdaptiveHeight, slideWidth)=>{\n    const width = slideWidth != null ? slideWidth : getSlideWidth(count, wrapAround);\n    const visibleSlideOpacity = isVisibleSlide ? 1 : 0;\n    const animationSpeed = animation === \"fade\" ? 200 : 500;\n    let height = \"auto\";\n    if (adaptiveHeight) {\n        if (initializedAdaptiveHeight) {\n            height = \"100%\";\n        } else if (isVisibleSlide) {\n            height = \"auto\";\n        } else {\n            height = \"0\";\n        }\n    }\n    return {\n        width,\n        height,\n        padding: `0 ${cellSpacing ? cellSpacing / 2 : 0}px`,\n        transition: animation ? `${speed || animationSpeed}ms ease 0s` : void 0,\n        transform: animation === \"zoom\" ? `scale(${isCurrentSlide && isVisibleSlide ? 1 : zoomScale || 0.85})` : void 0,\n        opacity: animation === \"fade\" ? visibleSlideOpacity : 1\n    };\n};\nvar generateIndex = (index, count, typeOfSlide)=>{\n    if (typeOfSlide === \"prev-cloned\") {\n        return index - count;\n    }\n    if (typeOfSlide === \"next-cloned\") {\n        return index + count;\n    }\n    return index;\n};\nvar Slide = ({ count, children, index, isCurrentSlide, typeOfSlide, wrapAround, cellSpacing, slideWidth, animation, speed, zoomScale, onVisibleSlideHeightChange, adaptiveHeight, initializedAdaptiveHeight, updateIOEntry, id, carouselRef, carouselId, tabbed })=>{\n    var _a;\n    const customIndex = wrapAround ? generateIndex(index, count, typeOfSlide) : index;\n    const slideRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const entry = useSlideIntersectionObserver(slideRef, carouselRef, (entry2)=>{\n        updateIOEntry(id, (entry2 == null ? void 0 : entry2.intersectionRatio) >= 0.95);\n    });\n    const isVisible = !!(entry == null ? void 0 : entry.isIntersecting);\n    const isFullyVisible = ((_a = entry == null ? void 0 : entry.intersectionRatio) != null ? _a : 1) >= 0.95;\n    const prevIsVisibleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a2;\n        const node = slideRef.current;\n        if (node) {\n            const slideHeight = (_a2 = node.getBoundingClientRect()) == null ? void 0 : _a2.height;\n            const prevIsVisible = prevIsVisibleRef.current;\n            if (isVisible && !prevIsVisible) {\n                onVisibleSlideHeightChange(customIndex, slideHeight);\n            } else if (!isVisible && prevIsVisible) {\n                onVisibleSlideHeightChange(customIndex, null);\n            }\n            prevIsVisibleRef.current = isVisible;\n        }\n    }, [\n        customIndex,\n        isVisible,\n        onVisibleSlideHeightChange\n    ]);\n    const currentSlideClass = isCurrentSlide && isFullyVisible ? \" slide-current\" : \"\";\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", __spreadProps(__spreadValues({\n        ref: slideRef\n    }, {\n        inert: isFullyVisible ? void 0 : \"true\"\n    }), {\n        className: `slide${currentSlideClass}${typeOfSlide ? ` ${typeOfSlide}` : \"\"}${isFullyVisible ? \" slide-visible\" : \"\"}`,\n        style: getSlideStyles(count, isCurrentSlide, isFullyVisible, wrapAround, cellSpacing, animation, speed, zoomScale, adaptiveHeight, initializedAdaptiveHeight, slideWidth),\n        id: typeOfSlide ? void 0 : `${carouselId}-slide-${index + 1}`,\n        role: tabbed ? \"tabpanel\" : \"group\",\n        \"aria-roledescription\": tabbed ? void 0 : \"slide\",\n        children\n    }));\n};\nvar slide_default = Slide;\n// src/announce-slide.tsx\n\nvar styles = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    overflow: \"hidden\",\n    padding: 0,\n    margin: \"-1px\",\n    clip: \"rect(0, 0, 0, 0)\",\n    whiteSpace: \"nowrap\",\n    border: 0\n};\nvar AnnounceSlide = ({ message, ariaLive = \"polite\" })=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        \"aria-live\": ariaLive,\n        \"aria-atomic\": \"true\",\n        style: styles,\n        tabIndex: -1,\n        children: message\n    });\nvar defaultRenderAnnounceSlideMessage = ({ currentSlide, count })=>`Slide ${currentSlide + 1} of ${count}`;\nvar announce_slide_default = AnnounceSlide;\n// src/slider-list.tsx\n\n// src/default-controls.tsx\n\n// src/types.ts\nvar Alignment = /* @__PURE__ */ ((Alignment2)=>{\n    Alignment2[\"Center\"] = \"center\";\n    Alignment2[\"Right\"] = \"right\";\n    Alignment2[\"Left\"] = \"left\";\n    return Alignment2;\n})(Alignment || {});\nvar Directions = /* @__PURE__ */ ((Directions2)=>{\n    Directions2[\"Next\"] = \"next\";\n    Directions2[\"Prev\"] = \"prev\";\n    Directions2[\"Up\"] = \"up\";\n    Directions2[\"Down\"] = \"down\";\n    return Directions2;\n})(Directions || {});\nvar Positions = /* @__PURE__ */ ((Positions2)=>{\n    Positions2[\"TopLeft\"] = \"TopLeft\";\n    Positions2[\"TopCenter\"] = \"TopCenter\";\n    Positions2[\"TopRight\"] = \"TopRight\";\n    Positions2[\"CenterLeft\"] = \"CenterLeft\";\n    Positions2[\"CenterCenter\"] = \"CenterCenter\";\n    Positions2[\"CenterRight\"] = \"CenterRight\";\n    Positions2[\"BottomLeft\"] = \"BottomLeft\";\n    Positions2[\"BottomCenter\"] = \"BottomCenter\";\n    Positions2[\"BottomRight\"] = \"BottomRight\";\n    return Positions2;\n})(Positions || {});\nvar ScrollMode = /* @__PURE__ */ ((ScrollMode2)=>{\n    ScrollMode2[\"page\"] = \"page\";\n    ScrollMode2[\"remainder\"] = \"remainder\";\n    return ScrollMode2;\n})(ScrollMode || {});\n// src/utils.ts\nvar getNextMoveIndex = (scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign)=>{\n    if (wrapAround) {\n        return currentSlide + slidesToScroll;\n    }\n    if (currentSlide >= slideCount - 1 || cellAlign === \"left\" && currentSlide >= slideCount - slidesToShow) {\n        return currentSlide;\n    }\n    if (scrollMode === \"remainder\" /* remainder */  && cellAlign === \"left\") {\n        return Math.min(currentSlide + slidesToScroll, slideCount - slidesToShow);\n    }\n    return Math.min(currentSlide + slidesToScroll, slideCount - 1);\n};\nvar getPrevMoveIndex = (scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign)=>{\n    if (wrapAround) {\n        return currentSlide - slidesToScroll;\n    }\n    if (currentSlide <= 0 || cellAlign === \"right\" && currentSlide <= slidesToShow - 1) {\n        return currentSlide;\n    }\n    if (scrollMode === \"remainder\" /* remainder */  && cellAlign === \"right\") {\n        return Math.max(currentSlide - slidesToScroll, slidesToShow - 1);\n    }\n    return Math.max(currentSlide - slidesToScroll, 0);\n};\nvar getDefaultSlideIndex = (slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode)=>{\n    if (slideIndex !== void 0) {\n        return slideIndex;\n    }\n    const dotIndexes = getDotIndexes(slideCount, slidesToScroll, scrollMode, slidesToShow, false, cellAlign);\n    return autoplayReverse ? dotIndexes[dotIndexes.length - 1] : dotIndexes[0];\n};\nvar getBoundedIndex = (rawIndex, slideCount)=>{\n    return (rawIndex % slideCount + slideCount) % slideCount;\n};\n// src/default-controls.tsx\n\nvar defaultButtonStyles = (disabled)=>({\n        border: 0,\n        background: \"rgba(0,0,0,0.4)\",\n        color: \"white\",\n        padding: 10,\n        textTransform: \"uppercase\",\n        opacity: disabled ? 0.3 : 1,\n        cursor: disabled ? \"not-allowed\" : \"pointer\"\n    });\nvar prevButtonDisabled = ({ cellAlign, currentSlide, slidesToShow, wrapAround })=>{\n    if (wrapAround) {\n        return false;\n    }\n    if (currentSlide === 0) {\n        return true;\n    }\n    if (cellAlign === \"right\" && currentSlide <= slidesToShow - 1) {\n        return true;\n    }\n    return false;\n};\nvar PreviousButton = ({ previousSlide, defaultControlsConfig: { prevButtonClassName, prevButtonStyle = {}, prevButtonText, prevButtonOnClick }, onUserNavigation, carouselId, previousDisabled: disabled })=>{\n    const handleClick = (event)=>{\n        prevButtonOnClick == null ? void 0 : prevButtonOnClick(event);\n        if (event.defaultPrevented) return;\n        onUserNavigation(event);\n        event.preventDefault();\n        previousSlide();\n    };\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n        className: prevButtonClassName,\n        style: __spreadValues(__spreadValues({}, defaultButtonStyles(disabled)), prevButtonStyle),\n        disabled,\n        onClick: handleClick,\n        \"aria-label\": \"previous\",\n        \"aria-controls\": `${carouselId}-slider-frame`,\n        type: \"button\",\n        children: prevButtonText || \"Prev\"\n    });\n};\nvar nextButtonDisabled = ({ cellAlign, currentSlide, slideCount, slidesToShow, wrapAround })=>{\n    if (wrapAround) {\n        return false;\n    }\n    if (currentSlide >= slideCount - 1) {\n        return true;\n    }\n    if (cellAlign === \"left\" && currentSlide >= slideCount - slidesToShow) {\n        return true;\n    }\n    return false;\n};\nvar NextButton = ({ nextSlide, defaultControlsConfig: { nextButtonClassName, nextButtonStyle = {}, nextButtonText, nextButtonOnClick }, carouselId, nextDisabled: disabled, onUserNavigation })=>{\n    const handleClick = (event)=>{\n        nextButtonOnClick == null ? void 0 : nextButtonOnClick(event);\n        if (event.defaultPrevented) return;\n        onUserNavigation(event);\n        event.preventDefault();\n        nextSlide();\n    };\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n        className: nextButtonClassName,\n        style: __spreadValues(__spreadValues({}, defaultButtonStyles(disabled)), nextButtonStyle),\n        disabled,\n        onClick: handleClick,\n        \"aria-label\": \"next\",\n        \"aria-controls\": `${carouselId}-slider-frame`,\n        type: \"button\",\n        children: nextButtonText || \"Next\"\n    });\n};\nvar getDotIndexes = (slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign)=>{\n    const dotIndexes = [];\n    const scrollSlides = slidesToScroll <= 0 ? 1 : slidesToScroll;\n    if (wrapAround) {\n        for(let i = 0; i < slideCount; i += scrollSlides){\n            dotIndexes.push(i);\n        }\n        return dotIndexes;\n    }\n    if (cellAlign === \"center\") {\n        for(let i = 0; i < slideCount - 1; i += scrollSlides){\n            dotIndexes.push(i);\n        }\n        if (slideCount > 0) {\n            dotIndexes.push(slideCount - 1);\n        }\n        return dotIndexes;\n    }\n    if (cellAlign === \"left\") {\n        if (slidesToShow >= slideCount) {\n            return [\n                0\n            ];\n        }\n        const lastPossibleIndexWithoutWhitespace = slideCount - slidesToShow;\n        for(let i = 0; i < lastPossibleIndexWithoutWhitespace; i += scrollSlides){\n            dotIndexes.push(i);\n        }\n        if (scrollMode === \"remainder\" /* remainder */ ) {\n            dotIndexes.push(lastPossibleIndexWithoutWhitespace);\n        } else {\n            dotIndexes.push(dotIndexes[dotIndexes.length - 1] + scrollSlides);\n        }\n        return dotIndexes;\n    }\n    if (cellAlign === \"right\") {\n        if (slidesToShow >= slideCount) {\n            return [\n                slideCount - 1\n            ];\n        }\n        const firstPossibleIndexWithoutWhitespace = slidesToShow - 1;\n        if (scrollMode === \"remainder\" /* remainder */ ) {\n            for(let i = firstPossibleIndexWithoutWhitespace; i < slideCount - 1; i += scrollSlides){\n                dotIndexes.push(i);\n            }\n            dotIndexes.push(slideCount - 1);\n        } else {\n            for(let i = slideCount - 1; i > firstPossibleIndexWithoutWhitespace; i -= scrollSlides){\n                dotIndexes.push(i);\n            }\n            dotIndexes.push(dotIndexes[dotIndexes.length - 1] - scrollSlides);\n            dotIndexes.reverse();\n        }\n        return dotIndexes;\n    }\n    return dotIndexes;\n};\nvar PagingDots = ({ pagingDotsIndices, defaultControlsConfig: { pagingDotsContainerClassName, pagingDotsClassName, pagingDotsStyle = {}, pagingDotsOnClick }, carouselId, currentSlide, onUserNavigation, slideCount, goToSlide, tabbed })=>{\n    const listStyles = {\n        position: \"relative\",\n        top: -10,\n        display: \"flex\",\n        margin: 0,\n        padding: 0,\n        listStyleType: \"none\"\n    };\n    const getButtonStyles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((active)=>({\n            cursor: \"pointer\",\n            opacity: active ? 1 : 0.5,\n            background: \"transparent\",\n            border: \"none\",\n            fill: \"black\"\n        }), []);\n    const currentSlideBounded = getBoundedIndex(currentSlide, slideCount);\n    if (!tabbed) return null;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        className: pagingDotsContainerClassName,\n        style: listStyles,\n        role: \"tablist\",\n        \"aria-label\": \"Choose slide to display.\",\n        children: pagingDotsIndices.map((slideIndex, i)=>{\n            const isActive = currentSlideBounded === slideIndex || // sets navigation dots active if the current slide falls in the current index range\n            currentSlideBounded < slideIndex && (i === 0 || currentSlideBounded > pagingDotsIndices[i - 1]);\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n                className: [\n                    \"paging-item\",\n                    pagingDotsClassName,\n                    isActive ? \"active\" : null\n                ].join(\" \"),\n                type: \"button\",\n                style: __spreadValues(__spreadValues({}, getButtonStyles(isActive)), pagingDotsStyle),\n                onClick: (event)=>{\n                    pagingDotsOnClick == null ? void 0 : pagingDotsOnClick(event);\n                    if (event.defaultPrevented) return;\n                    onUserNavigation(event);\n                    goToSlide(slideIndex);\n                },\n                \"aria-label\": `slide ${slideIndex + 1}`,\n                \"aria-selected\": isActive,\n                \"aria-controls\": `${carouselId}-slide-${slideIndex + 1}`,\n                role: \"tab\",\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"svg\", {\n                    className: \"paging-dot\",\n                    width: \"6\",\n                    height: \"6\",\n                    \"aria-hidden\": \"true\",\n                    focusable: \"false\",\n                    viewBox: \"0 0 6 6\",\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"circle\", {\n                        cx: \"3\",\n                        cy: \"3\",\n                        r: \"3\"\n                    })\n                })\n            }, slideIndex);\n        })\n    });\n};\n// src/hooks/use-tween.ts\n\nvar useTween = (durationMs, easingFunction, navigationNum, shouldInterrupt)=>{\n    const [normalizedTimeRaw, setNormalizedTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const startTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Date.now());\n    const rAF = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const isFirstRender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const lastNavigationNum = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const normalizedTime = lastNavigationNum.current === null || lastNavigationNum.current === navigationNum || shouldInterrupt ? normalizedTimeRaw : 0;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        lastNavigationNum.current = navigationNum;\n        if (isFirstRender.current) {\n            isFirstRender.current = false;\n            return;\n        }\n        if (shouldInterrupt) {\n            return;\n        }\n        startTime.current = Date.now();\n        setNormalizedTime(0);\n        const tick = ()=>{\n            rAF.current = requestAnimationFrame(()=>{\n                const currentTime = Date.now();\n                const normalizedTime2 = Math.min(1, (currentTime - startTime.current) / durationMs);\n                setNormalizedTime(normalizedTime2);\n                if (normalizedTime2 < 1) {\n                    tick();\n                } else {\n                    rAF.current = void 0;\n                }\n            });\n        };\n        tick();\n        return ()=>{\n            if (rAF.current !== void 0) {\n                cancelAnimationFrame(rAF.current);\n                setNormalizedTime(1);\n            }\n        };\n    }, [\n        navigationNum,\n        durationMs,\n        shouldInterrupt\n    ]);\n    return {\n        isAnimating: normalizedTime !== 1,\n        value: easingFunction(normalizedTime)\n    };\n};\n// src/slider-list.tsx\n\nvar getPercentOffsetForSlide = (currentSlide, slideCount, slidesToShow, cellAlign, wrapAround)=>{\n    const renderedSlideCount = wrapAround ? 3 * slideCount : slideCount;\n    const singleSlidePercentOfWhole = 100 / renderedSlideCount;\n    let slide0Offset = wrapAround ? -100 / 3 : 0;\n    if (cellAlign === \"right\" && slidesToShow > 1) {\n        const excessSlides = slidesToShow - 1;\n        slide0Offset += singleSlidePercentOfWhole * excessSlides;\n    }\n    if (cellAlign === \"center\" && slidesToShow > 1) {\n        const excessSlides = slidesToShow - 1;\n        const excessLeftSlides = excessSlides / 2;\n        slide0Offset += singleSlidePercentOfWhole * excessLeftSlides;\n    }\n    const currentSlideOffsetFrom0 = 100 / renderedSlideCount * currentSlide;\n    return slide0Offset - currentSlideOffsetFrom0;\n};\nvar SliderList = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ animation, animationDistance, cellAlign, children, currentSlide, disableAnimation, disableEdgeSwiping, draggedOffset, easing, edgeEasing, isDragging, scrollMode, slideCount, slidesToScroll, slidesToShow, speed, wrapAround, slideWidth, setIsAnimating }, forwardedRef)=>{\n    const renderedSlideCount = wrapAround ? 3 * slideCount : slideCount;\n    const listVisibleWidth = slideWidth ? `calc(${slideWidth} * ${renderedSlideCount})` : `${renderedSlideCount * 100 / slidesToShow}%`;\n    const percentOffsetForSlideProps = [\n        slideCount,\n        slidesToShow,\n        cellAlign,\n        wrapAround\n    ];\n    const dotIndexes = getDotIndexes(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);\n    let clampedDraggedOffset = `${draggedOffset}px`;\n    if (isDragging && disableEdgeSwiping && !wrapAround) {\n        const clampOffsets = [\n            dotIndexes[0],\n            dotIndexes[dotIndexes.length - 1]\n        ].map((index)=>getPercentOffsetForSlide(index, ...percentOffsetForSlideProps));\n        clampedDraggedOffset = `clamp(${clampOffsets[1]}%, ${draggedOffset}px, ${clampOffsets[0]}%)`;\n    }\n    const slideBasedOffset = getPercentOffsetForSlide(currentSlide, ...percentOffsetForSlideProps);\n    const isEdgeEasing = !disableEdgeSwiping && !wrapAround && (currentSlide === dotIndexes[0] && animationDistance < 0 || currentSlide === dotIndexes[dotIndexes.length - 1] && animationDistance > 0);\n    const { value: transition, isAnimating } = useTween(speed, !isEdgeEasing ? easing : edgeEasing, // animationDistance is assumed to be unique enough that it can be used to\n    // detect when a new animation should start. This is used in addition to\n    // currentSlide because some animations, such as those with edgeEasing, do\n    // not occur due to a change in value of currentSlide\n    currentSlide + animationDistance, isDragging || disableAnimation || animation === \"fade\");\n    let positioning;\n    if (isDragging || slideBasedOffset !== 0 || isAnimating) {\n        if (isDragging) {\n            positioning = `translateX(${clampedDraggedOffset})`;\n        } else {\n            const transitionOffset = isAnimating ? (1 - transition) * animationDistance : 0;\n            positioning = `translateX(calc(${slideBasedOffset}% - ${transitionOffset}px))`;\n        }\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setIsAnimating(isAnimating);\n    }, [\n        isAnimating,\n        setIsAnimating\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref: forwardedRef,\n        className: \"slider-list\",\n        style: {\n            width: listVisibleWidth,\n            textAlign: \"left\",\n            userSelect: \"auto\",\n            transform: positioning,\n            display: \"flex\"\n        },\n        children\n    });\n});\nSliderList.displayName = \"SliderList\";\n// src/controls.tsx\n\n// src/control-styles.ts\nvar commonStyles = {\n    position: \"absolute\",\n    display: \"flex\",\n    zIndex: 1,\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0\n};\nvar getControlContainerFlexStyles = (pos)=>{\n    let alignItems;\n    switch(pos){\n        case \"TopLeft\" /* TopLeft */ :\n        case \"TopCenter\" /* TopCenter */ :\n        case \"TopRight\" /* TopRight */ :\n            alignItems = \"flex-start\";\n            break;\n        case \"CenterLeft\" /* CenterLeft */ :\n        case \"CenterCenter\" /* CenterCenter */ :\n        case \"CenterRight\" /* CenterRight */ :\n            alignItems = \"center\";\n            break;\n        case \"BottomLeft\" /* BottomLeft */ :\n        case \"BottomCenter\" /* BottomCenter */ :\n        case \"BottomRight\" /* BottomRight */ :\n            alignItems = \"flex-end\";\n            break;\n    }\n    let justifyContent;\n    switch(pos){\n        case \"TopLeft\" /* TopLeft */ :\n        case \"CenterLeft\" /* CenterLeft */ :\n        case \"BottomLeft\" /* BottomLeft */ :\n            justifyContent = \"flex-start\";\n            break;\n        case \"TopCenter\" /* TopCenter */ :\n        case \"CenterCenter\" /* CenterCenter */ :\n        case \"BottomCenter\" /* BottomCenter */ :\n            justifyContent = \"center\";\n            break;\n        case \"TopRight\" /* TopRight */ :\n        case \"CenterRight\" /* CenterRight */ :\n        case \"BottomRight\" /* BottomRight */ :\n            justifyContent = \"flex-end\";\n            break;\n    }\n    return {\n        alignItems,\n        justifyContent\n    };\n};\nvar getControlContainerStyles = (pos)=>{\n    return __spreadValues(__spreadValues({}, getControlContainerFlexStyles(pos)), commonStyles);\n};\n// src/controls.tsx\n\nvar controlsMap = [\n    {\n        funcName: \"renderTopLeftControls\",\n        key: \"TopLeft\" /* TopLeft */ \n    },\n    {\n        funcName: \"renderTopCenterControls\",\n        key: \"TopCenter\" /* TopCenter */ \n    },\n    {\n        funcName: \"renderTopRightControls\",\n        key: \"TopRight\" /* TopRight */ \n    },\n    {\n        funcName: \"renderCenterLeftControls\",\n        key: \"CenterLeft\" /* CenterLeft */ \n    },\n    {\n        funcName: \"renderCenterCenterControls\",\n        key: \"CenterCenter\" /* CenterCenter */ \n    },\n    {\n        funcName: \"renderCenterRightControls\",\n        key: \"CenterRight\" /* CenterRight */ \n    },\n    {\n        funcName: \"renderBottomLeftControls\",\n        key: \"BottomLeft\" /* BottomLeft */ \n    },\n    {\n        funcName: \"renderBottomCenterControls\",\n        key: \"BottomCenter\" /* BottomCenter */ \n    },\n    {\n        funcName: \"renderBottomRightControls\",\n        key: \"BottomRight\" /* BottomRight */ \n    }\n];\nvar renderControls = (props, slideCount, currentSlide, goToSlide, nextSlide, prevSlide, slidesToScroll)=>{\n    if (props.withoutControls) {\n        return null;\n    }\n    const disableCheckProps = __spreadProps(__spreadValues({}, props), {\n        currentSlide,\n        slideCount\n    });\n    const nextDisabled = nextButtonDisabled(disableCheckProps);\n    const previousDisabled = prevButtonDisabled(disableCheckProps);\n    const pagingDotsIndices = getDotIndexes(slideCount, slidesToScroll, props.scrollMode, props.slidesToShow, props.wrapAround, props.cellAlign);\n    return controlsMap.map((control)=>{\n        var _a;\n        if (!props[control.funcName] || typeof props[control.funcName] !== \"function\") {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, control.funcName);\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n            style: __spreadProps(__spreadValues({}, getControlContainerStyles(control.key)), {\n                pointerEvents: \"none\"\n            }),\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n                className: [\n                    `slider-control-${control.key.toLowerCase()}`,\n                    props.defaultControlsConfig.containerClassName || \"\"\n                ].join(\" \").trim(),\n                style: {\n                    pointerEvents: \"auto\"\n                },\n                children: (_a = props[control.funcName]) == null ? void 0 : _a.call(props, {\n                    cellAlign: props.cellAlign,\n                    cellSpacing: props.cellSpacing,\n                    currentSlide,\n                    defaultControlsConfig: props.defaultControlsConfig || {},\n                    carouselId: props.carouselId,\n                    pagingDotsIndices,\n                    goToSlide,\n                    nextDisabled,\n                    nextSlide,\n                    onUserNavigation: props.onUserNavigation,\n                    previousDisabled,\n                    previousSlide: prevSlide,\n                    scrollMode: props.scrollMode,\n                    slideCount,\n                    slidesToScroll,\n                    slidesToShow: props.slidesToShow || 1,\n                    tabbed: props.tabbed,\n                    vertical: props.vertical,\n                    wrapAround: props.wrapAround\n                })\n            })\n        }, control.funcName);\n    });\n};\nvar controls_default = renderControls;\n// src/default-carousel-props.tsx\n\nvar easeOut = (t)=>__pow(t - 1, 3) + 1;\nvar defaultProps = {\n    adaptiveHeight: false,\n    adaptiveHeightAnimation: true,\n    afterSlide: ()=>{},\n    autoplay: false,\n    autoplayInterval: 3e3,\n    autoplayReverse: false,\n    beforeSlide: ()=>{},\n    cellAlign: \"left\",\n    cellSpacing: 0,\n    defaultControlsConfig: {},\n    disableAnimation: false,\n    disableEdgeSwiping: false,\n    dragging: true,\n    dragThreshold: 0.5,\n    easing: easeOut,\n    edgeEasing: easeOut,\n    enableKeyboardControls: false,\n    frameAriaLabel: \"Slider\",\n    keyCodeConfig: {\n        nextSlide: [\n            39,\n            68,\n            38,\n            87\n        ],\n        previousSlide: [\n            37,\n            65,\n            40,\n            83\n        ],\n        firstSlide: [\n            81\n        ],\n        lastSlide: [\n            69\n        ],\n        pause: [\n            32\n        ]\n    },\n    landmark: false,\n    onDragStart: ()=>{},\n    onDrag: ()=>{},\n    onDragEnd: ()=>{},\n    onUserNavigation: ()=>{},\n    pauseOnHover: true,\n    renderAnnounceSlideMessage: defaultRenderAnnounceSlideMessage,\n    renderBottomCenterControls: (props)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PagingDots, __spreadValues({}, props)),\n    renderCenterLeftControls: (props)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreviousButton, __spreadValues({}, props)),\n    renderCenterRightControls: (props)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NextButton, __spreadValues({}, props)),\n    scrollMode: \"page\" /* page */ ,\n    slidesToScroll: 1,\n    slidesToShow: 1,\n    speed: 500,\n    style: {},\n    swiping: true,\n    tabbed: true,\n    vertical: false,\n    withoutControls: false,\n    wrapAround: false,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {})\n};\nvar default_carousel_props_default = defaultProps;\n// src/hooks/use-frame-height.ts\n\n// src/hooks/use-state-with-ref.ts\n\nvar useStateWithRef = (initialState)=>{\n    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialState);\n    const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialState);\n    const setValueAndRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newValue)=>{\n        valueRef.current = newValue;\n        setValue(newValue);\n    }, []);\n    return [\n        value,\n        setValueAndRef,\n        valueRef\n    ];\n};\n// src/hooks/use-frame-height.ts\nvar useFrameHeight = (adaptiveHeight, slidesToShow, slideCount)=>{\n    const [visibleHeights, setVisibleHeights, visibleHeightsRef] = useStateWithRef([]);\n    const [initializedAdaptiveHeight, setInitializedAdaptiveHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const handleVisibleSlideHeightChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((slideIndex, height)=>{\n        const latestVisibleHeights = visibleHeightsRef.current;\n        let newVisibleHeights;\n        if (height === null) {\n            newVisibleHeights = latestVisibleHeights.filter((slideHeight)=>slideHeight.slideIndex !== slideIndex);\n        } else {\n            newVisibleHeights = [\n                ...latestVisibleHeights,\n                {\n                    slideIndex,\n                    height\n                }\n            ];\n        }\n        setVisibleHeights(newVisibleHeights);\n        if (newVisibleHeights.length >= Math.min(slideCount, Math.ceil(slidesToShow))) {\n            setInitializedAdaptiveHeight(true);\n        }\n    }, [\n        slideCount,\n        setVisibleHeights,\n        slidesToShow,\n        visibleHeightsRef\n    ]);\n    const frameHeight = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (adaptiveHeight) {\n            if (!initializedAdaptiveHeight) {\n                return \"auto\";\n            }\n            const maxHeight = Math.max(0, ...visibleHeights.map((height)=>height.height));\n            return `${maxHeight}px`;\n        } else {\n            return \"auto\";\n        }\n    }, [\n        adaptiveHeight,\n        initializedAdaptiveHeight,\n        visibleHeights\n    ]);\n    return {\n        handleVisibleSlideHeightChange,\n        frameHeight,\n        initializedAdaptiveHeight\n    };\n};\n// src/hooks/use-forward-ref.ts\n\nvar useForwardRef = (ref)=>{\n    const targetRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!ref) return;\n        if (typeof ref === \"function\") {\n            ref(targetRef.current);\n        } else {\n            ref.current = targetRef.current;\n        }\n    }, [\n        ref\n    ]);\n    return targetRef;\n};\n// src/carousel.tsx\n\nvar Carousel = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((rawProps, ref)=>{\n    const props = rawProps;\n    const internalCarouselId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const { adaptiveHeight, adaptiveHeightAnimation, afterSlide, animation, autoplay, autoplayInterval, autoplayReverse, beforeSlide, carouselId = internalCarouselId, cellAlign: propsCellAlign, cellSpacing, children, className, disableAnimation, dragging: desktopDraggingEnabled, dragThreshold: propsDragThreshold, enableKeyboardControls, frameAriaLabel, keyCodeConfig, landmark, onDrag, onDragEnd, onDragStart, onUserNavigation, pauseOnHover, renderAnnounceSlideMessage, scrollMode: propsScrollMode, slideIndex, slidesToScroll: propsSlidesToScroll, slidesToShow: propsSlidesToShow, slideWidth, speed, style, swiping: mobileDraggingEnabled, tabbed, wrapAround, zoomScale } = props;\n    const filteredSlides = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children).filter(Boolean);\n    const slideCount = filteredSlides.length;\n    const cellAlign = slideWidth || propsSlidesToScroll === \"auto\" ? \"left\" : propsCellAlign;\n    const scrollMode = propsSlidesToScroll === \"auto\" ? \"remainder\" /* remainder */  : propsScrollMode;\n    const [slideIOEntries, setSlideIOEntries] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(/* @__PURE__ */ new Map());\n    const visibleCount = Array.from(slideIOEntries).filter(([, visible])=>visible).length;\n    const [constantVisibleCount, setConstantVisibleCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(visibleCount);\n    const slidesToShow = slideWidth ? constantVisibleCount : propsSlidesToShow;\n    const slidesToScroll = animation === \"fade\" ? slidesToShow : propsSlidesToScroll === \"auto\" ? Math.max(constantVisibleCount, 1) : propsSlidesToScroll;\n    const [currentSlide, setCurrentSlide] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>getDefaultSlideIndex(slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode));\n    const [pause, setPause] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isDragging, setIsDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [dragDistance, setDragDistance] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [animationDistance, setAnimationDistance] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isAnimating, setIsAnimating] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const updateSlideIOEntry = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id, isFullyVisible)=>{\n        if (!!slideIOEntries.get(id) === isFullyVisible) return;\n        setSlideIOEntries((prev)=>{\n            const newMap = new Map(prev);\n            newMap.set(id, isFullyVisible);\n            return newMap;\n        });\n    }, [\n        slideIOEntries\n    ]);\n    const prevDragged = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isDragging) prevDragged.current = true;\n        if (!(isDragging || isAnimating)) {\n            if (!prevDragged.current) setConstantVisibleCount(visibleCount);\n            prevDragged.current = false;\n        }\n    }, [\n        isAnimating,\n        isDragging,\n        visibleCount\n    ]);\n    const prevXPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const preDragOffset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const sliderListRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const defaultCarouselRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const autoplayTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const autoplayLastTriggeredRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isMounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const setSliderListRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((node)=>{\n        if (node) {\n            node.querySelectorAll(\".slider-list img\").forEach((el)=>el.setAttribute(\"draggable\", \"false\"));\n        }\n        sliderListRef.current = node;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        isMounted.current = true;\n        return ()=>{\n            isMounted.current = false;\n        };\n    }, []);\n    const forwardedRef = useForwardRef(ref);\n    const carouselRef = forwardedRef || defaultCarouselRef;\n    const goToSlide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((targetSlideUnbounded)=>{\n        if (!sliderListRef.current || !carouselRef.current) return;\n        const targetSlideBounded = getBoundedIndex(targetSlideUnbounded, slideCount);\n        const slideChanged = targetSlideUnbounded !== currentSlide;\n        slideChanged && beforeSlide(currentSlide, targetSlideBounded);\n        const currentOffset = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;\n        const sliderWidth = sliderListRef.current.offsetWidth;\n        let targetOffset = getPercentOffsetForSlide(targetSlideBounded, slideCount, slidesToShow, cellAlign, wrapAround) / 100 * sliderWidth;\n        if (wrapAround) {\n            const slideSetWidth = sliderWidth / 3;\n            if (targetSlideUnbounded < 0) {\n                targetOffset += slideSetWidth;\n            }\n            if (targetSlideUnbounded >= slideCount) {\n                targetOffset -= slideSetWidth;\n            }\n        }\n        setAnimationDistance(targetOffset - currentOffset);\n        if (slideChanged) {\n            setCurrentSlide(targetSlideBounded);\n            const msToEndOfAnimation = !disableAnimation ? speed || 500 : 40;\n            setTimeout(()=>{\n                if (!isMounted.current) return;\n                afterSlide(targetSlideBounded);\n            }, msToEndOfAnimation);\n        }\n    }, [\n        afterSlide,\n        beforeSlide,\n        carouselRef,\n        cellAlign,\n        currentSlide,\n        disableAnimation,\n        speed,\n        slideCount,\n        slidesToShow,\n        wrapAround\n    ]);\n    const nextSlide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const nextSlideIndex = getNextMoveIndex(scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign);\n        if (currentSlide !== nextSlideIndex) {\n            goToSlide(nextSlideIndex);\n        }\n    }, [\n        cellAlign,\n        currentSlide,\n        goToSlide,\n        slidesToScroll,\n        scrollMode,\n        slideCount,\n        slidesToShow,\n        wrapAround\n    ]);\n    const prevSlide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const prevSlideIndex = getPrevMoveIndex(scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign);\n        if (currentSlide !== prevSlideIndex) {\n            goToSlide(prevSlideIndex);\n        }\n    }, [\n        cellAlign,\n        currentSlide,\n        goToSlide,\n        slidesToScroll,\n        scrollMode,\n        slidesToShow,\n        wrapAround\n    ]);\n    const prevMovedToSlideIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(slideIndex);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (slideIndex !== void 0 && slideIndex !== prevMovedToSlideIndex.current && !autoplayReverse) {\n            goToSlide(slideIndex);\n            prevMovedToSlideIndex.current = slideIndex;\n        }\n    }, [\n        slideIndex,\n        autoplayReverse,\n        goToSlide\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let pauseStarted = null;\n        if (pause) {\n            pauseStarted = Date.now();\n        }\n        return ()=>{\n            if (pauseStarted !== null && autoplayLastTriggeredRef.current !== null) {\n                autoplayLastTriggeredRef.current += Date.now() - pauseStarted;\n            }\n        };\n    }, [\n        pause\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (autoplay && !pause) {\n            const adjustedTimeoutMs = autoplayLastTriggeredRef.current !== null ? autoplayInterval - (Date.now() - autoplayLastTriggeredRef.current) : autoplayInterval;\n            autoplayTimeout.current = setTimeout(()=>{\n                autoplayLastTriggeredRef.current = Date.now();\n                if (autoplayReverse) {\n                    prevSlide();\n                } else {\n                    nextSlide();\n                }\n            }, adjustedTimeoutMs);\n        }\n        if (autoplay && pause) {\n            clearTimeout(autoplayTimeout.current);\n        }\n        return ()=>{\n            clearTimeout(autoplayTimeout.current);\n        };\n    }, [\n        pause,\n        autoplay,\n        autoplayInterval,\n        autoplayReverse,\n        prevSlide,\n        nextSlide\n    ]);\n    const onKeyDown = (event)=>{\n        let keyCommand = null;\n        Object.keys(keyCodeConfig).forEach((command)=>{\n            var _a;\n            if ((_a = keyCodeConfig[command]) == null ? void 0 : _a.includes(event.keyCode)) {\n                keyCommand = command;\n            }\n        });\n        if (keyCommand === null) return;\n        event.preventDefault();\n        event.stopPropagation();\n        switch(keyCommand){\n            case \"nextSlide\":\n                onUserNavigation(event);\n                nextSlide();\n                break;\n            case \"previousSlide\":\n                onUserNavigation(event);\n                prevSlide();\n                break;\n            case \"firstSlide\":\n            case \"lastSlide\":\n                {\n                    onUserNavigation(event);\n                    const dotIndices = getDotIndexes(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);\n                    if (keyCommand === \"firstSlide\") {\n                        goToSlide(dotIndices[0]);\n                    } else {\n                        goToSlide(dotIndices[dotIndices.length - 1]);\n                    }\n                    break;\n                }\n            case \"pause\":\n                setPause((p)=>!p);\n                break;\n        }\n    };\n    const dragPositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const handleDragEnd = (e)=>{\n        if (!isDragging || !carouselRef.current) return;\n        setIsDragging(false);\n        let distanceFromInertia = 0;\n        if (dragPositions.current.length > 1) {\n            const startMove = dragPositions.current[0];\n            const endMove = dragPositions.current[dragPositions.current.length - 1];\n            const timeOffset = endMove.time - startMove.time;\n            const goodInertiaFeelConstant = 9;\n            const goodFrictionFeelConstant = 0.92;\n            const initialVelocity = goodInertiaFeelConstant * Math.abs((endMove.pos - startMove.pos) / timeOffset);\n            let velocity = initialVelocity;\n            while(Math.abs(velocity) > 1){\n                distanceFromInertia += velocity;\n                velocity *= goodFrictionFeelConstant;\n            }\n        }\n        dragPositions.current = [];\n        const adjustedDragDistance = Math.abs(dragDistance) + Math.abs(distanceFromInertia);\n        onDragEnd(e);\n        prevXPosition.current = null;\n        setDragDistance(0);\n        const oneScrollWidth = carouselRef.current.offsetWidth * Math.min(1, slidesToScroll / slidesToShow);\n        const dragThreshold = oneScrollWidth * propsDragThreshold;\n        if (adjustedDragDistance < dragThreshold) {\n            goToSlide(currentSlide);\n            return;\n        }\n        const canMaintainVisualContinuity = slidesToShow >= 2 * slidesToScroll;\n        const timesToMove = canMaintainVisualContinuity ? 1 + Math.floor((adjustedDragDistance - dragThreshold) / oneScrollWidth) : 1;\n        let nextSlideIndex = currentSlide;\n        for(let index = 0; index < timesToMove; index += 1){\n            if (dragDistance > 0) {\n                nextSlideIndex = getNextMoveIndex(scrollMode, wrapAround, nextSlideIndex, slideCount, slidesToScroll, slidesToShow, cellAlign);\n            } else {\n                nextSlideIndex = getPrevMoveIndex(scrollMode, wrapAround, nextSlideIndex, slidesToScroll, slidesToShow, cellAlign);\n            }\n        }\n        if (nextSlideIndex !== currentSlide) {\n            onUserNavigation(e);\n        }\n        goToSlide(nextSlideIndex);\n    };\n    const onTouchStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (!mobileDraggingEnabled || !sliderListRef.current || !carouselRef.current) {\n            return;\n        }\n        setIsDragging(true);\n        preDragOffset.current = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;\n        onDragStart(e);\n    }, [\n        carouselRef,\n        onDragStart,\n        mobileDraggingEnabled\n    ]);\n    const handlePointerMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((xPosition)=>{\n        if (!isDragging) return;\n        const isFirstMove = prevXPosition.current === null;\n        const delta = prevXPosition.current !== null ? xPosition - prevXPosition.current : 0;\n        const nextDragDistance = dragDistance + delta;\n        const now = Date.now();\n        while(dragPositions.current.length > 0){\n            if (now - dragPositions.current[0].time <= 100) {\n                break;\n            }\n            dragPositions.current.shift();\n        }\n        dragPositions.current.push({\n            pos: nextDragDistance,\n            time: now\n        });\n        if (!isFirstMove) {\n            setDragDistance(nextDragDistance);\n        }\n        prevXPosition.current = xPosition;\n    }, [\n        isDragging,\n        dragDistance\n    ]);\n    const onTouchMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (!isDragging || !carouselRef.current) return;\n        onDragStart(e);\n        const moveValue = carouselRef.current.offsetWidth - e.touches[0].pageX;\n        handlePointerMove(moveValue);\n    }, [\n        isDragging,\n        carouselRef,\n        handlePointerMove,\n        onDragStart\n    ]);\n    const onMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (!desktopDraggingEnabled || !sliderListRef.current || !carouselRef.current) return;\n        setIsDragging(true);\n        preDragOffset.current = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;\n        onDragStart(e);\n    }, [\n        carouselRef,\n        desktopDraggingEnabled,\n        onDragStart\n    ]);\n    const onMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (!isDragging || !carouselRef.current) return;\n        onDrag(e);\n        const offsetX = e.clientX - carouselRef.current.getBoundingClientRect().left;\n        const moveValue = carouselRef.current.offsetWidth - offsetX;\n        handlePointerMove(moveValue);\n    }, [\n        carouselRef,\n        isDragging,\n        handlePointerMove,\n        onDrag\n    ]);\n    const onMouseUp = (e)=>{\n        e.preventDefault();\n        handleDragEnd(e);\n    };\n    const onMouseEnter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (pauseOnHover) {\n            setPause(true);\n        }\n    }, [\n        pauseOnHover\n    ]);\n    const onMouseLeave = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (pauseOnHover) {\n            setPause(false);\n        }\n    }, [\n        pauseOnHover\n    ]);\n    const { frameHeight, handleVisibleSlideHeightChange, initializedAdaptiveHeight } = useFrameHeight(adaptiveHeight, slidesToShow, slideCount);\n    const renderSlides = (typeOfSlide)=>{\n        const slides = filteredSlides.map((child, index)=>{\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(slide_default, {\n                id: `${typeOfSlide}-${index}`,\n                carouselId,\n                count: slideCount,\n                index,\n                isCurrentSlide: currentSlide === index,\n                typeOfSlide,\n                wrapAround,\n                cellSpacing,\n                animation,\n                speed,\n                zoomScale,\n                onVisibleSlideHeightChange: handleVisibleSlideHeightChange,\n                slideWidth,\n                updateIOEntry: updateSlideIOEntry,\n                adaptiveHeight,\n                initializedAdaptiveHeight,\n                carouselRef,\n                tabbed,\n                children: child\n            }, `${typeOfSlide}-${index}`);\n        });\n        return slides;\n    };\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", {\n        className: \"slider-container\",\n        style: {\n            position: \"relative\"\n        },\n        onMouseEnter,\n        onMouseLeave,\n        \"aria-label\": frameAriaLabel,\n        role: landmark ? \"region\" : \"group\",\n        \"aria-roledescription\": \"carousel\",\n        id: carouselId,\n        \"data-testid\": carouselId,\n        children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(announce_slide_default, {\n                ariaLive: autoplay && !pause ? \"off\" : \"polite\",\n                message: renderAnnounceSlideMessage({\n                    currentSlide,\n                    count: slideCount\n                })\n            }),\n            controls_default(__spreadProps(__spreadValues({}, props), {\n                carouselId\n            }), slideCount, currentSlide, goToSlide, nextSlide, prevSlide, slidesToScroll),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n                className: [\n                    \"slider-frame\",\n                    className || \"\"\n                ].join(\" \").trim(),\n                style: __spreadValues({\n                    overflow: \"hidden\",\n                    width: \"100%\",\n                    position: \"relative\",\n                    outline: \"none\",\n                    touchAction: \"pan-y\",\n                    height: frameHeight,\n                    transition: adaptiveHeightAnimation ? \"height 300ms ease-in-out\" : void 0,\n                    willChange: \"height\",\n                    userSelect: \"none\"\n                }, style),\n                tabIndex: enableKeyboardControls ? 0 : -1,\n                onKeyDown: enableKeyboardControls ? onKeyDown : void 0,\n                ref: carouselRef,\n                onMouseUp,\n                onMouseDown,\n                onMouseMove,\n                onMouseLeave: onMouseUp,\n                onTouchStart,\n                onTouchEnd: handleDragEnd,\n                onTouchMove,\n                id: `${carouselId}-slider-frame`,\n                \"data-testid\": `${carouselId}-slider-frame`,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(SliderList, {\n                    animationDistance,\n                    cellAlign,\n                    currentSlide,\n                    disableEdgeSwiping: props.disableEdgeSwiping,\n                    draggedOffset: preDragOffset.current - dragDistance,\n                    disableAnimation,\n                    easing: props.easing,\n                    edgeEasing: props.edgeEasing,\n                    isDragging,\n                    ref: setSliderListRef,\n                    scrollMode,\n                    animation,\n                    slideCount,\n                    slidesToScroll,\n                    slidesToShow,\n                    speed,\n                    slideWidth,\n                    wrapAround,\n                    setIsAnimating,\n                    children: [\n                        wrapAround ? renderSlides(\"prev-cloned\") : null,\n                        renderSlides(),\n                        wrapAround ? renderSlides(\"next-cloned\") : null\n                    ]\n                })\n            })\n        ]\n    });\n});\nCarousel.defaultProps = default_carousel_props_default;\nCarousel.displayName = \"Carousel\";\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbnVrYS1jYXJvdXNlbC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxhQUFhRixPQUFPRyxnQkFBZ0I7QUFDeEMsSUFBSUMsb0JBQW9CSixPQUFPSyx5QkFBeUI7QUFDeEQsSUFBSUMsc0JBQXNCTixPQUFPTyxxQkFBcUI7QUFDdEQsSUFBSUMsZUFBZVIsT0FBT1MsU0FBUyxDQUFDQyxjQUFjO0FBQ2xELElBQUlDLGVBQWVYLE9BQU9TLFNBQVMsQ0FBQ0csb0JBQW9CO0FBQ3hELElBQUlDLFFBQVFDLEtBQUtDLEdBQUc7QUFDcEIsSUFBSUMsa0JBQWtCLENBQUNDLEtBQUtDLEtBQUtDLFFBQVVELE9BQU9ELE1BQU1sQixVQUFVa0IsS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxpQkFBaUIsQ0FBQ0MsR0FBR0M7SUFDdkIsSUFBSyxJQUFJQyxRQUFRRCxLQUFNQSxDQUFBQSxJQUFJLENBQUMsR0FDMUIsSUFBSWpCLGFBQWFtQixJQUFJLENBQUNGLEdBQUdDLE9BQ3ZCVixnQkFBZ0JRLEdBQUdFLE1BQU1ELENBQUMsQ0FBQ0MsS0FBSztJQUNwQyxJQUFJcEIscUJBQ0YsS0FBSyxJQUFJb0IsUUFBUXBCLG9CQUFvQm1CLEdBQUk7UUFDdkMsSUFBSWQsYUFBYWdCLElBQUksQ0FBQ0YsR0FBR0MsT0FDdkJWLGdCQUFnQlEsR0FBR0UsTUFBTUQsQ0FBQyxDQUFDQyxLQUFLO0lBQ3BDO0lBQ0YsT0FBT0Y7QUFDVDtBQUNBLElBQUlJLGdCQUFnQixDQUFDSixHQUFHQyxJQUFNdkIsV0FBV3NCLEdBQUdwQixrQkFBa0JxQjtBQUU5RCxtQkFBbUI7QUFDbUg7QUFFdEksZ0JBQWdCO0FBSUQ7QUFFZiwrQ0FBK0M7QUFD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RjtnQkFDZGY7Z0JBQ0F3QixZQUFZekM7Z0JBQ1p3QjtnQkFDQXZXLElBQUksQ0FBQyxFQUFFRSxXQUFXLGFBQWEsQ0FBQztnQkFDaEMsZUFBZSxDQUFDLEVBQUVBLFdBQVcsYUFBYSxDQUFDO2dCQUMzQ0wsVUFBVSxhQUFhLEdBQUd5USx1REFBSUEsQ0FDNUIxRyxZQUNBO29CQUNFRTtvQkFDQXpHO29CQUNBakI7b0JBQ0E0SCxvQkFBb0JpQyxNQUFNakMsa0JBQWtCO29CQUM1Q0MsZUFBZTBJLGNBQWNwVixPQUFPLEdBQUcwVTtvQkFDdkNsSTtvQkFDQUcsUUFBUStCLE1BQU0vQixNQUFNO29CQUNwQkMsWUFBWThCLE1BQU05QixVQUFVO29CQUM1QkM7b0JBQ0FuSixLQUFLZ1M7b0JBQ0xoUTtvQkFDQXRFO29CQUNBdUU7b0JBQ0FDO29CQUNBQztvQkFDQXhFO29CQUNBSTtvQkFDQVY7b0JBQ0ErTDtvQkFDQXhLLFVBQVU7d0JBQ1J2QixhQUFhNFksYUFBYSxpQkFBaUI7d0JBQzNDQTt3QkFDQTVZLGFBQWE0WSxhQUFhLGlCQUFpQjtxQkFDNUM7Z0JBQ0g7WUFFSjtTQUVIO0lBQ0g7QUFFSjtBQUVGM0csU0FBU3ZELFlBQVksR0FBR3dCO0FBQ3hCK0IsU0FBU3RGLFdBQVcsR0FBRztBQVVyQixDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbXBsZS11aS1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL251a2EtY2Fyb3VzZWwvZGlzdC9pbmRleC5tanM/YTM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX3BvdyA9IE1hdGgucG93O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuXG4vLyBzcmMvY2Fyb3VzZWwudHN4XG5pbXBvcnQgUmVhY3Q1LCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q2LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTUsIHVzZVJlZiBhcyB1c2VSZWY2LCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazQsIHVzZUlkIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9zbGlkZS50c3hcbmltcG9ydCB7XG4gIHVzZVJlZiBhcyB1c2VSZWYyLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MlxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2hvb2tzL3VzZS1zbGlkZS1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXIudHNcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZVNsaWRlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAoZWxlbWVudFJlZiwgcm9vdFJlZiwgY2FsbGJhY2spID0+IHtcbiAgY29uc3QgW2VudHJ5LCBzZXRFbnRyeV0gPSB1c2VTdGF0ZSgpO1xuICBjb25zdCBjYWxsYmFja1JlZiA9IHVzZVJlZihjYWxsYmFjayk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tSZWYuY3VycmVudCA9IGNhbGxiYWNrO1xuICB9LCBbY2FsbGJhY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gZWxlbWVudFJlZiA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHJvb3QgPSByb290UmVmID09IG51bGwgPyB2b2lkIDAgOiByb290UmVmLmN1cnJlbnQ7XG4gICAgaWYgKCF3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgfHwgIW5vZGUgfHwgIXJvb3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAoZW50cmllcykgPT4ge1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5MikgPT4ge1xuICAgICAgICAgIHNldEVudHJ5KGVudHJ5Mik7XG4gICAgICAgICAgY2FsbGJhY2tSZWYuY3VycmVudChlbnRyeTIpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRocmVzaG9sZDogWzAuMDUsIDAuOTVdLFxuICAgICAgICByb290XG4gICAgICB9XG4gICAgKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUpO1xuICAgIHJldHVybiAoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0sIFtlbGVtZW50UmVmLCByb290UmVmXSk7XG4gIHJldHVybiBlbnRyeTtcbn07XG5cbi8vIHNyYy9zbGlkZS50c3hcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIGdldFNsaWRlV2lkdGggPSAoY291bnQsIHdyYXBBcm91bmQpID0+IGAke3dyYXBBcm91bmQgPyAxMDAgLyAoMyAqIGNvdW50KSA6IDEwMCAvIGNvdW50fSVgO1xudmFyIGdldFNsaWRlU3R5bGVzID0gKGNvdW50LCBpc0N1cnJlbnRTbGlkZSwgaXNWaXNpYmxlU2xpZGUsIHdyYXBBcm91bmQsIGNlbGxTcGFjaW5nLCBhbmltYXRpb24sIHNwZWVkLCB6b29tU2NhbGUsIGFkYXB0aXZlSGVpZ2h0LCBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0LCBzbGlkZVdpZHRoKSA9PiB7XG4gIGNvbnN0IHdpZHRoID0gc2xpZGVXaWR0aCAhPSBudWxsID8gc2xpZGVXaWR0aCA6IGdldFNsaWRlV2lkdGgoY291bnQsIHdyYXBBcm91bmQpO1xuICBjb25zdCB2aXNpYmxlU2xpZGVPcGFjaXR5ID0gaXNWaXNpYmxlU2xpZGUgPyAxIDogMDtcbiAgY29uc3QgYW5pbWF0aW9uU3BlZWQgPSBhbmltYXRpb24gPT09IFwiZmFkZVwiID8gMjAwIDogNTAwO1xuICBsZXQgaGVpZ2h0ID0gXCJhdXRvXCI7XG4gIGlmIChhZGFwdGl2ZUhlaWdodCkge1xuICAgIGlmIChpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBcIjEwMCVcIjtcbiAgICB9IGVsc2UgaWYgKGlzVmlzaWJsZVNsaWRlKSB7XG4gICAgICBoZWlnaHQgPSBcImF1dG9cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gXCIwXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHBhZGRpbmc6IGAwICR7Y2VsbFNwYWNpbmcgPyBjZWxsU3BhY2luZyAvIDIgOiAwfXB4YCxcbiAgICB0cmFuc2l0aW9uOiBhbmltYXRpb24gPyBgJHtzcGVlZCB8fCBhbmltYXRpb25TcGVlZH1tcyBlYXNlIDBzYCA6IHZvaWQgMCxcbiAgICB0cmFuc2Zvcm06IGFuaW1hdGlvbiA9PT0gXCJ6b29tXCIgPyBgc2NhbGUoJHtpc0N1cnJlbnRTbGlkZSAmJiBpc1Zpc2libGVTbGlkZSA/IDEgOiB6b29tU2NhbGUgfHwgMC44NX0pYCA6IHZvaWQgMCxcbiAgICBvcGFjaXR5OiBhbmltYXRpb24gPT09IFwiZmFkZVwiID8gdmlzaWJsZVNsaWRlT3BhY2l0eSA6IDFcbiAgfTtcbn07XG52YXIgZ2VuZXJhdGVJbmRleCA9IChpbmRleCwgY291bnQsIHR5cGVPZlNsaWRlKSA9PiB7XG4gIGlmICh0eXBlT2ZTbGlkZSA9PT0gXCJwcmV2LWNsb25lZFwiKSB7XG4gICAgcmV0dXJuIGluZGV4IC0gY291bnQ7XG4gIH1cbiAgaWYgKHR5cGVPZlNsaWRlID09PSBcIm5leHQtY2xvbmVkXCIpIHtcbiAgICByZXR1cm4gaW5kZXggKyBjb3VudDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xudmFyIFNsaWRlID0gKHtcbiAgY291bnQsXG4gIGNoaWxkcmVuLFxuICBpbmRleCxcbiAgaXNDdXJyZW50U2xpZGUsXG4gIHR5cGVPZlNsaWRlLFxuICB3cmFwQXJvdW5kLFxuICBjZWxsU3BhY2luZyxcbiAgc2xpZGVXaWR0aCxcbiAgYW5pbWF0aW9uLFxuICBzcGVlZCxcbiAgem9vbVNjYWxlLFxuICBvblZpc2libGVTbGlkZUhlaWdodENoYW5nZSxcbiAgYWRhcHRpdmVIZWlnaHQsXG4gIGluaXRpYWxpemVkQWRhcHRpdmVIZWlnaHQsXG4gIHVwZGF0ZUlPRW50cnksXG4gIGlkLFxuICBjYXJvdXNlbFJlZixcbiAgY2Fyb3VzZWxJZCxcbiAgdGFiYmVkXG59KSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgY3VzdG9tSW5kZXggPSB3cmFwQXJvdW5kID8gZ2VuZXJhdGVJbmRleChpbmRleCwgY291bnQsIHR5cGVPZlNsaWRlKSA6IGluZGV4O1xuICBjb25zdCBzbGlkZVJlZiA9IHVzZVJlZjIobnVsbCk7XG4gIGNvbnN0IGVudHJ5ID0gdXNlU2xpZGVJbnRlcnNlY3Rpb25PYnNlcnZlcihzbGlkZVJlZiwgY2Fyb3VzZWxSZWYsIChlbnRyeTIpID0+IHtcbiAgICB1cGRhdGVJT0VudHJ5KGlkLCAoZW50cnkyID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeTIuaW50ZXJzZWN0aW9uUmF0aW8pID49IDAuOTUpO1xuICB9KTtcbiAgY29uc3QgaXNWaXNpYmxlID0gISEoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IGVudHJ5LmlzSW50ZXJzZWN0aW5nKTtcbiAgY29uc3QgaXNGdWxseVZpc2libGUgPSAoKF9hID0gZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IGVudHJ5LmludGVyc2VjdGlvblJhdGlvKSAhPSBudWxsID8gX2EgOiAxKSA+PSAwLjk1O1xuICBjb25zdCBwcmV2SXNWaXNpYmxlUmVmID0gdXNlUmVmMihmYWxzZSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgY29uc3Qgbm9kZSA9IHNsaWRlUmVmLmN1cnJlbnQ7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIGNvbnN0IHNsaWRlSGVpZ2h0ID0gKF9hMiA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaGVpZ2h0O1xuICAgICAgY29uc3QgcHJldklzVmlzaWJsZSA9IHByZXZJc1Zpc2libGVSZWYuY3VycmVudDtcbiAgICAgIGlmIChpc1Zpc2libGUgJiYgIXByZXZJc1Zpc2libGUpIHtcbiAgICAgICAgb25WaXNpYmxlU2xpZGVIZWlnaHRDaGFuZ2UoY3VzdG9tSW5kZXgsIHNsaWRlSGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVmlzaWJsZSAmJiBwcmV2SXNWaXNpYmxlKSB7XG4gICAgICAgIG9uVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlKGN1c3RvbUluZGV4LCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHByZXZJc1Zpc2libGVSZWYuY3VycmVudCA9IGlzVmlzaWJsZTtcbiAgICB9XG4gIH0sIFtjdXN0b21JbmRleCwgaXNWaXNpYmxlLCBvblZpc2libGVTbGlkZUhlaWdodENoYW5nZV0pO1xuICBjb25zdCBjdXJyZW50U2xpZGVDbGFzcyA9IGlzQ3VycmVudFNsaWRlICYmIGlzRnVsbHlWaXNpYmxlID8gXCIgc2xpZGUtY3VycmVudFwiIDogXCJcIjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgXCJkaXZcIixcbiAgICBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHJlZjogc2xpZGVSZWZcbiAgICB9LCB7IGluZXJ0OiBpc0Z1bGx5VmlzaWJsZSA/IHZvaWQgMCA6IFwidHJ1ZVwiIH0pLCB7XG4gICAgICBjbGFzc05hbWU6IGBzbGlkZSR7Y3VycmVudFNsaWRlQ2xhc3N9JHt0eXBlT2ZTbGlkZSA/IGAgJHt0eXBlT2ZTbGlkZX1gIDogXCJcIn0ke2lzRnVsbHlWaXNpYmxlID8gXCIgc2xpZGUtdmlzaWJsZVwiIDogXCJcIn1gLFxuICAgICAgc3R5bGU6IGdldFNsaWRlU3R5bGVzKFxuICAgICAgICBjb3VudCxcbiAgICAgICAgaXNDdXJyZW50U2xpZGUsXG4gICAgICAgIGlzRnVsbHlWaXNpYmxlLFxuICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICBjZWxsU3BhY2luZyxcbiAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICBzcGVlZCxcbiAgICAgICAgem9vbVNjYWxlLFxuICAgICAgICBhZGFwdGl2ZUhlaWdodCxcbiAgICAgICAgaW5pdGlhbGl6ZWRBZGFwdGl2ZUhlaWdodCxcbiAgICAgICAgc2xpZGVXaWR0aFxuICAgICAgKSxcbiAgICAgIGlkOiB0eXBlT2ZTbGlkZSA/IHZvaWQgMCA6IGAke2Nhcm91c2VsSWR9LXNsaWRlLSR7aW5kZXggKyAxfWAsXG4gICAgICByb2xlOiB0YWJiZWQgPyBcInRhYnBhbmVsXCIgOiBcImdyb3VwXCIsXG4gICAgICBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IHRhYmJlZCA/IHZvaWQgMCA6IFwic2xpZGVcIixcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcbiAgKTtcbn07XG52YXIgc2xpZGVfZGVmYXVsdCA9IFNsaWRlO1xuXG4vLyBzcmMvYW5ub3VuY2Utc2xpZGUudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIHN0eWxlcyA9IHtcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgd2lkdGg6IFwiMXB4XCIsXG4gIGhlaWdodDogXCIxcHhcIixcbiAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gIHBhZGRpbmc6IDAsXG4gIG1hcmdpbjogXCItMXB4XCIsXG4gIGNsaXA6IFwicmVjdCgwLCAwLCAwLCAwKVwiLFxuICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICBib3JkZXI6IDBcbn07XG52YXIgQW5ub3VuY2VTbGlkZSA9ICh7XG4gIG1lc3NhZ2UsXG4gIGFyaWFMaXZlID0gXCJwb2xpdGVcIlxufSkgPT4gLyogQF9fUFVSRV9fICovIGpzeDIoXCJkaXZcIiwgeyBcImFyaWEtbGl2ZVwiOiBhcmlhTGl2ZSwgXCJhcmlhLWF0b21pY1wiOiBcInRydWVcIiwgc3R5bGU6IHN0eWxlcywgdGFiSW5kZXg6IC0xLCBjaGlsZHJlbjogbWVzc2FnZSB9KTtcbnZhciBkZWZhdWx0UmVuZGVyQW5ub3VuY2VTbGlkZU1lc3NhZ2UgPSAoe1xuICBjdXJyZW50U2xpZGUsXG4gIGNvdW50XG59KSA9PiBgU2xpZGUgJHtjdXJyZW50U2xpZGUgKyAxfSBvZiAke2NvdW50fWA7XG52YXIgYW5ub3VuY2Vfc2xpZGVfZGVmYXVsdCA9IEFubm91bmNlU2xpZGU7XG5cbi8vIHNyYy9zbGlkZXItbGlzdC50c3hcbmltcG9ydCBSZWFjdDMsIHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2RlZmF1bHQtY29udHJvbHMudHN4XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdHlwZXMudHNcbnZhciBBbGlnbm1lbnQgPSAvKiBAX19QVVJFX18gKi8gKChBbGlnbm1lbnQyKSA9PiB7XG4gIEFsaWdubWVudDJbXCJDZW50ZXJcIl0gPSBcImNlbnRlclwiO1xuICBBbGlnbm1lbnQyW1wiUmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gIEFsaWdubWVudDJbXCJMZWZ0XCJdID0gXCJsZWZ0XCI7XG4gIHJldHVybiBBbGlnbm1lbnQyO1xufSkoQWxpZ25tZW50IHx8IHt9KTtcbnZhciBEaXJlY3Rpb25zID0gLyogQF9fUFVSRV9fICovICgoRGlyZWN0aW9uczIpID0+IHtcbiAgRGlyZWN0aW9uczJbXCJOZXh0XCJdID0gXCJuZXh0XCI7XG4gIERpcmVjdGlvbnMyW1wiUHJldlwiXSA9IFwicHJldlwiO1xuICBEaXJlY3Rpb25zMltcIlVwXCJdID0gXCJ1cFwiO1xuICBEaXJlY3Rpb25zMltcIkRvd25cIl0gPSBcImRvd25cIjtcbiAgcmV0dXJuIERpcmVjdGlvbnMyO1xufSkoRGlyZWN0aW9ucyB8fCB7fSk7XG52YXIgUG9zaXRpb25zID0gLyogQF9fUFVSRV9fICovICgoUG9zaXRpb25zMikgPT4ge1xuICBQb3NpdGlvbnMyW1wiVG9wTGVmdFwiXSA9IFwiVG9wTGVmdFwiO1xuICBQb3NpdGlvbnMyW1wiVG9wQ2VudGVyXCJdID0gXCJUb3BDZW50ZXJcIjtcbiAgUG9zaXRpb25zMltcIlRvcFJpZ2h0XCJdID0gXCJUb3BSaWdodFwiO1xuICBQb3NpdGlvbnMyW1wiQ2VudGVyTGVmdFwiXSA9IFwiQ2VudGVyTGVmdFwiO1xuICBQb3NpdGlvbnMyW1wiQ2VudGVyQ2VudGVyXCJdID0gXCJDZW50ZXJDZW50ZXJcIjtcbiAgUG9zaXRpb25zMltcIkNlbnRlclJpZ2h0XCJdID0gXCJDZW50ZXJSaWdodFwiO1xuICBQb3NpdGlvbnMyW1wiQm90dG9tTGVmdFwiXSA9IFwiQm90dG9tTGVmdFwiO1xuICBQb3NpdGlvbnMyW1wiQm90dG9tQ2VudGVyXCJdID0gXCJCb3R0b21DZW50ZXJcIjtcbiAgUG9zaXRpb25zMltcIkJvdHRvbVJpZ2h0XCJdID0gXCJCb3R0b21SaWdodFwiO1xuICByZXR1cm4gUG9zaXRpb25zMjtcbn0pKFBvc2l0aW9ucyB8fCB7fSk7XG52YXIgU2Nyb2xsTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNjcm9sbE1vZGUyKSA9PiB7XG4gIFNjcm9sbE1vZGUyW1wicGFnZVwiXSA9IFwicGFnZVwiO1xuICBTY3JvbGxNb2RlMltcInJlbWFpbmRlclwiXSA9IFwicmVtYWluZGVyXCI7XG4gIHJldHVybiBTY3JvbGxNb2RlMjtcbn0pKFNjcm9sbE1vZGUgfHwge30pO1xuXG4vLyBzcmMvdXRpbHMudHNcbnZhciBnZXROZXh0TW92ZUluZGV4ID0gKHNjcm9sbE1vZGUsIHdyYXBBcm91bmQsIGN1cnJlbnRTbGlkZSwgc2xpZGVDb3VudCwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlc1RvU2hvdywgY2VsbEFsaWduKSA9PiB7XG4gIGlmICh3cmFwQXJvdW5kKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTbGlkZSArIHNsaWRlc1RvU2Nyb2xsO1xuICB9XG4gIGlmIChjdXJyZW50U2xpZGUgPj0gc2xpZGVDb3VudCAtIDEgfHwgY2VsbEFsaWduID09PSBcImxlZnRcIiAmJiBjdXJyZW50U2xpZGUgPj0gc2xpZGVDb3VudCAtIHNsaWRlc1RvU2hvdykge1xuICAgIHJldHVybiBjdXJyZW50U2xpZGU7XG4gIH1cbiAgaWYgKHNjcm9sbE1vZGUgPT09IFwicmVtYWluZGVyXCIgLyogcmVtYWluZGVyICovICYmIGNlbGxBbGlnbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oY3VycmVudFNsaWRlICsgc2xpZGVzVG9TY3JvbGwsIHNsaWRlQ291bnQgLSBzbGlkZXNUb1Nob3cpO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihjdXJyZW50U2xpZGUgKyBzbGlkZXNUb1Njcm9sbCwgc2xpZGVDb3VudCAtIDEpO1xufTtcbnZhciBnZXRQcmV2TW92ZUluZGV4ID0gKHNjcm9sbE1vZGUsIHdyYXBBcm91bmQsIGN1cnJlbnRTbGlkZSwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlc1RvU2hvdywgY2VsbEFsaWduKSA9PiB7XG4gIGlmICh3cmFwQXJvdW5kKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTbGlkZSAtIHNsaWRlc1RvU2Nyb2xsO1xuICB9XG4gIGlmIChjdXJyZW50U2xpZGUgPD0gMCB8fCBjZWxsQWxpZ24gPT09IFwicmlnaHRcIiAmJiBjdXJyZW50U2xpZGUgPD0gc2xpZGVzVG9TaG93IC0gMSkge1xuICAgIHJldHVybiBjdXJyZW50U2xpZGU7XG4gIH1cbiAgaWYgKHNjcm9sbE1vZGUgPT09IFwicmVtYWluZGVyXCIgLyogcmVtYWluZGVyICovICYmIGNlbGxBbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KGN1cnJlbnRTbGlkZSAtIHNsaWRlc1RvU2Nyb2xsLCBzbGlkZXNUb1Nob3cgLSAxKTtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoY3VycmVudFNsaWRlIC0gc2xpZGVzVG9TY3JvbGwsIDApO1xufTtcbnZhciBnZXREZWZhdWx0U2xpZGVJbmRleCA9IChzbGlkZUluZGV4LCBzbGlkZUNvdW50LCBzbGlkZXNUb1Nob3csIHNsaWRlc1RvU2Nyb2xsLCBjZWxsQWxpZ24sIGF1dG9wbGF5UmV2ZXJzZSwgc2Nyb2xsTW9kZSkgPT4ge1xuICBpZiAoc2xpZGVJbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHNsaWRlSW5kZXg7XG4gIH1cbiAgY29uc3QgZG90SW5kZXhlcyA9IGdldERvdEluZGV4ZXMoXG4gICAgc2xpZGVDb3VudCxcbiAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICBzY3JvbGxNb2RlLFxuICAgIHNsaWRlc1RvU2hvdyxcbiAgICBmYWxzZSxcbiAgICBjZWxsQWxpZ25cbiAgKTtcbiAgcmV0dXJuIGF1dG9wbGF5UmV2ZXJzZSA/IGRvdEluZGV4ZXNbZG90SW5kZXhlcy5sZW5ndGggLSAxXSA6IGRvdEluZGV4ZXNbMF07XG59O1xudmFyIGdldEJvdW5kZWRJbmRleCA9IChyYXdJbmRleCwgc2xpZGVDb3VudCkgPT4ge1xuICByZXR1cm4gKHJhd0luZGV4ICUgc2xpZGVDb3VudCArIHNsaWRlQ291bnQpICUgc2xpZGVDb3VudDtcbn07XG5cbi8vIHNyYy9kZWZhdWx0LWNvbnRyb2xzLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBkZWZhdWx0QnV0dG9uU3R5bGVzID0gKGRpc2FibGVkKSA9PiAoe1xuICBib3JkZXI6IDAsXG4gIGJhY2tncm91bmQ6IFwicmdiYSgwLDAsMCwwLjQpXCIsXG4gIGNvbG9yOiBcIndoaXRlXCIsXG4gIHBhZGRpbmc6IDEwLFxuICB0ZXh0VHJhbnNmb3JtOiBcInVwcGVyY2FzZVwiLFxuICBvcGFjaXR5OiBkaXNhYmxlZCA/IDAuMyA6IDEsXG4gIGN1cnNvcjogZGlzYWJsZWQgPyBcIm5vdC1hbGxvd2VkXCIgOiBcInBvaW50ZXJcIlxufSk7XG52YXIgcHJldkJ1dHRvbkRpc2FibGVkID0gKHtcbiAgY2VsbEFsaWduLFxuICBjdXJyZW50U2xpZGUsXG4gIHNsaWRlc1RvU2hvdyxcbiAgd3JhcEFyb3VuZFxufSkgPT4ge1xuICBpZiAod3JhcEFyb3VuZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY3VycmVudFNsaWRlID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNlbGxBbGlnbiA9PT0gXCJyaWdodFwiICYmIGN1cnJlbnRTbGlkZSA8PSBzbGlkZXNUb1Nob3cgLSAxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBQcmV2aW91c0J1dHRvbiA9ICh7XG4gIHByZXZpb3VzU2xpZGUsXG4gIGRlZmF1bHRDb250cm9sc0NvbmZpZzoge1xuICAgIHByZXZCdXR0b25DbGFzc05hbWUsXG4gICAgcHJldkJ1dHRvblN0eWxlID0ge30sXG4gICAgcHJldkJ1dHRvblRleHQsXG4gICAgcHJldkJ1dHRvbk9uQ2xpY2tcbiAgfSxcbiAgb25Vc2VyTmF2aWdhdGlvbixcbiAgY2Fyb3VzZWxJZCxcbiAgcHJldmlvdXNEaXNhYmxlZDogZGlzYWJsZWRcbn0pID0+IHtcbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICBwcmV2QnV0dG9uT25DbGljayA9PSBudWxsID8gdm9pZCAwIDogcHJldkJ1dHRvbk9uQ2xpY2soZXZlbnQpO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIG9uVXNlck5hdmlnYXRpb24oZXZlbnQpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcHJldmlvdXNTbGlkZSgpO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMoXG4gICAgXCJidXR0b25cIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IHByZXZCdXR0b25DbGFzc05hbWUsXG4gICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGRlZmF1bHRCdXR0b25TdHlsZXMoZGlzYWJsZWQpKSwgcHJldkJ1dHRvblN0eWxlKSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgICBcImFyaWEtbGFiZWxcIjogXCJwcmV2aW91c1wiLFxuICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IGAke2Nhcm91c2VsSWR9LXNsaWRlci1mcmFtZWAsXG4gICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgY2hpbGRyZW46IHByZXZCdXR0b25UZXh0IHx8IFwiUHJldlwiXG4gICAgfVxuICApO1xufTtcbnZhciBuZXh0QnV0dG9uRGlzYWJsZWQgPSAoe1xuICBjZWxsQWxpZ24sXG4gIGN1cnJlbnRTbGlkZSxcbiAgc2xpZGVDb3VudCxcbiAgc2xpZGVzVG9TaG93LFxuICB3cmFwQXJvdW5kXG59KSA9PiB7XG4gIGlmICh3cmFwQXJvdW5kKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjdXJyZW50U2xpZGUgPj0gc2xpZGVDb3VudCAtIDEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY2VsbEFsaWduID09PSBcImxlZnRcIiAmJiBjdXJyZW50U2xpZGUgPj0gc2xpZGVDb3VudCAtIHNsaWRlc1RvU2hvdykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgTmV4dEJ1dHRvbiA9ICh7XG4gIG5leHRTbGlkZSxcbiAgZGVmYXVsdENvbnRyb2xzQ29uZmlnOiB7XG4gICAgbmV4dEJ1dHRvbkNsYXNzTmFtZSxcbiAgICBuZXh0QnV0dG9uU3R5bGUgPSB7fSxcbiAgICBuZXh0QnV0dG9uVGV4dCxcbiAgICBuZXh0QnV0dG9uT25DbGlja1xuICB9LFxuICBjYXJvdXNlbElkLFxuICBuZXh0RGlzYWJsZWQ6IGRpc2FibGVkLFxuICBvblVzZXJOYXZpZ2F0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgbmV4dEJ1dHRvbk9uQ2xpY2sgPT0gbnVsbCA/IHZvaWQgMCA6IG5leHRCdXR0b25PbkNsaWNrKGV2ZW50KTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBvblVzZXJOYXZpZ2F0aW9uKGV2ZW50KTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIG5leHRTbGlkZSgpO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMoXG4gICAgXCJidXR0b25cIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IG5leHRCdXR0b25DbGFzc05hbWUsXG4gICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGRlZmF1bHRCdXR0b25TdHlsZXMoZGlzYWJsZWQpKSwgbmV4dEJ1dHRvblN0eWxlKSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgICBcImFyaWEtbGFiZWxcIjogXCJuZXh0XCIsXG4gICAgICBcImFyaWEtY29udHJvbHNcIjogYCR7Y2Fyb3VzZWxJZH0tc2xpZGVyLWZyYW1lYCxcbiAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICBjaGlsZHJlbjogbmV4dEJ1dHRvblRleHQgfHwgXCJOZXh0XCJcbiAgICB9XG4gICk7XG59O1xudmFyIGdldERvdEluZGV4ZXMgPSAoc2xpZGVDb3VudCwgc2xpZGVzVG9TY3JvbGwsIHNjcm9sbE1vZGUsIHNsaWRlc1RvU2hvdywgd3JhcEFyb3VuZCwgY2VsbEFsaWduKSA9PiB7XG4gIGNvbnN0IGRvdEluZGV4ZXMgPSBbXTtcbiAgY29uc3Qgc2Nyb2xsU2xpZGVzID0gc2xpZGVzVG9TY3JvbGwgPD0gMCA/IDEgOiBzbGlkZXNUb1Njcm9sbDtcbiAgaWYgKHdyYXBBcm91bmQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlQ291bnQ7IGkgKz0gc2Nyb2xsU2xpZGVzKSB7XG4gICAgICBkb3RJbmRleGVzLnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiBkb3RJbmRleGVzO1xuICB9XG4gIGlmIChjZWxsQWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlQ291bnQgLSAxOyBpICs9IHNjcm9sbFNsaWRlcykge1xuICAgICAgZG90SW5kZXhlcy5wdXNoKGkpO1xuICAgIH1cbiAgICBpZiAoc2xpZGVDb3VudCA+IDApIHtcbiAgICAgIGRvdEluZGV4ZXMucHVzaChzbGlkZUNvdW50IC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBkb3RJbmRleGVzO1xuICB9XG4gIGlmIChjZWxsQWxpZ24gPT09IFwibGVmdFwiKSB7XG4gICAgaWYgKHNsaWRlc1RvU2hvdyA+PSBzbGlkZUNvdW50KSB7XG4gICAgICByZXR1cm4gWzBdO1xuICAgIH1cbiAgICBjb25zdCBsYXN0UG9zc2libGVJbmRleFdpdGhvdXRXaGl0ZXNwYWNlID0gc2xpZGVDb3VudCAtIHNsaWRlc1RvU2hvdztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RQb3NzaWJsZUluZGV4V2l0aG91dFdoaXRlc3BhY2U7IGkgKz0gc2Nyb2xsU2xpZGVzKSB7XG4gICAgICBkb3RJbmRleGVzLnB1c2goaSk7XG4gICAgfVxuICAgIGlmIChzY3JvbGxNb2RlID09PSBcInJlbWFpbmRlclwiIC8qIHJlbWFpbmRlciAqLykge1xuICAgICAgZG90SW5kZXhlcy5wdXNoKGxhc3RQb3NzaWJsZUluZGV4V2l0aG91dFdoaXRlc3BhY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb3RJbmRleGVzLnB1c2goZG90SW5kZXhlc1tkb3RJbmRleGVzLmxlbmd0aCAtIDFdICsgc2Nyb2xsU2xpZGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvdEluZGV4ZXM7XG4gIH1cbiAgaWYgKGNlbGxBbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgaWYgKHNsaWRlc1RvU2hvdyA+PSBzbGlkZUNvdW50KSB7XG4gICAgICByZXR1cm4gW3NsaWRlQ291bnQgLSAxXTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb3NzaWJsZUluZGV4V2l0aG91dFdoaXRlc3BhY2UgPSBzbGlkZXNUb1Nob3cgLSAxO1xuICAgIGlmIChzY3JvbGxNb2RlID09PSBcInJlbWFpbmRlclwiIC8qIHJlbWFpbmRlciAqLykge1xuICAgICAgZm9yIChsZXQgaSA9IGZpcnN0UG9zc2libGVJbmRleFdpdGhvdXRXaGl0ZXNwYWNlOyBpIDwgc2xpZGVDb3VudCAtIDE7IGkgKz0gc2Nyb2xsU2xpZGVzKSB7XG4gICAgICAgIGRvdEluZGV4ZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIGRvdEluZGV4ZXMucHVzaChzbGlkZUNvdW50IC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBzbGlkZUNvdW50IC0gMTsgaSA+IGZpcnN0UG9zc2libGVJbmRleFdpdGhvdXRXaGl0ZXNwYWNlOyBpIC09IHNjcm9sbFNsaWRlcykge1xuICAgICAgICBkb3RJbmRleGVzLnB1c2goaSk7XG4gICAgICB9XG4gICAgICBkb3RJbmRleGVzLnB1c2goZG90SW5kZXhlc1tkb3RJbmRleGVzLmxlbmd0aCAtIDFdIC0gc2Nyb2xsU2xpZGVzKTtcbiAgICAgIGRvdEluZGV4ZXMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZG90SW5kZXhlcztcbiAgfVxuICByZXR1cm4gZG90SW5kZXhlcztcbn07XG52YXIgUGFnaW5nRG90cyA9ICh7XG4gIHBhZ2luZ0RvdHNJbmRpY2VzLFxuICBkZWZhdWx0Q29udHJvbHNDb25maWc6IHtcbiAgICBwYWdpbmdEb3RzQ29udGFpbmVyQ2xhc3NOYW1lLFxuICAgIHBhZ2luZ0RvdHNDbGFzc05hbWUsXG4gICAgcGFnaW5nRG90c1N0eWxlID0ge30sXG4gICAgcGFnaW5nRG90c09uQ2xpY2tcbiAgfSxcbiAgY2Fyb3VzZWxJZCxcbiAgY3VycmVudFNsaWRlLFxuICBvblVzZXJOYXZpZ2F0aW9uLFxuICBzbGlkZUNvdW50LFxuICBnb1RvU2xpZGUsXG4gIHRhYmJlZFxufSkgPT4ge1xuICBjb25zdCBsaXN0U3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgdG9wOiAtMTAsXG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgbWFyZ2luOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgbGlzdFN0eWxlVHlwZTogXCJub25lXCJcbiAgfTtcbiAgY29uc3QgZ2V0QnV0dG9uU3R5bGVzID0gdXNlQ2FsbGJhY2soXG4gICAgKGFjdGl2ZSkgPT4gKHtcbiAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICBvcGFjaXR5OiBhY3RpdmUgPyAxIDogMC41LFxuICAgICAgYmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLFxuICAgIFtdXG4gICk7XG4gIGNvbnN0IGN1cnJlbnRTbGlkZUJvdW5kZWQgPSBnZXRCb3VuZGVkSW5kZXgoY3VycmVudFNsaWRlLCBzbGlkZUNvdW50KTtcbiAgaWYgKCF0YWJiZWQpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogcGFnaW5nRG90c0NvbnRhaW5lckNsYXNzTmFtZSxcbiAgICAgIHN0eWxlOiBsaXN0U3R5bGVzLFxuICAgICAgcm9sZTogXCJ0YWJsaXN0XCIsXG4gICAgICBcImFyaWEtbGFiZWxcIjogXCJDaG9vc2Ugc2xpZGUgdG8gZGlzcGxheS5cIixcbiAgICAgIGNoaWxkcmVuOiBwYWdpbmdEb3RzSW5kaWNlcy5tYXAoKHNsaWRlSW5kZXgsIGkpID0+IHtcbiAgICAgICAgY29uc3QgaXNBY3RpdmUgPSBjdXJyZW50U2xpZGVCb3VuZGVkID09PSBzbGlkZUluZGV4IHx8IC8vIHNldHMgbmF2aWdhdGlvbiBkb3RzIGFjdGl2ZSBpZiB0aGUgY3VycmVudCBzbGlkZSBmYWxscyBpbiB0aGUgY3VycmVudCBpbmRleCByYW5nZVxuICAgICAgICBjdXJyZW50U2xpZGVCb3VuZGVkIDwgc2xpZGVJbmRleCAmJiAoaSA9PT0gMCB8fCBjdXJyZW50U2xpZGVCb3VuZGVkID4gcGFnaW5nRG90c0luZGljZXNbaSAtIDFdKTtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFxuICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgIFwicGFnaW5nLWl0ZW1cIixcbiAgICAgICAgICAgICAgcGFnaW5nRG90c0NsYXNzTmFtZSxcbiAgICAgICAgICAgICAgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbFxuICAgICAgICAgICAgXS5qb2luKFwiIFwiKSxcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGdldEJ1dHRvblN0eWxlcyhpc0FjdGl2ZSkpLCBwYWdpbmdEb3RzU3R5bGUpLFxuICAgICAgICAgICAgb25DbGljazogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIHBhZ2luZ0RvdHNPbkNsaWNrID09IG51bGwgPyB2b2lkIDAgOiBwYWdpbmdEb3RzT25DbGljayhldmVudCk7XG4gICAgICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgb25Vc2VyTmF2aWdhdGlvbihldmVudCk7XG4gICAgICAgICAgICAgIGdvVG9TbGlkZShzbGlkZUluZGV4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogYHNsaWRlICR7c2xpZGVJbmRleCArIDF9YCxcbiAgICAgICAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBpc0FjdGl2ZSxcbiAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBgJHtjYXJvdXNlbElkfS1zbGlkZS0ke3NsaWRlSW5kZXggKyAxfWAsXG4gICAgICAgICAgICByb2xlOiBcInRhYlwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzKFxuICAgICAgICAgICAgICBcInN2Z1wiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcInBhZ2luZy1kb3RcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogXCI2XCIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjZcIixcbiAgICAgICAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgICAgIGZvY3VzYWJsZTogXCJmYWxzZVwiLFxuICAgICAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDYgNlwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MyhcImNpcmNsZVwiLCB7IGN4OiBcIjNcIiwgY3k6IFwiM1wiLCByOiBcIjNcIiB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbGlkZUluZGV4XG4gICAgICAgICk7XG4gICAgICB9KVxuICAgIH1cbiAgKTtcbn07XG5cbi8vIHNyYy9ob29rcy91c2UtdHdlZW4udHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIsIHVzZVJlZiBhcyB1c2VSZWYzIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlVHdlZW4gPSAoZHVyYXRpb25NcywgZWFzaW5nRnVuY3Rpb24sIG5hdmlnYXRpb25OdW0sIHNob3VsZEludGVycnVwdCkgPT4ge1xuICBjb25zdCBbbm9ybWFsaXplZFRpbWVSYXcsIHNldE5vcm1hbGl6ZWRUaW1lXSA9IHVzZVN0YXRlMigxKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gdXNlUmVmMyhEYXRlLm5vdygpKTtcbiAgY29uc3QgckFGID0gdXNlUmVmMygpO1xuICBjb25zdCBpc0ZpcnN0UmVuZGVyID0gdXNlUmVmMyh0cnVlKTtcbiAgY29uc3QgbGFzdE5hdmlnYXRpb25OdW0gPSB1c2VSZWYzKG51bGwpO1xuICBjb25zdCBub3JtYWxpemVkVGltZSA9IGxhc3ROYXZpZ2F0aW9uTnVtLmN1cnJlbnQgPT09IG51bGwgfHwgbGFzdE5hdmlnYXRpb25OdW0uY3VycmVudCA9PT0gbmF2aWdhdGlvbk51bSB8fCBzaG91bGRJbnRlcnJ1cHQgPyBub3JtYWxpemVkVGltZVJhdyA6IDA7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGxhc3ROYXZpZ2F0aW9uTnVtLmN1cnJlbnQgPSBuYXZpZ2F0aW9uTnVtO1xuICAgIGlmIChpc0ZpcnN0UmVuZGVyLmN1cnJlbnQpIHtcbiAgICAgIGlzRmlyc3RSZW5kZXIuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkSW50ZXJydXB0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXJ0VGltZS5jdXJyZW50ID0gRGF0ZS5ub3coKTtcbiAgICBzZXROb3JtYWxpemVkVGltZSgwKTtcbiAgICBjb25zdCB0aWNrID0gKCkgPT4ge1xuICAgICAgckFGLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUaW1lMiA9IE1hdGgubWluKFxuICAgICAgICAgIDEsXG4gICAgICAgICAgKGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lLmN1cnJlbnQpIC8gZHVyYXRpb25Nc1xuICAgICAgICApO1xuICAgICAgICBzZXROb3JtYWxpemVkVGltZShub3JtYWxpemVkVGltZTIpO1xuICAgICAgICBpZiAobm9ybWFsaXplZFRpbWUyIDwgMSkge1xuICAgICAgICAgIHRpY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByQUYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aWNrKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChyQUYuY3VycmVudCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJBRi5jdXJyZW50KTtcbiAgICAgICAgc2V0Tm9ybWFsaXplZFRpbWUoMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW25hdmlnYXRpb25OdW0sIGR1cmF0aW9uTXMsIHNob3VsZEludGVycnVwdF0pO1xuICByZXR1cm4ge1xuICAgIGlzQW5pbWF0aW5nOiBub3JtYWxpemVkVGltZSAhPT0gMSxcbiAgICB2YWx1ZTogZWFzaW5nRnVuY3Rpb24obm9ybWFsaXplZFRpbWUpXG4gIH07XG59O1xuXG4vLyBzcmMvc2xpZGVyLWxpc3QudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIGdldFBlcmNlbnRPZmZzZXRGb3JTbGlkZSA9IChjdXJyZW50U2xpZGUsIHNsaWRlQ291bnQsIHNsaWRlc1RvU2hvdywgY2VsbEFsaWduLCB3cmFwQXJvdW5kKSA9PiB7XG4gIGNvbnN0IHJlbmRlcmVkU2xpZGVDb3VudCA9IHdyYXBBcm91bmQgPyAzICogc2xpZGVDb3VudCA6IHNsaWRlQ291bnQ7XG4gIGNvbnN0IHNpbmdsZVNsaWRlUGVyY2VudE9mV2hvbGUgPSAxMDAgLyByZW5kZXJlZFNsaWRlQ291bnQ7XG4gIGxldCBzbGlkZTBPZmZzZXQgPSB3cmFwQXJvdW5kID8gLTEwMCAvIDMgOiAwO1xuICBpZiAoY2VsbEFsaWduID09PSBcInJpZ2h0XCIgJiYgc2xpZGVzVG9TaG93ID4gMSkge1xuICAgIGNvbnN0IGV4Y2Vzc1NsaWRlcyA9IHNsaWRlc1RvU2hvdyAtIDE7XG4gICAgc2xpZGUwT2Zmc2V0ICs9IHNpbmdsZVNsaWRlUGVyY2VudE9mV2hvbGUgKiBleGNlc3NTbGlkZXM7XG4gIH1cbiAgaWYgKGNlbGxBbGlnbiA9PT0gXCJjZW50ZXJcIiAmJiBzbGlkZXNUb1Nob3cgPiAxKSB7XG4gICAgY29uc3QgZXhjZXNzU2xpZGVzID0gc2xpZGVzVG9TaG93IC0gMTtcbiAgICBjb25zdCBleGNlc3NMZWZ0U2xpZGVzID0gZXhjZXNzU2xpZGVzIC8gMjtcbiAgICBzbGlkZTBPZmZzZXQgKz0gc2luZ2xlU2xpZGVQZXJjZW50T2ZXaG9sZSAqIGV4Y2Vzc0xlZnRTbGlkZXM7XG4gIH1cbiAgY29uc3QgY3VycmVudFNsaWRlT2Zmc2V0RnJvbTAgPSAxMDAgLyByZW5kZXJlZFNsaWRlQ291bnQgKiBjdXJyZW50U2xpZGU7XG4gIHJldHVybiBzbGlkZTBPZmZzZXQgLSBjdXJyZW50U2xpZGVPZmZzZXRGcm9tMDtcbn07XG52YXIgU2xpZGVyTGlzdCA9IFJlYWN0My5mb3J3YXJkUmVmKFxuICAoe1xuICAgIGFuaW1hdGlvbixcbiAgICBhbmltYXRpb25EaXN0YW5jZSxcbiAgICBjZWxsQWxpZ24sXG4gICAgY2hpbGRyZW4sXG4gICAgY3VycmVudFNsaWRlLFxuICAgIGRpc2FibGVBbmltYXRpb24sXG4gICAgZGlzYWJsZUVkZ2VTd2lwaW5nLFxuICAgIGRyYWdnZWRPZmZzZXQsXG4gICAgZWFzaW5nLFxuICAgIGVkZ2VFYXNpbmcsXG4gICAgaXNEcmFnZ2luZyxcbiAgICBzY3JvbGxNb2RlLFxuICAgIHNsaWRlQ291bnQsXG4gICAgc2xpZGVzVG9TY3JvbGwsXG4gICAgc2xpZGVzVG9TaG93LFxuICAgIHNwZWVkLFxuICAgIHdyYXBBcm91bmQsXG4gICAgc2xpZGVXaWR0aCxcbiAgICBzZXRJc0FuaW1hdGluZ1xuICB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCByZW5kZXJlZFNsaWRlQ291bnQgPSB3cmFwQXJvdW5kID8gMyAqIHNsaWRlQ291bnQgOiBzbGlkZUNvdW50O1xuICAgIGNvbnN0IGxpc3RWaXNpYmxlV2lkdGggPSBzbGlkZVdpZHRoID8gYGNhbGMoJHtzbGlkZVdpZHRofSAqICR7cmVuZGVyZWRTbGlkZUNvdW50fSlgIDogYCR7cmVuZGVyZWRTbGlkZUNvdW50ICogMTAwIC8gc2xpZGVzVG9TaG93fSVgO1xuICAgIGNvbnN0IHBlcmNlbnRPZmZzZXRGb3JTbGlkZVByb3BzID0gW1xuICAgICAgc2xpZGVDb3VudCxcbiAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgIGNlbGxBbGlnbixcbiAgICAgIHdyYXBBcm91bmRcbiAgICBdO1xuICAgIGNvbnN0IGRvdEluZGV4ZXMgPSBnZXREb3RJbmRleGVzKFxuICAgICAgc2xpZGVDb3VudCxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgIHdyYXBBcm91bmQsXG4gICAgICBjZWxsQWxpZ25cbiAgICApO1xuICAgIGxldCBjbGFtcGVkRHJhZ2dlZE9mZnNldCA9IGAke2RyYWdnZWRPZmZzZXR9cHhgO1xuICAgIGlmIChpc0RyYWdnaW5nICYmIGRpc2FibGVFZGdlU3dpcGluZyAmJiAhd3JhcEFyb3VuZCkge1xuICAgICAgY29uc3QgY2xhbXBPZmZzZXRzID0gW1xuICAgICAgICBkb3RJbmRleGVzWzBdLFxuICAgICAgICBkb3RJbmRleGVzW2RvdEluZGV4ZXMubGVuZ3RoIC0gMV1cbiAgICAgIF0ubWFwKFxuICAgICAgICAoaW5kZXgpID0+IGdldFBlcmNlbnRPZmZzZXRGb3JTbGlkZShpbmRleCwgLi4ucGVyY2VudE9mZnNldEZvclNsaWRlUHJvcHMpXG4gICAgICApO1xuICAgICAgY2xhbXBlZERyYWdnZWRPZmZzZXQgPSBgY2xhbXAoJHtjbGFtcE9mZnNldHNbMV19JSwgJHtkcmFnZ2VkT2Zmc2V0fXB4LCAke2NsYW1wT2Zmc2V0c1swXX0lKWA7XG4gICAgfVxuICAgIGNvbnN0IHNsaWRlQmFzZWRPZmZzZXQgPSBnZXRQZXJjZW50T2Zmc2V0Rm9yU2xpZGUoXG4gICAgICBjdXJyZW50U2xpZGUsXG4gICAgICAuLi5wZXJjZW50T2Zmc2V0Rm9yU2xpZGVQcm9wc1xuICAgICk7XG4gICAgY29uc3QgaXNFZGdlRWFzaW5nID0gIWRpc2FibGVFZGdlU3dpcGluZyAmJiAhd3JhcEFyb3VuZCAmJiAoY3VycmVudFNsaWRlID09PSBkb3RJbmRleGVzWzBdICYmIGFuaW1hdGlvbkRpc3RhbmNlIDwgMCB8fCBjdXJyZW50U2xpZGUgPT09IGRvdEluZGV4ZXNbZG90SW5kZXhlcy5sZW5ndGggLSAxXSAmJiBhbmltYXRpb25EaXN0YW5jZSA+IDApO1xuICAgIGNvbnN0IHsgdmFsdWU6IHRyYW5zaXRpb24sIGlzQW5pbWF0aW5nIH0gPSB1c2VUd2VlbihcbiAgICAgIHNwZWVkLFxuICAgICAgIWlzRWRnZUVhc2luZyA/IGVhc2luZyA6IGVkZ2VFYXNpbmcsXG4gICAgICAvLyBhbmltYXRpb25EaXN0YW5jZSBpcyBhc3N1bWVkIHRvIGJlIHVuaXF1ZSBlbm91Z2ggdGhhdCBpdCBjYW4gYmUgdXNlZCB0b1xuICAgICAgLy8gZGV0ZWN0IHdoZW4gYSBuZXcgYW5pbWF0aW9uIHNob3VsZCBzdGFydC4gVGhpcyBpcyB1c2VkIGluIGFkZGl0aW9uIHRvXG4gICAgICAvLyBjdXJyZW50U2xpZGUgYmVjYXVzZSBzb21lIGFuaW1hdGlvbnMsIHN1Y2ggYXMgdGhvc2Ugd2l0aCBlZGdlRWFzaW5nLCBkb1xuICAgICAgLy8gbm90IG9jY3VyIGR1ZSB0byBhIGNoYW5nZSBpbiB2YWx1ZSBvZiBjdXJyZW50U2xpZGVcbiAgICAgIGN1cnJlbnRTbGlkZSArIGFuaW1hdGlvbkRpc3RhbmNlLFxuICAgICAgaXNEcmFnZ2luZyB8fCBkaXNhYmxlQW5pbWF0aW9uIHx8IGFuaW1hdGlvbiA9PT0gXCJmYWRlXCJcbiAgICApO1xuICAgIGxldCBwb3NpdGlvbmluZztcbiAgICBpZiAoaXNEcmFnZ2luZyB8fCBzbGlkZUJhc2VkT2Zmc2V0ICE9PSAwIHx8IGlzQW5pbWF0aW5nKSB7XG4gICAgICBpZiAoaXNEcmFnZ2luZykge1xuICAgICAgICBwb3NpdGlvbmluZyA9IGB0cmFuc2xhdGVYKCR7Y2xhbXBlZERyYWdnZWRPZmZzZXR9KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0cmFuc2l0aW9uT2Zmc2V0ID0gaXNBbmltYXRpbmcgPyAoMSAtIHRyYW5zaXRpb24pICogYW5pbWF0aW9uRGlzdGFuY2UgOiAwO1xuICAgICAgICBwb3NpdGlvbmluZyA9IGB0cmFuc2xhdGVYKGNhbGMoJHtzbGlkZUJhc2VkT2Zmc2V0fSUgLSAke3RyYW5zaXRpb25PZmZzZXR9cHgpKWA7XG4gICAgICB9XG4gICAgfVxuICAgIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgICAgc2V0SXNBbmltYXRpbmcoaXNBbmltYXRpbmcpO1xuICAgIH0sIFtpc0FuaW1hdGluZywgc2V0SXNBbmltYXRpbmddKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgICAgY2xhc3NOYW1lOiBcInNsaWRlci1saXN0XCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgd2lkdGg6IGxpc3RWaXNpYmxlV2lkdGgsXG4gICAgICAgICAgdGV4dEFsaWduOiBcImxlZnRcIixcbiAgICAgICAgICB1c2VyU2VsZWN0OiBcImF1dG9cIixcbiAgICAgICAgICB0cmFuc2Zvcm06IHBvc2l0aW9uaW5nLFxuICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcblNsaWRlckxpc3QuZGlzcGxheU5hbWUgPSBcIlNsaWRlckxpc3RcIjtcblxuLy8gc3JjL2NvbnRyb2xzLnRzeFxuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2NvbnRyb2wtc3R5bGVzLnRzXG52YXIgY29tbW9uU3R5bGVzID0ge1xuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICBkaXNwbGF5OiBcImZsZXhcIixcbiAgekluZGV4OiAxLFxuICB0b3A6IDAsXG4gIGxlZnQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgcmlnaHQ6IDBcbn07XG52YXIgZ2V0Q29udHJvbENvbnRhaW5lckZsZXhTdHlsZXMgPSAocG9zKSA9PiB7XG4gIGxldCBhbGlnbkl0ZW1zO1xuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgXCJUb3BMZWZ0XCIgLyogVG9wTGVmdCAqLzpcbiAgICBjYXNlIFwiVG9wQ2VudGVyXCIgLyogVG9wQ2VudGVyICovOlxuICAgIGNhc2UgXCJUb3BSaWdodFwiIC8qIFRvcFJpZ2h0ICovOlxuICAgICAgYWxpZ25JdGVtcyA9IFwiZmxleC1zdGFydFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkNlbnRlckxlZnRcIiAvKiBDZW50ZXJMZWZ0ICovOlxuICAgIGNhc2UgXCJDZW50ZXJDZW50ZXJcIiAvKiBDZW50ZXJDZW50ZXIgKi86XG4gICAgY2FzZSBcIkNlbnRlclJpZ2h0XCIgLyogQ2VudGVyUmlnaHQgKi86XG4gICAgICBhbGlnbkl0ZW1zID0gXCJjZW50ZXJcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJCb3R0b21MZWZ0XCIgLyogQm90dG9tTGVmdCAqLzpcbiAgICBjYXNlIFwiQm90dG9tQ2VudGVyXCIgLyogQm90dG9tQ2VudGVyICovOlxuICAgIGNhc2UgXCJCb3R0b21SaWdodFwiIC8qIEJvdHRvbVJpZ2h0ICovOlxuICAgICAgYWxpZ25JdGVtcyA9IFwiZmxleC1lbmRcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGxldCBqdXN0aWZ5Q29udGVudDtcbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlIFwiVG9wTGVmdFwiIC8qIFRvcExlZnQgKi86XG4gICAgY2FzZSBcIkNlbnRlckxlZnRcIiAvKiBDZW50ZXJMZWZ0ICovOlxuICAgIGNhc2UgXCJCb3R0b21MZWZ0XCIgLyogQm90dG9tTGVmdCAqLzpcbiAgICAgIGp1c3RpZnlDb250ZW50ID0gXCJmbGV4LXN0YXJ0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiVG9wQ2VudGVyXCIgLyogVG9wQ2VudGVyICovOlxuICAgIGNhc2UgXCJDZW50ZXJDZW50ZXJcIiAvKiBDZW50ZXJDZW50ZXIgKi86XG4gICAgY2FzZSBcIkJvdHRvbUNlbnRlclwiIC8qIEJvdHRvbUNlbnRlciAqLzpcbiAgICAgIGp1c3RpZnlDb250ZW50ID0gXCJjZW50ZXJcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJUb3BSaWdodFwiIC8qIFRvcFJpZ2h0ICovOlxuICAgIGNhc2UgXCJDZW50ZXJSaWdodFwiIC8qIENlbnRlclJpZ2h0ICovOlxuICAgIGNhc2UgXCJCb3R0b21SaWdodFwiIC8qIEJvdHRvbVJpZ2h0ICovOlxuICAgICAganVzdGlmeUNvbnRlbnQgPSBcImZsZXgtZW5kXCI7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4geyBhbGlnbkl0ZW1zLCBqdXN0aWZ5Q29udGVudCB9O1xufTtcbnZhciBnZXRDb250cm9sQ29udGFpbmVyU3R5bGVzID0gKHBvcykgPT4ge1xuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGdldENvbnRyb2xDb250YWluZXJGbGV4U3R5bGVzKHBvcykpLCBjb21tb25TdHlsZXMpO1xufTtcblxuLy8gc3JjL2NvbnRyb2xzLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDUgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBjb250cm9sc01hcCA9IFtcbiAgeyBmdW5jTmFtZTogXCJyZW5kZXJUb3BMZWZ0Q29udHJvbHNcIiwga2V5OiBcIlRvcExlZnRcIiAvKiBUb3BMZWZ0ICovIH0sXG4gIHsgZnVuY05hbWU6IFwicmVuZGVyVG9wQ2VudGVyQ29udHJvbHNcIiwga2V5OiBcIlRvcENlbnRlclwiIC8qIFRvcENlbnRlciAqLyB9LFxuICB7IGZ1bmNOYW1lOiBcInJlbmRlclRvcFJpZ2h0Q29udHJvbHNcIiwga2V5OiBcIlRvcFJpZ2h0XCIgLyogVG9wUmlnaHQgKi8gfSxcbiAgeyBmdW5jTmFtZTogXCJyZW5kZXJDZW50ZXJMZWZ0Q29udHJvbHNcIiwga2V5OiBcIkNlbnRlckxlZnRcIiAvKiBDZW50ZXJMZWZ0ICovIH0sXG4gIHsgZnVuY05hbWU6IFwicmVuZGVyQ2VudGVyQ2VudGVyQ29udHJvbHNcIiwga2V5OiBcIkNlbnRlckNlbnRlclwiIC8qIENlbnRlckNlbnRlciAqLyB9LFxuICB7IGZ1bmNOYW1lOiBcInJlbmRlckNlbnRlclJpZ2h0Q29udHJvbHNcIiwga2V5OiBcIkNlbnRlclJpZ2h0XCIgLyogQ2VudGVyUmlnaHQgKi8gfSxcbiAgeyBmdW5jTmFtZTogXCJyZW5kZXJCb3R0b21MZWZ0Q29udHJvbHNcIiwga2V5OiBcIkJvdHRvbUxlZnRcIiAvKiBCb3R0b21MZWZ0ICovIH0sXG4gIHsgZnVuY05hbWU6IFwicmVuZGVyQm90dG9tQ2VudGVyQ29udHJvbHNcIiwga2V5OiBcIkJvdHRvbUNlbnRlclwiIC8qIEJvdHRvbUNlbnRlciAqLyB9LFxuICB7IGZ1bmNOYW1lOiBcInJlbmRlckJvdHRvbVJpZ2h0Q29udHJvbHNcIiwga2V5OiBcIkJvdHRvbVJpZ2h0XCIgLyogQm90dG9tUmlnaHQgKi8gfVxuXTtcbnZhciByZW5kZXJDb250cm9scyA9IChwcm9wcywgc2xpZGVDb3VudCwgY3VycmVudFNsaWRlLCBnb1RvU2xpZGUsIG5leHRTbGlkZSwgcHJldlNsaWRlLCBzbGlkZXNUb1Njcm9sbCkgPT4ge1xuICBpZiAocHJvcHMud2l0aG91dENvbnRyb2xzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZGlzYWJsZUNoZWNrUHJvcHMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcyksIHtcbiAgICBjdXJyZW50U2xpZGUsXG4gICAgc2xpZGVDb3VudFxuICB9KTtcbiAgY29uc3QgbmV4dERpc2FibGVkID0gbmV4dEJ1dHRvbkRpc2FibGVkKGRpc2FibGVDaGVja1Byb3BzKTtcbiAgY29uc3QgcHJldmlvdXNEaXNhYmxlZCA9IHByZXZCdXR0b25EaXNhYmxlZChkaXNhYmxlQ2hlY2tQcm9wcyk7XG4gIGNvbnN0IHBhZ2luZ0RvdHNJbmRpY2VzID0gZ2V0RG90SW5kZXhlcyhcbiAgICBzbGlkZUNvdW50LFxuICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgIHByb3BzLnNjcm9sbE1vZGUsXG4gICAgcHJvcHMuc2xpZGVzVG9TaG93LFxuICAgIHByb3BzLndyYXBBcm91bmQsXG4gICAgcHJvcHMuY2VsbEFsaWduXG4gICk7XG4gIHJldHVybiBjb250cm9sc01hcC5tYXAoKGNvbnRyb2wpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFwcm9wc1tjb250cm9sLmZ1bmNOYW1lXSB8fCB0eXBlb2YgcHJvcHNbY29udHJvbC5mdW5jTmFtZV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g1KEZyYWdtZW50LCB7fSwgY29udHJvbC5mdW5jTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NShcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBnZXRDb250cm9sQ29udGFpbmVyU3R5bGVzKGNvbnRyb2wua2V5KSksIHtcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgICAgICB9KSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g1KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgIGBzbGlkZXItY29udHJvbC0ke2NvbnRyb2wua2V5LnRvTG93ZXJDYXNlKCl9YCxcbiAgICAgICAgICAgICAgcHJvcHMuZGVmYXVsdENvbnRyb2xzQ29uZmlnLmNvbnRhaW5lckNsYXNzTmFtZSB8fCBcIlwiXG4gICAgICAgICAgICBdLmpvaW4oXCIgXCIpLnRyaW0oKSxcbiAgICAgICAgICAgIHN0eWxlOiB7IHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogKF9hID0gcHJvcHNbY29udHJvbC5mdW5jTmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHByb3BzLCB7XG4gICAgICAgICAgICAgIGNlbGxBbGlnbjogcHJvcHMuY2VsbEFsaWduLFxuICAgICAgICAgICAgICBjZWxsU3BhY2luZzogcHJvcHMuY2VsbFNwYWNpbmcsXG4gICAgICAgICAgICAgIGN1cnJlbnRTbGlkZSxcbiAgICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xzQ29uZmlnOiBwcm9wcy5kZWZhdWx0Q29udHJvbHNDb25maWcgfHwge30sXG4gICAgICAgICAgICAgIGNhcm91c2VsSWQ6IHByb3BzLmNhcm91c2VsSWQsXG4gICAgICAgICAgICAgIHBhZ2luZ0RvdHNJbmRpY2VzLFxuICAgICAgICAgICAgICBnb1RvU2xpZGUsXG4gICAgICAgICAgICAgIG5leHREaXNhYmxlZCxcbiAgICAgICAgICAgICAgbmV4dFNsaWRlLFxuICAgICAgICAgICAgICBvblVzZXJOYXZpZ2F0aW9uOiBwcm9wcy5vblVzZXJOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICBwcmV2aW91c0Rpc2FibGVkLFxuICAgICAgICAgICAgICBwcmV2aW91c1NsaWRlOiBwcmV2U2xpZGUsXG4gICAgICAgICAgICAgIHNjcm9sbE1vZGU6IHByb3BzLnNjcm9sbE1vZGUsXG4gICAgICAgICAgICAgIHNsaWRlQ291bnQsXG4gICAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgICAgICAgICBzbGlkZXNUb1Nob3c6IHByb3BzLnNsaWRlc1RvU2hvdyB8fCAxLFxuICAgICAgICAgICAgICB0YWJiZWQ6IHByb3BzLnRhYmJlZCxcbiAgICAgICAgICAgICAgdmVydGljYWw6IHByb3BzLnZlcnRpY2FsLFxuICAgICAgICAgICAgICB3cmFwQXJvdW5kOiBwcm9wcy53cmFwQXJvdW5kXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGNvbnRyb2wuZnVuY05hbWVcbiAgICApO1xuICB9KTtcbn07XG52YXIgY29udHJvbHNfZGVmYXVsdCA9IHJlbmRlckNvbnRyb2xzO1xuXG4vLyBzcmMvZGVmYXVsdC1jYXJvdXNlbC1wcm9wcy50c3hcbmltcG9ydCB7IEZyYWdtZW50IGFzIEZyYWdtZW50MiwganN4IGFzIGpzeDYgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBlYXNlT3V0ID0gKHQpID0+IF9fcG93KHQgLSAxLCAzKSArIDE7XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBhZGFwdGl2ZUhlaWdodDogZmFsc2UsXG4gIGFkYXB0aXZlSGVpZ2h0QW5pbWF0aW9uOiB0cnVlLFxuICBhZnRlclNsaWRlOiAoKSA9PiB7XG4gIH0sXG4gIGF1dG9wbGF5OiBmYWxzZSxcbiAgYXV0b3BsYXlJbnRlcnZhbDogM2UzLFxuICBhdXRvcGxheVJldmVyc2U6IGZhbHNlLFxuICBiZWZvcmVTbGlkZTogKCkgPT4ge1xuICB9LFxuICBjZWxsQWxpZ246IFwibGVmdFwiLFxuICBjZWxsU3BhY2luZzogMCxcbiAgZGVmYXVsdENvbnRyb2xzQ29uZmlnOiB7fSxcbiAgZGlzYWJsZUFuaW1hdGlvbjogZmFsc2UsXG4gIGRpc2FibGVFZGdlU3dpcGluZzogZmFsc2UsXG4gIGRyYWdnaW5nOiB0cnVlLFxuICBkcmFnVGhyZXNob2xkOiAwLjUsXG4gIGVhc2luZzogZWFzZU91dCxcbiAgZWRnZUVhc2luZzogZWFzZU91dCxcbiAgZW5hYmxlS2V5Ym9hcmRDb250cm9sczogZmFsc2UsXG4gIGZyYW1lQXJpYUxhYmVsOiBcIlNsaWRlclwiLFxuICBrZXlDb2RlQ29uZmlnOiB7XG4gICAgbmV4dFNsaWRlOiBbMzksIDY4LCAzOCwgODddLFxuICAgIHByZXZpb3VzU2xpZGU6IFszNywgNjUsIDQwLCA4M10sXG4gICAgZmlyc3RTbGlkZTogWzgxXSxcbiAgICBsYXN0U2xpZGU6IFs2OV0sXG4gICAgcGF1c2U6IFszMl1cbiAgfSxcbiAgbGFuZG1hcms6IGZhbHNlLFxuICBvbkRyYWdTdGFydDogKCkgPT4ge1xuICB9LFxuICBvbkRyYWc6ICgpID0+IHtcbiAgfSxcbiAgb25EcmFnRW5kOiAoKSA9PiB7XG4gIH0sXG4gIG9uVXNlck5hdmlnYXRpb246ICgpID0+IHtcbiAgfSxcbiAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuICByZW5kZXJBbm5vdW5jZVNsaWRlTWVzc2FnZTogZGVmYXVsdFJlbmRlckFubm91bmNlU2xpZGVNZXNzYWdlLFxuICByZW5kZXJCb3R0b21DZW50ZXJDb250cm9sczogKHByb3BzKSA9PiAvKiBAX19QVVJFX18gKi8ganN4NihQYWdpbmdEb3RzLCBfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpKSxcbiAgcmVuZGVyQ2VudGVyTGVmdENvbnRyb2xzOiAocHJvcHMpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3g2KFByZXZpb3VzQnV0dG9uLCBfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpKSxcbiAgcmVuZGVyQ2VudGVyUmlnaHRDb250cm9sczogKHByb3BzKSA9PiAvKiBAX19QVVJFX18gKi8ganN4NihOZXh0QnV0dG9uLCBfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpKSxcbiAgc2Nyb2xsTW9kZTogXCJwYWdlXCIgLyogcGFnZSAqLyxcbiAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gIHNsaWRlc1RvU2hvdzogMSxcbiAgc3BlZWQ6IDUwMCxcbiAgc3R5bGU6IHt9LFxuICBzd2lwaW5nOiB0cnVlLFxuICB0YWJiZWQ6IHRydWUsXG4gIHZlcnRpY2FsOiBmYWxzZSxcbiAgd2l0aG91dENvbnRyb2xzOiBmYWxzZSxcbiAgd3JhcEFyb3VuZDogZmFsc2UsXG4gIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NihGcmFnbWVudDIsIHt9KVxufTtcbnZhciBkZWZhdWx0X2Nhcm91c2VsX3Byb3BzX2RlZmF1bHQgPSBkZWZhdWx0UHJvcHM7XG5cbi8vIHNyYy9ob29rcy91c2UtZnJhbWUtaGVpZ2h0LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazMsIHVzZU1lbW8sIHVzZVN0YXRlIGFzIHVzZVN0YXRlNCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvaG9va3MvdXNlLXN0YXRlLXdpdGgtcmVmLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZVJlZiBhcyB1c2VSZWY0LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTMgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VTdGF0ZVdpdGhSZWYgPSAoaW5pdGlhbFN0YXRlKSA9PiB7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUzKGluaXRpYWxTdGF0ZSk7XG4gIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmNChpbml0aWFsU3RhdGUpO1xuICBjb25zdCBzZXRWYWx1ZUFuZFJlZiA9IHVzZUNhbGxiYWNrMigobmV3VmFsdWUpID0+IHtcbiAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV3VmFsdWU7XG4gICAgc2V0VmFsdWUobmV3VmFsdWUpO1xuICB9LCBbXSk7XG4gIHJldHVybiBbdmFsdWUsIHNldFZhbHVlQW5kUmVmLCB2YWx1ZVJlZl07XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlLWZyYW1lLWhlaWdodC50c1xudmFyIHVzZUZyYW1lSGVpZ2h0ID0gKGFkYXB0aXZlSGVpZ2h0LCBzbGlkZXNUb1Nob3csIHNsaWRlQ291bnQpID0+IHtcbiAgY29uc3QgW3Zpc2libGVIZWlnaHRzLCBzZXRWaXNpYmxlSGVpZ2h0cywgdmlzaWJsZUhlaWdodHNSZWZdID0gdXNlU3RhdGVXaXRoUmVmKFtdKTtcbiAgY29uc3QgW2luaXRpYWxpemVkQWRhcHRpdmVIZWlnaHQsIHNldEluaXRpYWxpemVkQWRhcHRpdmVIZWlnaHRdID0gdXNlU3RhdGU0KGZhbHNlKTtcbiAgY29uc3QgaGFuZGxlVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlID0gdXNlQ2FsbGJhY2szKFxuICAgIChzbGlkZUluZGV4LCBoZWlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGxhdGVzdFZpc2libGVIZWlnaHRzID0gdmlzaWJsZUhlaWdodHNSZWYuY3VycmVudDtcbiAgICAgIGxldCBuZXdWaXNpYmxlSGVpZ2h0cztcbiAgICAgIGlmIChoZWlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgbmV3VmlzaWJsZUhlaWdodHMgPSBsYXRlc3RWaXNpYmxlSGVpZ2h0cy5maWx0ZXIoXG4gICAgICAgICAgKHNsaWRlSGVpZ2h0KSA9PiBzbGlkZUhlaWdodC5zbGlkZUluZGV4ICE9PSBzbGlkZUluZGV4XG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWaXNpYmxlSGVpZ2h0cyA9IFsuLi5sYXRlc3RWaXNpYmxlSGVpZ2h0cywgeyBzbGlkZUluZGV4LCBoZWlnaHQgfV07XG4gICAgICB9XG4gICAgICBzZXRWaXNpYmxlSGVpZ2h0cyhuZXdWaXNpYmxlSGVpZ2h0cyk7XG4gICAgICBpZiAobmV3VmlzaWJsZUhlaWdodHMubGVuZ3RoID49IE1hdGgubWluKHNsaWRlQ291bnQsIE1hdGguY2VpbChzbGlkZXNUb1Nob3cpKSkge1xuICAgICAgICBzZXRJbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0KHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3NsaWRlQ291bnQsIHNldFZpc2libGVIZWlnaHRzLCBzbGlkZXNUb1Nob3csIHZpc2libGVIZWlnaHRzUmVmXVxuICApO1xuICBjb25zdCBmcmFtZUhlaWdodCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChhZGFwdGl2ZUhlaWdodCkge1xuICAgICAgaWYgKCFpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBcImF1dG9cIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IE1hdGgubWF4KFxuICAgICAgICAwLFxuICAgICAgICAuLi52aXNpYmxlSGVpZ2h0cy5tYXAoKGhlaWdodCkgPT4gaGVpZ2h0LmhlaWdodClcbiAgICAgICk7XG4gICAgICByZXR1cm4gYCR7bWF4SGVpZ2h0fXB4YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiYXV0b1wiO1xuICAgIH1cbiAgfSwgW2FkYXB0aXZlSGVpZ2h0LCBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0LCB2aXNpYmxlSGVpZ2h0c10pO1xuICByZXR1cm4ge1xuICAgIGhhbmRsZVZpc2libGVTbGlkZUhlaWdodENoYW5nZSxcbiAgICBmcmFtZUhlaWdodCxcbiAgICBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0XG4gIH07XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlLWZvcndhcmQtcmVmLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NSwgdXNlUmVmIGFzIHVzZVJlZjUgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VGb3J3YXJkUmVmID0gKHJlZikgPT4ge1xuICBjb25zdCB0YXJnZXRSZWYgPSB1c2VSZWY1KG51bGwpO1xuICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICBpZiAoIXJlZilcbiAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZWYodGFyZ2V0UmVmLmN1cnJlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IHRhcmdldFJlZi5jdXJyZW50O1xuICAgIH1cbiAgfSwgW3JlZl0pO1xuICByZXR1cm4gdGFyZ2V0UmVmO1xufTtcblxuLy8gc3JjL2Nhcm91c2VsLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDcsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBDYXJvdXNlbCA9IFJlYWN0NS5mb3J3YXJkUmVmKFxuICAocmF3UHJvcHMsIHJlZikgPT4ge1xuICAgIGNvbnN0IHByb3BzID0gcmF3UHJvcHM7XG4gICAgY29uc3QgaW50ZXJuYWxDYXJvdXNlbElkID0gdXNlSWQoKTtcbiAgICBjb25zdCB7XG4gICAgICBhZGFwdGl2ZUhlaWdodCxcbiAgICAgIGFkYXB0aXZlSGVpZ2h0QW5pbWF0aW9uLFxuICAgICAgYWZ0ZXJTbGlkZSxcbiAgICAgIGFuaW1hdGlvbixcbiAgICAgIGF1dG9wbGF5LFxuICAgICAgYXV0b3BsYXlJbnRlcnZhbCxcbiAgICAgIGF1dG9wbGF5UmV2ZXJzZSxcbiAgICAgIGJlZm9yZVNsaWRlLFxuICAgICAgY2Fyb3VzZWxJZCA9IGludGVybmFsQ2Fyb3VzZWxJZCxcbiAgICAgIGNlbGxBbGlnbjogcHJvcHNDZWxsQWxpZ24sXG4gICAgICBjZWxsU3BhY2luZyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgZGlzYWJsZUFuaW1hdGlvbixcbiAgICAgIGRyYWdnaW5nOiBkZXNrdG9wRHJhZ2dpbmdFbmFibGVkLFxuICAgICAgZHJhZ1RocmVzaG9sZDogcHJvcHNEcmFnVGhyZXNob2xkLFxuICAgICAgZW5hYmxlS2V5Ym9hcmRDb250cm9scyxcbiAgICAgIGZyYW1lQXJpYUxhYmVsLFxuICAgICAga2V5Q29kZUNvbmZpZyxcbiAgICAgIGxhbmRtYXJrLFxuICAgICAgb25EcmFnLFxuICAgICAgb25EcmFnRW5kLFxuICAgICAgb25EcmFnU3RhcnQsXG4gICAgICBvblVzZXJOYXZpZ2F0aW9uLFxuICAgICAgcGF1c2VPbkhvdmVyLFxuICAgICAgcmVuZGVyQW5ub3VuY2VTbGlkZU1lc3NhZ2UsXG4gICAgICBzY3JvbGxNb2RlOiBwcm9wc1Njcm9sbE1vZGUsXG4gICAgICBzbGlkZUluZGV4LFxuICAgICAgc2xpZGVzVG9TY3JvbGw6IHByb3BzU2xpZGVzVG9TY3JvbGwsXG4gICAgICBzbGlkZXNUb1Nob3c6IHByb3BzU2xpZGVzVG9TaG93LFxuICAgICAgc2xpZGVXaWR0aCxcbiAgICAgIHNwZWVkLFxuICAgICAgc3R5bGUsXG4gICAgICBzd2lwaW5nOiBtb2JpbGVEcmFnZ2luZ0VuYWJsZWQsXG4gICAgICB0YWJiZWQsXG4gICAgICB3cmFwQXJvdW5kLFxuICAgICAgem9vbVNjYWxlXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IGZpbHRlcmVkU2xpZGVzID0gUmVhY3Q1LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBzbGlkZUNvdW50ID0gZmlsdGVyZWRTbGlkZXMubGVuZ3RoO1xuICAgIGNvbnN0IGNlbGxBbGlnbiA9IHNsaWRlV2lkdGggfHwgcHJvcHNTbGlkZXNUb1Njcm9sbCA9PT0gXCJhdXRvXCIgPyBcImxlZnRcIiA6IHByb3BzQ2VsbEFsaWduO1xuICAgIGNvbnN0IHNjcm9sbE1vZGUgPSBwcm9wc1NsaWRlc1RvU2Nyb2xsID09PSBcImF1dG9cIiA/IFwicmVtYWluZGVyXCIgLyogcmVtYWluZGVyICovIDogcHJvcHNTY3JvbGxNb2RlO1xuICAgIGNvbnN0IFtzbGlkZUlPRW50cmllcywgc2V0U2xpZGVJT0VudHJpZXNdID0gdXNlU3RhdGU1KFxuICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICAgICk7XG4gICAgY29uc3QgdmlzaWJsZUNvdW50ID0gQXJyYXkuZnJvbShzbGlkZUlPRW50cmllcykuZmlsdGVyKFxuICAgICAgKFssIHZpc2libGVdKSA9PiB2aXNpYmxlXG4gICAgKS5sZW5ndGg7XG4gICAgY29uc3QgW2NvbnN0YW50VmlzaWJsZUNvdW50LCBzZXRDb25zdGFudFZpc2libGVDb3VudF0gPSB1c2VTdGF0ZTUodmlzaWJsZUNvdW50KTtcbiAgICBjb25zdCBzbGlkZXNUb1Nob3cgPSBzbGlkZVdpZHRoID8gY29uc3RhbnRWaXNpYmxlQ291bnQgOiBwcm9wc1NsaWRlc1RvU2hvdztcbiAgICBjb25zdCBzbGlkZXNUb1Njcm9sbCA9IGFuaW1hdGlvbiA9PT0gXCJmYWRlXCIgPyBzbGlkZXNUb1Nob3cgOiBwcm9wc1NsaWRlc1RvU2Nyb2xsID09PSBcImF1dG9cIiA/IE1hdGgubWF4KGNvbnN0YW50VmlzaWJsZUNvdW50LCAxKSA6IHByb3BzU2xpZGVzVG9TY3JvbGw7XG4gICAgY29uc3QgW2N1cnJlbnRTbGlkZSwgc2V0Q3VycmVudFNsaWRlXSA9IHVzZVN0YXRlNShcbiAgICAgICgpID0+IGdldERlZmF1bHRTbGlkZUluZGV4KFxuICAgICAgICBzbGlkZUluZGV4LFxuICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICBzbGlkZXNUb1Nob3csXG4gICAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgICBjZWxsQWxpZ24sXG4gICAgICAgIGF1dG9wbGF5UmV2ZXJzZSxcbiAgICAgICAgc2Nyb2xsTW9kZVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3QgW3BhdXNlLCBzZXRQYXVzZV0gPSB1c2VTdGF0ZTUoZmFsc2UpO1xuICAgIGNvbnN0IFtpc0RyYWdnaW5nLCBzZXRJc0RyYWdnaW5nXSA9IHVzZVN0YXRlNShmYWxzZSk7XG4gICAgY29uc3QgW2RyYWdEaXN0YW5jZSwgc2V0RHJhZ0Rpc3RhbmNlXSA9IHVzZVN0YXRlNSgwKTtcbiAgICBjb25zdCBbYW5pbWF0aW9uRGlzdGFuY2UsIHNldEFuaW1hdGlvbkRpc3RhbmNlXSA9IHVzZVN0YXRlNSgwKTtcbiAgICBjb25zdCBbaXNBbmltYXRpbmcsIHNldElzQW5pbWF0aW5nXSA9IHVzZVN0YXRlNShmYWxzZSk7XG4gICAgY29uc3QgdXBkYXRlU2xpZGVJT0VudHJ5ID0gdXNlQ2FsbGJhY2s0KFxuICAgICAgKGlkLCBpc0Z1bGx5VmlzaWJsZSkgPT4ge1xuICAgICAgICBpZiAoISFzbGlkZUlPRW50cmllcy5nZXQoaWQpID09PSBpc0Z1bGx5VmlzaWJsZSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldFNsaWRlSU9FbnRyaWVzKChwcmV2KSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3TWFwID0gbmV3IE1hcChwcmV2KTtcbiAgICAgICAgICBuZXdNYXAuc2V0KGlkLCBpc0Z1bGx5VmlzaWJsZSk7XG4gICAgICAgICAgcmV0dXJuIG5ld01hcDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgW3NsaWRlSU9FbnRyaWVzXVxuICAgICk7XG4gICAgY29uc3QgcHJldkRyYWdnZWQgPSB1c2VSZWY2KGZhbHNlKTtcbiAgICB1c2VFZmZlY3Q2KCgpID0+IHtcbiAgICAgIGlmIChpc0RyYWdnaW5nKVxuICAgICAgICBwcmV2RHJhZ2dlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGlmICghKGlzRHJhZ2dpbmcgfHwgaXNBbmltYXRpbmcpKSB7XG4gICAgICAgIGlmICghcHJldkRyYWdnZWQuY3VycmVudClcbiAgICAgICAgICBzZXRDb25zdGFudFZpc2libGVDb3VudCh2aXNpYmxlQ291bnQpO1xuICAgICAgICBwcmV2RHJhZ2dlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSwgW2lzQW5pbWF0aW5nLCBpc0RyYWdnaW5nLCB2aXNpYmxlQ291bnRdKTtcbiAgICBjb25zdCBwcmV2WFBvc2l0aW9uID0gdXNlUmVmNihudWxsKTtcbiAgICBjb25zdCBwcmVEcmFnT2Zmc2V0ID0gdXNlUmVmNigwKTtcbiAgICBjb25zdCBzbGlkZXJMaXN0UmVmID0gdXNlUmVmNihudWxsKTtcbiAgICBjb25zdCBkZWZhdWx0Q2Fyb3VzZWxSZWYgPSB1c2VSZWY2KG51bGwpO1xuICAgIGNvbnN0IGF1dG9wbGF5VGltZW91dCA9IHVzZVJlZjYoKTtcbiAgICBjb25zdCBhdXRvcGxheUxhc3RUcmlnZ2VyZWRSZWYgPSB1c2VSZWY2KG51bGwpO1xuICAgIGNvbnN0IGlzTW91bnRlZCA9IHVzZVJlZjYodHJ1ZSk7XG4gICAgY29uc3Qgc2V0U2xpZGVyTGlzdFJlZiA9IHVzZUNhbGxiYWNrNCgobm9kZSkgPT4ge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiLnNsaWRlci1saXN0IGltZ1wiKS5mb3JFYWNoKChlbCkgPT4gZWwuc2V0QXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIsIFwiZmFsc2VcIikpO1xuICAgICAgfVxuICAgICAgc2xpZGVyTGlzdFJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0NigoKSA9PiB7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZm9yd2FyZGVkUmVmID0gdXNlRm9yd2FyZFJlZihyZWYpO1xuICAgIGNvbnN0IGNhcm91c2VsUmVmID0gZm9yd2FyZGVkUmVmIHx8IGRlZmF1bHRDYXJvdXNlbFJlZjtcbiAgICBjb25zdCBnb1RvU2xpZGUgPSB1c2VDYWxsYmFjazQoXG4gICAgICAodGFyZ2V0U2xpZGVVbmJvdW5kZWQpID0+IHtcbiAgICAgICAgaWYgKCFzbGlkZXJMaXN0UmVmLmN1cnJlbnQgfHwgIWNhcm91c2VsUmVmLmN1cnJlbnQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB0YXJnZXRTbGlkZUJvdW5kZWQgPSBnZXRCb3VuZGVkSW5kZXgoXG4gICAgICAgICAgdGFyZ2V0U2xpZGVVbmJvdW5kZWQsXG4gICAgICAgICAgc2xpZGVDb3VudFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBzbGlkZUNoYW5nZWQgPSB0YXJnZXRTbGlkZVVuYm91bmRlZCAhPT0gY3VycmVudFNsaWRlO1xuICAgICAgICBzbGlkZUNoYW5nZWQgJiYgYmVmb3JlU2xpZGUoY3VycmVudFNsaWRlLCB0YXJnZXRTbGlkZUJvdW5kZWQpO1xuICAgICAgICBjb25zdCBjdXJyZW50T2Zmc2V0ID0gc2xpZGVyTGlzdFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBjYXJvdXNlbFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGNvbnN0IHNsaWRlcldpZHRoID0gc2xpZGVyTGlzdFJlZi5jdXJyZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBsZXQgdGFyZ2V0T2Zmc2V0ID0gZ2V0UGVyY2VudE9mZnNldEZvclNsaWRlKFxuICAgICAgICAgIHRhcmdldFNsaWRlQm91bmRlZCxcbiAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgICAgICBjZWxsQWxpZ24sXG4gICAgICAgICAgd3JhcEFyb3VuZFxuICAgICAgICApIC8gMTAwICogc2xpZGVyV2lkdGg7XG4gICAgICAgIGlmICh3cmFwQXJvdW5kKSB7XG4gICAgICAgICAgY29uc3Qgc2xpZGVTZXRXaWR0aCA9IHNsaWRlcldpZHRoIC8gMztcbiAgICAgICAgICBpZiAodGFyZ2V0U2xpZGVVbmJvdW5kZWQgPCAwKSB7XG4gICAgICAgICAgICB0YXJnZXRPZmZzZXQgKz0gc2xpZGVTZXRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRhcmdldFNsaWRlVW5ib3VuZGVkID49IHNsaWRlQ291bnQpIHtcbiAgICAgICAgICAgIHRhcmdldE9mZnNldCAtPSBzbGlkZVNldFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRBbmltYXRpb25EaXN0YW5jZSh0YXJnZXRPZmZzZXQgLSBjdXJyZW50T2Zmc2V0KTtcbiAgICAgICAgaWYgKHNsaWRlQ2hhbmdlZCkge1xuICAgICAgICAgIHNldEN1cnJlbnRTbGlkZSh0YXJnZXRTbGlkZUJvdW5kZWQpO1xuICAgICAgICAgIGNvbnN0IG1zVG9FbmRPZkFuaW1hdGlvbiA9ICFkaXNhYmxlQW5pbWF0aW9uID8gc3BlZWQgfHwgNTAwIDogNDA7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzTW91bnRlZC5jdXJyZW50KVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhZnRlclNsaWRlKHRhcmdldFNsaWRlQm91bmRlZCk7XG4gICAgICAgICAgfSwgbXNUb0VuZE9mQW5pbWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgYWZ0ZXJTbGlkZSxcbiAgICAgICAgYmVmb3JlU2xpZGUsXG4gICAgICAgIGNhcm91c2VsUmVmLFxuICAgICAgICBjZWxsQWxpZ24sXG4gICAgICAgIGN1cnJlbnRTbGlkZSxcbiAgICAgICAgZGlzYWJsZUFuaW1hdGlvbixcbiAgICAgICAgc3BlZWQsXG4gICAgICAgIHNsaWRlQ291bnQsXG4gICAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgICAgd3JhcEFyb3VuZFxuICAgICAgXVxuICAgICk7XG4gICAgY29uc3QgbmV4dFNsaWRlID0gdXNlQ2FsbGJhY2s0KCgpID0+IHtcbiAgICAgIGNvbnN0IG5leHRTbGlkZUluZGV4ID0gZ2V0TmV4dE1vdmVJbmRleChcbiAgICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgICAgd3JhcEFyb3VuZCxcbiAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgc2xpZGVzVG9TaG93LFxuICAgICAgICBjZWxsQWxpZ25cbiAgICAgICk7XG4gICAgICBpZiAoY3VycmVudFNsaWRlICE9PSBuZXh0U2xpZGVJbmRleCkge1xuICAgICAgICBnb1RvU2xpZGUobmV4dFNsaWRlSW5kZXgpO1xuICAgICAgfVxuICAgIH0sIFtcbiAgICAgIGNlbGxBbGlnbixcbiAgICAgIGN1cnJlbnRTbGlkZSxcbiAgICAgIGdvVG9TbGlkZSxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgIHNsaWRlQ291bnQsXG4gICAgICBzbGlkZXNUb1Nob3csXG4gICAgICB3cmFwQXJvdW5kXG4gICAgXSk7XG4gICAgY29uc3QgcHJldlNsaWRlID0gdXNlQ2FsbGJhY2s0KCgpID0+IHtcbiAgICAgIGNvbnN0IHByZXZTbGlkZUluZGV4ID0gZ2V0UHJldk1vdmVJbmRleChcbiAgICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgICAgd3JhcEFyb3VuZCxcbiAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgc2xpZGVzVG9TaG93LFxuICAgICAgICBjZWxsQWxpZ25cbiAgICAgICk7XG4gICAgICBpZiAoY3VycmVudFNsaWRlICE9PSBwcmV2U2xpZGVJbmRleCkge1xuICAgICAgICBnb1RvU2xpZGUocHJldlNsaWRlSW5kZXgpO1xuICAgICAgfVxuICAgIH0sIFtcbiAgICAgIGNlbGxBbGlnbixcbiAgICAgIGN1cnJlbnRTbGlkZSxcbiAgICAgIGdvVG9TbGlkZSxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgIHdyYXBBcm91bmRcbiAgICBdKTtcbiAgICBjb25zdCBwcmV2TW92ZWRUb1NsaWRlSW5kZXggPSB1c2VSZWY2KHNsaWRlSW5kZXgpO1xuICAgIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgICAgaWYgKHNsaWRlSW5kZXggIT09IHZvaWQgMCAmJiBzbGlkZUluZGV4ICE9PSBwcmV2TW92ZWRUb1NsaWRlSW5kZXguY3VycmVudCAmJiAhYXV0b3BsYXlSZXZlcnNlKSB7XG4gICAgICAgIGdvVG9TbGlkZShzbGlkZUluZGV4KTtcbiAgICAgICAgcHJldk1vdmVkVG9TbGlkZUluZGV4LmN1cnJlbnQgPSBzbGlkZUluZGV4O1xuICAgICAgfVxuICAgIH0sIFtzbGlkZUluZGV4LCBhdXRvcGxheVJldmVyc2UsIGdvVG9TbGlkZV0pO1xuICAgIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgICAgbGV0IHBhdXNlU3RhcnRlZCA9IG51bGw7XG4gICAgICBpZiAocGF1c2UpIHtcbiAgICAgICAgcGF1c2VTdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChwYXVzZVN0YXJ0ZWQgIT09IG51bGwgJiYgYXV0b3BsYXlMYXN0VHJpZ2dlcmVkUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBhdXRvcGxheUxhc3RUcmlnZ2VyZWRSZWYuY3VycmVudCArPSBEYXRlLm5vdygpIC0gcGF1c2VTdGFydGVkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIFtwYXVzZV0pO1xuICAgIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgICAgaWYgKGF1dG9wbGF5ICYmICFwYXVzZSkge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFRpbWVvdXRNcyA9IGF1dG9wbGF5TGFzdFRyaWdnZXJlZFJlZi5jdXJyZW50ICE9PSBudWxsID8gYXV0b3BsYXlJbnRlcnZhbCAtIChEYXRlLm5vdygpIC0gYXV0b3BsYXlMYXN0VHJpZ2dlcmVkUmVmLmN1cnJlbnQpIDogYXV0b3BsYXlJbnRlcnZhbDtcbiAgICAgICAgYXV0b3BsYXlUaW1lb3V0LmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBhdXRvcGxheUxhc3RUcmlnZ2VyZWRSZWYuY3VycmVudCA9IERhdGUubm93KCk7XG4gICAgICAgICAgaWYgKGF1dG9wbGF5UmV2ZXJzZSkge1xuICAgICAgICAgICAgcHJldlNsaWRlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRTbGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgYWRqdXN0ZWRUaW1lb3V0TXMpO1xuICAgICAgfVxuICAgICAgaWYgKGF1dG9wbGF5ICYmIHBhdXNlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhdXRvcGxheVRpbWVvdXQuY3VycmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoYXV0b3BsYXlUaW1lb3V0LmN1cnJlbnQpO1xuICAgICAgfTtcbiAgICB9LCBbXG4gICAgICBwYXVzZSxcbiAgICAgIGF1dG9wbGF5LFxuICAgICAgYXV0b3BsYXlJbnRlcnZhbCxcbiAgICAgIGF1dG9wbGF5UmV2ZXJzZSxcbiAgICAgIHByZXZTbGlkZSxcbiAgICAgIG5leHRTbGlkZVxuICAgIF0pO1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgbGV0IGtleUNvbW1hbmQgPSBudWxsO1xuICAgICAgT2JqZWN0LmtleXMoa2V5Q29kZUNvbmZpZykuZm9yRWFjaChcbiAgICAgICAgKGNvbW1hbmQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgaWYgKChfYSA9IGtleUNvZGVDb25maWdbY29tbWFuZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhldmVudC5rZXlDb2RlKSkge1xuICAgICAgICAgICAga2V5Q29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKGtleUNvbW1hbmQgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHN3aXRjaCAoa2V5Q29tbWFuZCkge1xuICAgICAgICBjYXNlIFwibmV4dFNsaWRlXCI6XG4gICAgICAgICAgb25Vc2VyTmF2aWdhdGlvbihldmVudCk7XG4gICAgICAgICAgbmV4dFNsaWRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwcmV2aW91c1NsaWRlXCI6XG4gICAgICAgICAgb25Vc2VyTmF2aWdhdGlvbihldmVudCk7XG4gICAgICAgICAgcHJldlNsaWRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmaXJzdFNsaWRlXCI6XG4gICAgICAgIGNhc2UgXCJsYXN0U2xpZGVcIjoge1xuICAgICAgICAgIG9uVXNlck5hdmlnYXRpb24oZXZlbnQpO1xuICAgICAgICAgIGNvbnN0IGRvdEluZGljZXMgPSBnZXREb3RJbmRleGVzKFxuICAgICAgICAgICAgc2xpZGVDb3VudCxcbiAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgICAgICAgIHdyYXBBcm91bmQsXG4gICAgICAgICAgICBjZWxsQWxpZ25cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChrZXlDb21tYW5kID09PSBcImZpcnN0U2xpZGVcIikge1xuICAgICAgICAgICAgZ29Ub1NsaWRlKGRvdEluZGljZXNbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnb1RvU2xpZGUoZG90SW5kaWNlc1tkb3RJbmRpY2VzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBhdXNlXCI6XG4gICAgICAgICAgc2V0UGF1c2UoKHApID0+ICFwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRyYWdQb3NpdGlvbnMgPSB1c2VSZWY2KFtdKTtcbiAgICBjb25zdCBoYW5kbGVEcmFnRW5kID0gKGUpID0+IHtcbiAgICAgIGlmICghaXNEcmFnZ2luZyB8fCAhY2Fyb3VzZWxSZWYuY3VycmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgc2V0SXNEcmFnZ2luZyhmYWxzZSk7XG4gICAgICBsZXQgZGlzdGFuY2VGcm9tSW5lcnRpYSA9IDA7XG4gICAgICBpZiAoZHJhZ1Bvc2l0aW9ucy5jdXJyZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRNb3ZlID0gZHJhZ1Bvc2l0aW9ucy5jdXJyZW50WzBdO1xuICAgICAgICBjb25zdCBlbmRNb3ZlID0gZHJhZ1Bvc2l0aW9ucy5jdXJyZW50W2RyYWdQb3NpdGlvbnMuY3VycmVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgdGltZU9mZnNldCA9IGVuZE1vdmUudGltZSAtIHN0YXJ0TW92ZS50aW1lO1xuICAgICAgICBjb25zdCBnb29kSW5lcnRpYUZlZWxDb25zdGFudCA9IDk7XG4gICAgICAgIGNvbnN0IGdvb2RGcmljdGlvbkZlZWxDb25zdGFudCA9IDAuOTI7XG4gICAgICAgIGNvbnN0IGluaXRpYWxWZWxvY2l0eSA9IGdvb2RJbmVydGlhRmVlbENvbnN0YW50ICogTWF0aC5hYnMoKGVuZE1vdmUucG9zIC0gc3RhcnRNb3ZlLnBvcykgLyB0aW1lT2Zmc2V0KTtcbiAgICAgICAgbGV0IHZlbG9jaXR5ID0gaW5pdGlhbFZlbG9jaXR5O1xuICAgICAgICB3aGlsZSAoTWF0aC5hYnModmVsb2NpdHkpID4gMSkge1xuICAgICAgICAgIGRpc3RhbmNlRnJvbUluZXJ0aWEgKz0gdmVsb2NpdHk7XG4gICAgICAgICAgdmVsb2NpdHkgKj0gZ29vZEZyaWN0aW9uRmVlbENvbnN0YW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkcmFnUG9zaXRpb25zLmN1cnJlbnQgPSBbXTtcbiAgICAgIGNvbnN0IGFkanVzdGVkRHJhZ0Rpc3RhbmNlID0gTWF0aC5hYnMoZHJhZ0Rpc3RhbmNlKSArIE1hdGguYWJzKGRpc3RhbmNlRnJvbUluZXJ0aWEpO1xuICAgICAgb25EcmFnRW5kKGUpO1xuICAgICAgcHJldlhQb3NpdGlvbi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHNldERyYWdEaXN0YW5jZSgwKTtcbiAgICAgIGNvbnN0IG9uZVNjcm9sbFdpZHRoID0gY2Fyb3VzZWxSZWYuY3VycmVudC5vZmZzZXRXaWR0aCAqIE1hdGgubWluKDEsIHNsaWRlc1RvU2Nyb2xsIC8gc2xpZGVzVG9TaG93KTtcbiAgICAgIGNvbnN0IGRyYWdUaHJlc2hvbGQgPSBvbmVTY3JvbGxXaWR0aCAqIHByb3BzRHJhZ1RocmVzaG9sZDtcbiAgICAgIGlmIChhZGp1c3RlZERyYWdEaXN0YW5jZSA8IGRyYWdUaHJlc2hvbGQpIHtcbiAgICAgICAgZ29Ub1NsaWRlKGN1cnJlbnRTbGlkZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbk1haW50YWluVmlzdWFsQ29udGludWl0eSA9IHNsaWRlc1RvU2hvdyA+PSAyICogc2xpZGVzVG9TY3JvbGw7XG4gICAgICBjb25zdCB0aW1lc1RvTW92ZSA9IGNhbk1haW50YWluVmlzdWFsQ29udGludWl0eSA/IDEgKyBNYXRoLmZsb29yKChhZGp1c3RlZERyYWdEaXN0YW5jZSAtIGRyYWdUaHJlc2hvbGQpIC8gb25lU2Nyb2xsV2lkdGgpIDogMTtcbiAgICAgIGxldCBuZXh0U2xpZGVJbmRleCA9IGN1cnJlbnRTbGlkZTtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aW1lc1RvTW92ZTsgaW5kZXggKz0gMSkge1xuICAgICAgICBpZiAoZHJhZ0Rpc3RhbmNlID4gMCkge1xuICAgICAgICAgIG5leHRTbGlkZUluZGV4ID0gZ2V0TmV4dE1vdmVJbmRleChcbiAgICAgICAgICAgIHNjcm9sbE1vZGUsXG4gICAgICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICAgICAgbmV4dFNsaWRlSW5kZXgsXG4gICAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGwsXG4gICAgICAgICAgICBzbGlkZXNUb1Nob3csXG4gICAgICAgICAgICBjZWxsQWxpZ25cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRTbGlkZUluZGV4ID0gZ2V0UHJldk1vdmVJbmRleChcbiAgICAgICAgICAgIHNjcm9sbE1vZGUsXG4gICAgICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICAgICAgbmV4dFNsaWRlSW5kZXgsXG4gICAgICAgICAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgICAgICAgIGNlbGxBbGlnblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXh0U2xpZGVJbmRleCAhPT0gY3VycmVudFNsaWRlKSB7XG4gICAgICAgIG9uVXNlck5hdmlnYXRpb24oZSk7XG4gICAgICB9XG4gICAgICBnb1RvU2xpZGUobmV4dFNsaWRlSW5kZXgpO1xuICAgIH07XG4gICAgY29uc3Qgb25Ub3VjaFN0YXJ0ID0gdXNlQ2FsbGJhY2s0KFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgaWYgKCFtb2JpbGVEcmFnZ2luZ0VuYWJsZWQgfHwgIXNsaWRlckxpc3RSZWYuY3VycmVudCB8fCAhY2Fyb3VzZWxSZWYuY3VycmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRJc0RyYWdnaW5nKHRydWUpO1xuICAgICAgICBwcmVEcmFnT2Zmc2V0LmN1cnJlbnQgPSBzbGlkZXJMaXN0UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIGNhcm91c2VsUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgb25EcmFnU3RhcnQoZSk7XG4gICAgICB9LFxuICAgICAgW2Nhcm91c2VsUmVmLCBvbkRyYWdTdGFydCwgbW9iaWxlRHJhZ2dpbmdFbmFibGVkXVxuICAgICk7XG4gICAgY29uc3QgaGFuZGxlUG9pbnRlck1vdmUgPSB1c2VDYWxsYmFjazQoXG4gICAgICAoeFBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGlmICghaXNEcmFnZ2luZylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGlzRmlyc3RNb3ZlID0gcHJldlhQb3NpdGlvbi5jdXJyZW50ID09PSBudWxsO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHByZXZYUG9zaXRpb24uY3VycmVudCAhPT0gbnVsbCA/IHhQb3NpdGlvbiAtIHByZXZYUG9zaXRpb24uY3VycmVudCA6IDA7XG4gICAgICAgIGNvbnN0IG5leHREcmFnRGlzdGFuY2UgPSBkcmFnRGlzdGFuY2UgKyBkZWx0YTtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKGRyYWdQb3NpdGlvbnMuY3VycmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKG5vdyAtIGRyYWdQb3NpdGlvbnMuY3VycmVudFswXS50aW1lIDw9IDEwMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRyYWdQb3NpdGlvbnMuY3VycmVudC5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGRyYWdQb3NpdGlvbnMuY3VycmVudC5wdXNoKHsgcG9zOiBuZXh0RHJhZ0Rpc3RhbmNlLCB0aW1lOiBub3cgfSk7XG4gICAgICAgIGlmICghaXNGaXJzdE1vdmUpIHtcbiAgICAgICAgICBzZXREcmFnRGlzdGFuY2UobmV4dERyYWdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlhQb3NpdGlvbi5jdXJyZW50ID0geFBvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIFtpc0RyYWdnaW5nLCBkcmFnRGlzdGFuY2VdXG4gICAgKTtcbiAgICBjb25zdCBvblRvdWNoTW92ZSA9IHVzZUNhbGxiYWNrNChcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGlmICghaXNEcmFnZ2luZyB8fCAhY2Fyb3VzZWxSZWYuY3VycmVudClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIG9uRHJhZ1N0YXJ0KGUpO1xuICAgICAgICBjb25zdCBtb3ZlVmFsdWUgPSBjYXJvdXNlbFJlZi5jdXJyZW50Lm9mZnNldFdpZHRoIC0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICBoYW5kbGVQb2ludGVyTW92ZShtb3ZlVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIFtpc0RyYWdnaW5nLCBjYXJvdXNlbFJlZiwgaGFuZGxlUG9pbnRlck1vdmUsIG9uRHJhZ1N0YXJ0XVxuICAgICk7XG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSB1c2VDYWxsYmFjazQoXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBpZiAoIWRlc2t0b3BEcmFnZ2luZ0VuYWJsZWQgfHwgIXNsaWRlckxpc3RSZWYuY3VycmVudCB8fCAhY2Fyb3VzZWxSZWYuY3VycmVudClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldElzRHJhZ2dpbmcodHJ1ZSk7XG4gICAgICAgIHByZURyYWdPZmZzZXQuY3VycmVudCA9IHNsaWRlckxpc3RSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gY2Fyb3VzZWxSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICBvbkRyYWdTdGFydChlKTtcbiAgICAgIH0sXG4gICAgICBbY2Fyb3VzZWxSZWYsIGRlc2t0b3BEcmFnZ2luZ0VuYWJsZWQsIG9uRHJhZ1N0YXJ0XVxuICAgICk7XG4gICAgY29uc3Qgb25Nb3VzZU1vdmUgPSB1c2VDYWxsYmFjazQoXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBpZiAoIWlzRHJhZ2dpbmcgfHwgIWNhcm91c2VsUmVmLmN1cnJlbnQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvbkRyYWcoZSk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBlLmNsaWVudFggLSBjYXJvdXNlbFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGNvbnN0IG1vdmVWYWx1ZSA9IGNhcm91c2VsUmVmLmN1cnJlbnQub2Zmc2V0V2lkdGggLSBvZmZzZXRYO1xuICAgICAgICBoYW5kbGVQb2ludGVyTW92ZShtb3ZlVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIFtjYXJvdXNlbFJlZiwgaXNEcmFnZ2luZywgaGFuZGxlUG9pbnRlck1vdmUsIG9uRHJhZ11cbiAgICApO1xuICAgIGNvbnN0IG9uTW91c2VVcCA9IChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBoYW5kbGVEcmFnRW5kKGUpO1xuICAgIH07XG4gICAgY29uc3Qgb25Nb3VzZUVudGVyID0gdXNlQ2FsbGJhY2s0KCgpID0+IHtcbiAgICAgIGlmIChwYXVzZU9uSG92ZXIpIHtcbiAgICAgICAgc2V0UGF1c2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfSwgW3BhdXNlT25Ib3Zlcl0pO1xuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9IHVzZUNhbGxiYWNrNCgoKSA9PiB7XG4gICAgICBpZiAocGF1c2VPbkhvdmVyKSB7XG4gICAgICAgIHNldFBhdXNlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LCBbcGF1c2VPbkhvdmVyXSk7XG4gICAgY29uc3Qge1xuICAgICAgZnJhbWVIZWlnaHQsXG4gICAgICBoYW5kbGVWaXNpYmxlU2xpZGVIZWlnaHRDaGFuZ2UsXG4gICAgICBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0XG4gICAgfSA9IHVzZUZyYW1lSGVpZ2h0KGFkYXB0aXZlSGVpZ2h0LCBzbGlkZXNUb1Nob3csIHNsaWRlQ291bnQpO1xuICAgIGNvbnN0IHJlbmRlclNsaWRlcyA9ICh0eXBlT2ZTbGlkZSkgPT4ge1xuICAgICAgY29uc3Qgc2xpZGVzID0gZmlsdGVyZWRTbGlkZXMubWFwKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFxuICAgICAgICAgIHNsaWRlX2RlZmF1bHQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IGAke3R5cGVPZlNsaWRlfS0ke2luZGV4fWAsXG4gICAgICAgICAgICBjYXJvdXNlbElkLFxuICAgICAgICAgICAgY291bnQ6IHNsaWRlQ291bnQsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGlzQ3VycmVudFNsaWRlOiBjdXJyZW50U2xpZGUgPT09IGluZGV4LFxuICAgICAgICAgICAgdHlwZU9mU2xpZGUsXG4gICAgICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICAgICAgY2VsbFNwYWNpbmcsXG4gICAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAgICBzcGVlZCxcbiAgICAgICAgICAgIHpvb21TY2FsZSxcbiAgICAgICAgICAgIG9uVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlOiBoYW5kbGVWaXNpYmxlU2xpZGVIZWlnaHRDaGFuZ2UsXG4gICAgICAgICAgICBzbGlkZVdpZHRoLFxuICAgICAgICAgICAgdXBkYXRlSU9FbnRyeTogdXBkYXRlU2xpZGVJT0VudHJ5LFxuICAgICAgICAgICAgYWRhcHRpdmVIZWlnaHQsXG4gICAgICAgICAgICBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0LFxuICAgICAgICAgICAgY2Fyb3VzZWxSZWYsXG4gICAgICAgICAgICB0YWJiZWQsXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGAke3R5cGVPZlNsaWRlfS0ke2luZGV4fWBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNsaWRlcztcbiAgICB9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJzbGlkZXItY29udGFpbmVyXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRW50ZXIsXG4gICAgICAgIG9uTW91c2VMZWF2ZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGZyYW1lQXJpYUxhYmVsLFxuICAgICAgICByb2xlOiBsYW5kbWFyayA/IFwicmVnaW9uXCIgOiBcImdyb3VwXCIsXG4gICAgICAgIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJjYXJvdXNlbFwiLFxuICAgICAgICBpZDogY2Fyb3VzZWxJZCxcbiAgICAgICAgXCJkYXRhLXRlc3RpZFwiOiBjYXJvdXNlbElkLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFxuICAgICAgICAgICAgYW5ub3VuY2Vfc2xpZGVfZGVmYXVsdCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYXJpYUxpdmU6IGF1dG9wbGF5ICYmICFwYXVzZSA/IFwib2ZmXCIgOiBcInBvbGl0ZVwiLFxuICAgICAgICAgICAgICBtZXNzYWdlOiByZW5kZXJBbm5vdW5jZVNsaWRlTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICAgICAgICAgIGNvdW50OiBzbGlkZUNvdW50XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBjb250cm9sc19kZWZhdWx0KFxuICAgICAgICAgICAgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpLCB7IGNhcm91c2VsSWQgfSksXG4gICAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICAgICAgZ29Ub1NsaWRlLFxuICAgICAgICAgICAgbmV4dFNsaWRlLFxuICAgICAgICAgICAgcHJldlNsaWRlLFxuICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGxcbiAgICAgICAgICApLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBbXCJzbGlkZXItZnJhbWVcIiwgY2xhc3NOYW1lIHx8IFwiXCJdLmpvaW4oXCIgXCIpLnRyaW0oKSxcbiAgICAgICAgICAgICAgc3R5bGU6IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICB0b3VjaEFjdGlvbjogXCJwYW4teVwiLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZnJhbWVIZWlnaHQsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYWRhcHRpdmVIZWlnaHRBbmltYXRpb24gPyBcImhlaWdodCAzMDBtcyBlYXNlLWluLW91dFwiIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIHdpbGxDaGFuZ2U6IFwiaGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgdXNlclNlbGVjdDogXCJub25lXCJcbiAgICAgICAgICAgICAgfSwgc3R5bGUpLFxuICAgICAgICAgICAgICB0YWJJbmRleDogZW5hYmxlS2V5Ym9hcmRDb250cm9scyA/IDAgOiAtMSxcbiAgICAgICAgICAgICAgb25LZXlEb3duOiBlbmFibGVLZXlib2FyZENvbnRyb2xzID8gb25LZXlEb3duIDogdm9pZCAwLFxuICAgICAgICAgICAgICByZWY6IGNhcm91c2VsUmVmLFxuICAgICAgICAgICAgICBvbk1vdXNlVXAsXG4gICAgICAgICAgICAgIG9uTW91c2VEb3duLFxuICAgICAgICAgICAgICBvbk1vdXNlTW92ZSxcbiAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlVXAsXG4gICAgICAgICAgICAgIG9uVG91Y2hTdGFydCxcbiAgICAgICAgICAgICAgb25Ub3VjaEVuZDogaGFuZGxlRHJhZ0VuZCxcbiAgICAgICAgICAgICAgb25Ub3VjaE1vdmUsXG4gICAgICAgICAgICAgIGlkOiBgJHtjYXJvdXNlbElkfS1zbGlkZXItZnJhbWVgLFxuICAgICAgICAgICAgICBcImRhdGEtdGVzdGlkXCI6IGAke2Nhcm91c2VsSWR9LXNsaWRlci1mcmFtZWAsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgICAgICAgICAgICBTbGlkZXJMaXN0LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgY2VsbEFsaWduLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICAgICAgICAgICAgZGlzYWJsZUVkZ2VTd2lwaW5nOiBwcm9wcy5kaXNhYmxlRWRnZVN3aXBpbmcsXG4gICAgICAgICAgICAgICAgICBkcmFnZ2VkT2Zmc2V0OiBwcmVEcmFnT2Zmc2V0LmN1cnJlbnQgLSBkcmFnRGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlQW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgZWFzaW5nOiBwcm9wcy5lYXNpbmcsXG4gICAgICAgICAgICAgICAgICBlZGdlRWFzaW5nOiBwcm9wcy5lZGdlRWFzaW5nLFxuICAgICAgICAgICAgICAgICAgaXNEcmFnZ2luZyxcbiAgICAgICAgICAgICAgICAgIHJlZjogc2V0U2xpZGVyTGlzdFJlZixcbiAgICAgICAgICAgICAgICAgIHNjcm9sbE1vZGUsXG4gICAgICAgICAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGwsXG4gICAgICAgICAgICAgICAgICBzbGlkZXNUb1Nob3csXG4gICAgICAgICAgICAgICAgICBzcGVlZCxcbiAgICAgICAgICAgICAgICAgIHNsaWRlV2lkdGgsXG4gICAgICAgICAgICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICAgICAgICAgICAgc2V0SXNBbmltYXRpbmcsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICB3cmFwQXJvdW5kID8gcmVuZGVyU2xpZGVzKFwicHJldi1jbG9uZWRcIikgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJTbGlkZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgd3JhcEFyb3VuZCA/IHJlbmRlclNsaWRlcyhcIm5leHQtY2xvbmVkXCIpIDogbnVsbFxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5DYXJvdXNlbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0X2Nhcm91c2VsX3Byb3BzX2RlZmF1bHQ7XG5DYXJvdXNlbC5kaXNwbGF5TmFtZSA9IFwiQ2Fyb3VzZWxcIjtcbmV4cG9ydCB7XG4gIEFsaWdubWVudCxcbiAgRGlyZWN0aW9ucyxcbiAgTmV4dEJ1dHRvbixcbiAgUGFnaW5nRG90cyxcbiAgUG9zaXRpb25zLFxuICBQcmV2aW91c0J1dHRvbixcbiAgU2Nyb2xsTW9kZSxcbiAgQ2Fyb3VzZWwgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZlByb3BzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fZ2V0T3duUHJvcERlc2NzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fZ2V0T3duUHJvcFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fcHJvcElzRW51bSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19wb3ciLCJNYXRoIiwicG93IiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3NwcmVhZFZhbHVlcyIsImEiLCJiIiwicHJvcCIsImNhbGwiLCJfX3NwcmVhZFByb3BzIiwiUmVhY3Q1IiwidXNlRWZmZWN0IiwidXNlRWZmZWN0NiIsInVzZVN0YXRlIiwidXNlU3RhdGU1IiwidXNlUmVmIiwidXNlUmVmNiIsInVzZUNhbGxiYWNrIiwidXNlQ2FsbGJhY2s0IiwidXNlSWQiLCJ1c2VSZWYyIiwidXNlRWZmZWN0MiIsInVzZVNsaWRlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbGVtZW50UmVmIiwicm9vdFJlZiIsImNhbGxiYWNrIiwiZW50cnkiLCJzZXRFbnRyeSIsImNhbGxiYWNrUmVmIiwiY3VycmVudCIsIm5vZGUiLCJyb290Iiwid2luZG93IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlciIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkyIiwidGhyZXNob2xkIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJqc3giLCJnZXRTbGlkZVdpZHRoIiwiY291bnQiLCJ3cmFwQXJvdW5kIiwiZ2V0U2xpZGVTdHlsZXMiLCJpc0N1cnJlbnRTbGlkZSIsImlzVmlzaWJsZVNsaWRlIiwiY2VsbFNwYWNpbmciLCJhbmltYXRpb24iLCJzcGVlZCIsInpvb21TY2FsZSIsImFkYXB0aXZlSGVpZ2h0IiwiaW5pdGlhbGl6ZWRBZGFwdGl2ZUhlaWdodCIsInNsaWRlV2lkdGgiLCJ3aWR0aCIsInZpc2libGVTbGlkZU9wYWNpdHkiLCJhbmltYXRpb25TcGVlZCIsImhlaWdodCIsInBhZGRpbmciLCJ0cmFuc2l0aW9uIiwidHJhbnNmb3JtIiwib3BhY2l0eSIsImdlbmVyYXRlSW5kZXgiLCJpbmRleCIsInR5cGVPZlNsaWRlIiwiU2xpZGUiLCJjaGlsZHJlbiIsIm9uVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlIiwidXBkYXRlSU9FbnRyeSIsImlkIiwiY2Fyb3VzZWxSZWYiLCJjYXJvdXNlbElkIiwidGFiYmVkIiwiX2EiLCJjdXN0b21JbmRleCIsInNsaWRlUmVmIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJpc1Zpc2libGUiLCJpc0ludGVyc2VjdGluZyIsImlzRnVsbHlWaXNpYmxlIiwicHJldklzVmlzaWJsZVJlZiIsIl9hMiIsInNsaWRlSGVpZ2h0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicHJldklzVmlzaWJsZSIsImN1cnJlbnRTbGlkZUNsYXNzIiwicmVmIiwiaW5lcnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsInJvbGUiLCJzbGlkZV9kZWZhdWx0IiwianN4MiIsInN0eWxlcyIsInBvc2l0aW9uIiwib3ZlcmZsb3ciLCJtYXJnaW4iLCJjbGlwIiwid2hpdGVTcGFjZSIsImJvcmRlciIsIkFubm91bmNlU2xpZGUiLCJtZXNzYWdlIiwiYXJpYUxpdmUiLCJ0YWJJbmRleCIsImRlZmF1bHRSZW5kZXJBbm5vdW5jZVNsaWRlTWVzc2FnZSIsImN1cnJlbnRTbGlkZSIsImFubm91bmNlX3NsaWRlX2RlZmF1bHQiLCJSZWFjdDMiLCJ1c2VFZmZlY3Q0IiwiQWxpZ25tZW50IiwiQWxpZ25tZW50MiIsIkRpcmVjdGlvbnMiLCJEaXJlY3Rpb25zMiIsIlBvc2l0aW9ucyIsIlBvc2l0aW9uczIiLCJTY3JvbGxNb2RlIiwiU2Nyb2xsTW9kZTIiLCJnZXROZXh0TW92ZUluZGV4Iiwic2Nyb2xsTW9kZSIsInNsaWRlQ291bnQiLCJzbGlkZXNUb1Njcm9sbCIsInNsaWRlc1RvU2hvdyIsImNlbGxBbGlnbiIsIm1pbiIsImdldFByZXZNb3ZlSW5kZXgiLCJtYXgiLCJnZXREZWZhdWx0U2xpZGVJbmRleCIsInNsaWRlSW5kZXgiLCJhdXRvcGxheVJldmVyc2UiLCJkb3RJbmRleGVzIiwiZ2V0RG90SW5kZXhlcyIsImxlbmd0aCIsImdldEJvdW5kZWRJbmRleCIsInJhd0luZGV4IiwianN4MyIsImRlZmF1bHRCdXR0b25TdHlsZXMiLCJkaXNhYmxlZCIsImJhY2tncm91bmQiLCJjb2xvciIsInRleHRUcmFuc2Zvcm0iLCJjdXJzb3IiLCJwcmV2QnV0dG9uRGlzYWJsZWQiLCJQcmV2aW91c0J1dHRvbiIsInByZXZpb3VzU2xpZGUiLCJkZWZhdWx0Q29udHJvbHNDb25maWciLCJwcmV2QnV0dG9uQ2xhc3NOYW1lIiwicHJldkJ1dHRvblN0eWxlIiwicHJldkJ1dHRvblRleHQiLCJwcmV2QnV0dG9uT25DbGljayIsIm9uVXNlck5hdmlnYXRpb24iLCJwcmV2aW91c0Rpc2FibGVkIiwiaGFuZGxlQ2xpY2siLCJldmVudCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwcmV2ZW50RGVmYXVsdCIsIm9uQ2xpY2siLCJ0eXBlIiwibmV4dEJ1dHRvbkRpc2FibGVkIiwiTmV4dEJ1dHRvbiIsIm5leHRTbGlkZSIsIm5leHRCdXR0b25DbGFzc05hbWUiLCJuZXh0QnV0dG9uU3R5bGUiLCJuZXh0QnV0dG9uVGV4dCIsIm5leHRCdXR0b25PbkNsaWNrIiwibmV4dERpc2FibGVkIiwic2Nyb2xsU2xpZGVzIiwiaSIsInB1c2giLCJsYXN0UG9zc2libGVJbmRleFdpdGhvdXRXaGl0ZXNwYWNlIiwiZmlyc3RQb3NzaWJsZUluZGV4V2l0aG91dFdoaXRlc3BhY2UiLCJyZXZlcnNlIiwiUGFnaW5nRG90cyIsInBhZ2luZ0RvdHNJbmRpY2VzIiwicGFnaW5nRG90c0NvbnRhaW5lckNsYXNzTmFtZSIsInBhZ2luZ0RvdHNDbGFzc05hbWUiLCJwYWdpbmdEb3RzU3R5bGUiLCJwYWdpbmdEb3RzT25DbGljayIsImdvVG9TbGlkZSIsImxpc3RTdHlsZXMiLCJ0b3AiLCJkaXNwbGF5IiwibGlzdFN0eWxlVHlwZSIsImdldEJ1dHRvblN0eWxlcyIsImFjdGl2ZSIsImZpbGwiLCJjdXJyZW50U2xpZGVCb3VuZGVkIiwibWFwIiwiaXNBY3RpdmUiLCJqb2luIiwiZm9jdXNhYmxlIiwidmlld0JveCIsImN4IiwiY3kiLCJyIiwidXNlRWZmZWN0MyIsInVzZVN0YXRlMiIsInVzZVJlZjMiLCJ1c2VUd2VlbiIsImR1cmF0aW9uTXMiLCJlYXNpbmdGdW5jdGlvbiIsIm5hdmlnYXRpb25OdW0iLCJzaG91bGRJbnRlcnJ1cHQiLCJub3JtYWxpemVkVGltZVJhdyIsInNldE5vcm1hbGl6ZWRUaW1lIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJBRiIsImlzRmlyc3RSZW5kZXIiLCJsYXN0TmF2aWdhdGlvbk51bSIsIm5vcm1hbGl6ZWRUaW1lIiwidGljayIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImN1cnJlbnRUaW1lIiwibm9ybWFsaXplZFRpbWUyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpc0FuaW1hdGluZyIsImpzeDQiLCJnZXRQZXJjZW50T2Zmc2V0Rm9yU2xpZGUiLCJyZW5kZXJlZFNsaWRlQ291bnQiLCJzaW5nbGVTbGlkZVBlcmNlbnRPZldob2xlIiwic2xpZGUwT2Zmc2V0IiwiZXhjZXNzU2xpZGVzIiwiZXhjZXNzTGVmdFNsaWRlcyIsImN1cnJlbnRTbGlkZU9mZnNldEZyb20wIiwiU2xpZGVyTGlzdCIsImZvcndhcmRSZWYiLCJhbmltYXRpb25EaXN0YW5jZSIsImRpc2FibGVBbmltYXRpb24iLCJkaXNhYmxlRWRnZVN3aXBpbmciLCJkcmFnZ2VkT2Zmc2V0IiwiZWFzaW5nIiwiZWRnZUVhc2luZyIsImlzRHJhZ2dpbmciLCJzZXRJc0FuaW1hdGluZyIsImZvcndhcmRlZFJlZiIsImxpc3RWaXNpYmxlV2lkdGgiLCJwZXJjZW50T2Zmc2V0Rm9yU2xpZGVQcm9wcyIsImNsYW1wZWREcmFnZ2VkT2Zmc2V0IiwiY2xhbXBPZmZzZXRzIiwic2xpZGVCYXNlZE9mZnNldCIsImlzRWRnZUVhc2luZyIsInBvc2l0aW9uaW5nIiwidHJhbnNpdGlvbk9mZnNldCIsInRleHRBbGlnbiIsInVzZXJTZWxlY3QiLCJkaXNwbGF5TmFtZSIsIkZyYWdtZW50IiwiY29tbW9uU3R5bGVzIiwiekluZGV4IiwibGVmdCIsImJvdHRvbSIsInJpZ2h0IiwiZ2V0Q29udHJvbENvbnRhaW5lckZsZXhTdHlsZXMiLCJwb3MiLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJnZXRDb250cm9sQ29udGFpbmVyU3R5bGVzIiwianN4NSIsImNvbnRyb2xzTWFwIiwiZnVuY05hbWUiLCJyZW5kZXJDb250cm9scyIsInByb3BzIiwicHJldlNsaWRlIiwid2l0aG91dENvbnRyb2xzIiwiZGlzYWJsZUNoZWNrUHJvcHMiLCJjb250cm9sIiwicG9pbnRlckV2ZW50cyIsInRvTG93ZXJDYXNlIiwiY29udGFpbmVyQ2xhc3NOYW1lIiwidHJpbSIsInZlcnRpY2FsIiwiY29udHJvbHNfZGVmYXVsdCIsIkZyYWdtZW50MiIsImpzeDYiLCJlYXNlT3V0IiwidCIsImRlZmF1bHRQcm9wcyIsImFkYXB0aXZlSGVpZ2h0QW5pbWF0aW9uIiwiYWZ0ZXJTbGlkZSIsImF1dG9wbGF5IiwiYXV0b3BsYXlJbnRlcnZhbCIsImJlZm9yZVNsaWRlIiwiZHJhZ2dpbmciLCJkcmFnVGhyZXNob2xkIiwiZW5hYmxlS2V5Ym9hcmRDb250cm9scyIsImZyYW1lQXJpYUxhYmVsIiwia2V5Q29kZUNvbmZpZyIsImZpcnN0U2xpZGUiLCJsYXN0U2xpZGUiLCJwYXVzZSIsImxhbmRtYXJrIiwib25EcmFnU3RhcnQiLCJvbkRyYWciLCJvbkRyYWdFbmQiLCJwYXVzZU9uSG92ZXIiLCJyZW5kZXJBbm5vdW5jZVNsaWRlTWVzc2FnZSIsInJlbmRlckJvdHRvbUNlbnRlckNvbnRyb2xzIiwicmVuZGVyQ2VudGVyTGVmdENvbnRyb2xzIiwicmVuZGVyQ2VudGVyUmlnaHRDb250cm9scyIsInN3aXBpbmciLCJkZWZhdWx0X2Nhcm91c2VsX3Byb3BzX2RlZmF1bHQiLCJ1c2VDYWxsYmFjazMiLCJ1c2VNZW1vIiwidXNlU3RhdGU0IiwidXNlQ2FsbGJhY2syIiwidXNlUmVmNCIsInVzZVN0YXRlMyIsInVzZVN0YXRlV2l0aFJlZiIsImluaXRpYWxTdGF0ZSIsInNldFZhbHVlIiwidmFsdWVSZWYiLCJzZXRWYWx1ZUFuZFJlZiIsIm5ld1ZhbHVlIiwidXNlRnJhbWVIZWlnaHQiLCJ2aXNpYmxlSGVpZ2h0cyIsInNldFZpc2libGVIZWlnaHRzIiwidmlzaWJsZUhlaWdodHNSZWYiLCJzZXRJbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0IiwiaGFuZGxlVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlIiwibGF0ZXN0VmlzaWJsZUhlaWdodHMiLCJuZXdWaXNpYmxlSGVpZ2h0cyIsImZpbHRlciIsImNlaWwiLCJmcmFtZUhlaWdodCIsIm1heEhlaWdodCIsInVzZUVmZmVjdDUiLCJ1c2VSZWY1IiwidXNlRm9yd2FyZFJlZiIsInRhcmdldFJlZiIsImpzeDciLCJqc3hzIiwiQ2Fyb3VzZWwiLCJyYXdQcm9wcyIsImludGVybmFsQ2Fyb3VzZWxJZCIsInByb3BzQ2VsbEFsaWduIiwiZGVza3RvcERyYWdnaW5nRW5hYmxlZCIsInByb3BzRHJhZ1RocmVzaG9sZCIsInByb3BzU2Nyb2xsTW9kZSIsInByb3BzU2xpZGVzVG9TY3JvbGwiLCJwcm9wc1NsaWRlc1RvU2hvdyIsIm1vYmlsZURyYWdnaW5nRW5hYmxlZCIsImZpbHRlcmVkU2xpZGVzIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiQm9vbGVhbiIsInNsaWRlSU9FbnRyaWVzIiwic2V0U2xpZGVJT0VudHJpZXMiLCJNYXAiLCJ2aXNpYmxlQ291bnQiLCJBcnJheSIsImZyb20iLCJ2aXNpYmxlIiwiY29uc3RhbnRWaXNpYmxlQ291bnQiLCJzZXRDb25zdGFudFZpc2libGVDb3VudCIsInNldEN1cnJlbnRTbGlkZSIsInNldFBhdXNlIiwic2V0SXNEcmFnZ2luZyIsImRyYWdEaXN0YW5jZSIsInNldERyYWdEaXN0YW5jZSIsInNldEFuaW1hdGlvbkRpc3RhbmNlIiwidXBkYXRlU2xpZGVJT0VudHJ5IiwiZ2V0IiwicHJldiIsIm5ld01hcCIsInNldCIsInByZXZEcmFnZ2VkIiwicHJldlhQb3NpdGlvbiIsInByZURyYWdPZmZzZXQiLCJzbGlkZXJMaXN0UmVmIiwiZGVmYXVsdENhcm91c2VsUmVmIiwiYXV0b3BsYXlUaW1lb3V0IiwiYXV0b3BsYXlMYXN0VHJpZ2dlcmVkUmVmIiwiaXNNb3VudGVkIiwic2V0U2xpZGVyTGlzdFJlZiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJlbCIsInNldEF0dHJpYnV0ZSIsInRhcmdldFNsaWRlVW5ib3VuZGVkIiwidGFyZ2V0U2xpZGVCb3VuZGVkIiwic2xpZGVDaGFuZ2VkIiwiY3VycmVudE9mZnNldCIsInNsaWRlcldpZHRoIiwib2Zmc2V0V2lkdGgiLCJ0YXJnZXRPZmZzZXQiLCJzbGlkZVNldFdpZHRoIiwibXNUb0VuZE9mQW5pbWF0aW9uIiwic2V0VGltZW91dCIsIm5leHRTbGlkZUluZGV4IiwicHJldlNsaWRlSW5kZXgiLCJwcmV2TW92ZWRUb1NsaWRlSW5kZXgiLCJwYXVzZVN0YXJ0ZWQiLCJhZGp1c3RlZFRpbWVvdXRNcyIsImNsZWFyVGltZW91dCIsIm9uS2V5RG93biIsImtleUNvbW1hbmQiLCJrZXlzIiwiY29tbWFuZCIsImluY2x1ZGVzIiwia2V5Q29kZSIsInN0b3BQcm9wYWdhdGlvbiIsImRvdEluZGljZXMiLCJwIiwiZHJhZ1Bvc2l0aW9ucyIsImhhbmRsZURyYWdFbmQiLCJlIiwiZGlzdGFuY2VGcm9tSW5lcnRpYSIsInN0YXJ0TW92ZSIsImVuZE1vdmUiLCJ0aW1lT2Zmc2V0IiwidGltZSIsImdvb2RJbmVydGlhRmVlbENvbnN0YW50IiwiZ29vZEZyaWN0aW9uRmVlbENvbnN0YW50IiwiaW5pdGlhbFZlbG9jaXR5IiwiYWJzIiwidmVsb2NpdHkiLCJhZGp1c3RlZERyYWdEaXN0YW5jZSIsIm9uZVNjcm9sbFdpZHRoIiwiY2FuTWFpbnRhaW5WaXN1YWxDb250aW51aXR5IiwidGltZXNUb01vdmUiLCJmbG9vciIsIm9uVG91Y2hTdGFydCIsImhhbmRsZVBvaW50ZXJNb3ZlIiwieFBvc2l0aW9uIiwiaXNGaXJzdE1vdmUiLCJkZWx0YSIsIm5leHREcmFnRGlzdGFuY2UiLCJzaGlmdCIsIm9uVG91Y2hNb3ZlIiwibW92ZVZhbHVlIiwidG91Y2hlcyIsInBhZ2VYIiwib25Nb3VzZURvd24iLCJvbk1vdXNlTW92ZSIsIm9mZnNldFgiLCJjbGllbnRYIiwib25Nb3VzZVVwIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwicmVuZGVyU2xpZGVzIiwic2xpZGVzIiwiY2hpbGQiLCJvdXRsaW5lIiwidG91Y2hBY3Rpb24iLCJ3aWxsQ2hhbmdlIiwib25Ub3VjaEVuZCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nuka-carousel/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/nuka-carousel/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/nuka-carousel/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Alignment: () => (/* binding */ Alignment),\n/* harmony export */   Directions: () => (/* binding */ Directions),\n/* harmony export */   NextButton: () => (/* binding */ NextButton),\n/* harmony export */   PagingDots: () => (/* binding */ PagingDots),\n/* harmony export */   Positions: () => (/* binding */ Positions),\n/* harmony export */   PreviousButton: () => (/* binding */ PreviousButton),\n/* harmony export */   ScrollMode: () => (/* binding */ ScrollMode),\n/* harmony export */   \"default\": () => (/* binding */ Carousel)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __pow = Math.pow;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __spreadValues = (a, b)=>{\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));\n// src/carousel.tsx\n\n// src/slide.tsx\n\n// src/hooks/use-slide-intersection-observer.ts\n\nvar useSlideIntersectionObserver = (elementRef, rootRef, callback)=>{\n    const [entry, setEntry] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(callback);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        callbackRef.current = callback;\n    }, [\n        callback\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const node = elementRef == null ? void 0 : elementRef.current;\n        const root = rootRef == null ? void 0 : rootRef.current;\n        if (!window.IntersectionObserver || !node || !root) return;\n        const observer = new IntersectionObserver((entries)=>{\n            entries.forEach((entry2)=>{\n                setEntry(entry2);\n                callbackRef.current(entry2);\n            });\n        }, {\n            threshold: [\n                0.05,\n                0.95\n            ],\n            root\n        });\n        observer.observe(node);\n        return ()=>observer.disconnect();\n    }, [\n        elementRef,\n        rootRef\n    ]);\n    return entry;\n};\n// src/slide.tsx\n\nvar getSlideWidth = (count, wrapAround)=>`${wrapAround ? 100 / (3 * count) : 100 / count}%`;\nvar getSlideStyles = (count, isCurrentSlide, isVisibleSlide, wrapAround, cellSpacing, animation, speed, zoomScale, adaptiveHeight, initializedAdaptiveHeight, slideWidth)=>{\n    const width = slideWidth != null ? slideWidth : getSlideWidth(count, wrapAround);\n    const visibleSlideOpacity = isVisibleSlide ? 1 : 0;\n    const animationSpeed = animation === \"fade\" ? 200 : 500;\n    let height = \"auto\";\n    if (adaptiveHeight) {\n        if (initializedAdaptiveHeight) {\n            height = \"100%\";\n        } else if (isVisibleSlide) {\n            height = \"auto\";\n        } else {\n            height = \"0\";\n        }\n    }\n    return {\n        width,\n        height,\n        padding: `0 ${cellSpacing ? cellSpacing / 2 : 0}px`,\n        transition: animation ? `${speed || animationSpeed}ms ease 0s` : void 0,\n        transform: animation === \"zoom\" ? `scale(${isCurrentSlide && isVisibleSlide ? 1 : zoomScale || 0.85})` : void 0,\n        opacity: animation === \"fade\" ? visibleSlideOpacity : 1\n    };\n};\nvar generateIndex = (index, count, typeOfSlide)=>{\n    if (typeOfSlide === \"prev-cloned\") {\n        return index - count;\n    }\n    if (typeOfSlide === \"next-cloned\") {\n        return index + count;\n    }\n    return index;\n};\nvar Slide = ({ count, children, index, isCurrentSlide, typeOfSlide, wrapAround, cellSpacing, slideWidth, animation, speed, zoomScale, onVisibleSlideHeightChange, adaptiveHeight, initializedAdaptiveHeight, updateIOEntry, id, carouselRef, carouselId, tabbed })=>{\n    var _a;\n    const customIndex = wrapAround ? generateIndex(index, count, typeOfSlide) : index;\n    const slideRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const entry = useSlideIntersectionObserver(slideRef, carouselRef, (entry2)=>{\n        updateIOEntry(id, (entry2 == null ? void 0 : entry2.intersectionRatio) >= 0.95);\n    });\n    const isVisible = !!(entry == null ? void 0 : entry.isIntersecting);\n    const isFullyVisible = ((_a = entry == null ? void 0 : entry.intersectionRatio) != null ? _a : 1) >= 0.95;\n    const prevIsVisibleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a2;\n        const node = slideRef.current;\n        if (node) {\n            const slideHeight = (_a2 = node.getBoundingClientRect()) == null ? void 0 : _a2.height;\n            const prevIsVisible = prevIsVisibleRef.current;\n            if (isVisible && !prevIsVisible) {\n                onVisibleSlideHeightChange(customIndex, slideHeight);\n            } else if (!isVisible && prevIsVisible) {\n                onVisibleSlideHeightChange(customIndex, null);\n            }\n            prevIsVisibleRef.current = isVisible;\n        }\n    }, [\n        customIndex,\n        isVisible,\n        onVisibleSlideHeightChange\n    ]);\n    const currentSlideClass = isCurrentSlide && isFullyVisible ? \" slide-current\" : \"\";\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", __spreadProps(__spreadValues({\n        ref: slideRef\n    }, {\n        inert: isFullyVisible ? void 0 : \"true\"\n    }), {\n        className: `slide${currentSlideClass}${typeOfSlide ? ` ${typeOfSlide}` : \"\"}${isFullyVisible ? \" slide-visible\" : \"\"}`,\n        style: getSlideStyles(count, isCurrentSlide, isFullyVisible, wrapAround, cellSpacing, animation, speed, zoomScale, adaptiveHeight, initializedAdaptiveHeight, slideWidth),\n        id: typeOfSlide ? void 0 : `${carouselId}-slide-${index + 1}`,\n        role: tabbed ? \"tabpanel\" : \"group\",\n        \"aria-roledescription\": tabbed ? void 0 : \"slide\",\n        children\n    }));\n};\nvar slide_default = Slide;\n// src/announce-slide.tsx\n\nvar styles = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    overflow: \"hidden\",\n    padding: 0,\n    margin: \"-1px\",\n    clip: \"rect(0, 0, 0, 0)\",\n    whiteSpace: \"nowrap\",\n    border: 0\n};\nvar AnnounceSlide = ({ message, ariaLive = \"polite\" })=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        \"aria-live\": ariaLive,\n        \"aria-atomic\": \"true\",\n        style: styles,\n        tabIndex: -1,\n        children: message\n    });\nvar defaultRenderAnnounceSlideMessage = ({ currentSlide, count })=>`Slide ${currentSlide + 1} of ${count}`;\nvar announce_slide_default = AnnounceSlide;\n// src/slider-list.tsx\n\n// src/default-controls.tsx\n\n// src/types.ts\nvar Alignment = /* @__PURE__ */ ((Alignment2)=>{\n    Alignment2[\"Center\"] = \"center\";\n    Alignment2[\"Right\"] = \"right\";\n    Alignment2[\"Left\"] = \"left\";\n    return Alignment2;\n})(Alignment || {});\nvar Directions = /* @__PURE__ */ ((Directions2)=>{\n    Directions2[\"Next\"] = \"next\";\n    Directions2[\"Prev\"] = \"prev\";\n    Directions2[\"Up\"] = \"up\";\n    Directions2[\"Down\"] = \"down\";\n    return Directions2;\n})(Directions || {});\nvar Positions = /* @__PURE__ */ ((Positions2)=>{\n    Positions2[\"TopLeft\"] = \"TopLeft\";\n    Positions2[\"TopCenter\"] = \"TopCenter\";\n    Positions2[\"TopRight\"] = \"TopRight\";\n    Positions2[\"CenterLeft\"] = \"CenterLeft\";\n    Positions2[\"CenterCenter\"] = \"CenterCenter\";\n    Positions2[\"CenterRight\"] = \"CenterRight\";\n    Positions2[\"BottomLeft\"] = \"BottomLeft\";\n    Positions2[\"BottomCenter\"] = \"BottomCenter\";\n    Positions2[\"BottomRight\"] = \"BottomRight\";\n    return Positions2;\n})(Positions || {});\nvar ScrollMode = /* @__PURE__ */ ((ScrollMode2)=>{\n    ScrollMode2[\"page\"] = \"page\";\n    ScrollMode2[\"remainder\"] = \"remainder\";\n    return ScrollMode2;\n})(ScrollMode || {});\n// src/utils.ts\nvar getNextMoveIndex = (scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign)=>{\n    if (wrapAround) {\n        return currentSlide + slidesToScroll;\n    }\n    if (currentSlide >= slideCount - 1 || cellAlign === \"left\" && currentSlide >= slideCount - slidesToShow) {\n        return currentSlide;\n    }\n    if (scrollMode === \"remainder\" /* remainder */  && cellAlign === \"left\") {\n        return Math.min(currentSlide + slidesToScroll, slideCount - slidesToShow);\n    }\n    return Math.min(currentSlide + slidesToScroll, slideCount - 1);\n};\nvar getPrevMoveIndex = (scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign)=>{\n    if (wrapAround) {\n        return currentSlide - slidesToScroll;\n    }\n    if (currentSlide <= 0 || cellAlign === \"right\" && currentSlide <= slidesToShow - 1) {\n        return currentSlide;\n    }\n    if (scrollMode === \"remainder\" /* remainder */  && cellAlign === \"right\") {\n        return Math.max(currentSlide - slidesToScroll, slidesToShow - 1);\n    }\n    return Math.max(currentSlide - slidesToScroll, 0);\n};\nvar getDefaultSlideIndex = (slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode)=>{\n    if (slideIndex !== void 0) {\n        return slideIndex;\n    }\n    const dotIndexes = getDotIndexes(slideCount, slidesToScroll, scrollMode, slidesToShow, false, cellAlign);\n    return autoplayReverse ? dotIndexes[dotIndexes.length - 1] : dotIndexes[0];\n};\nvar getBoundedIndex = (rawIndex, slideCount)=>{\n    return (rawIndex % slideCount + slideCount) % slideCount;\n};\n// src/default-controls.tsx\n\nvar defaultButtonStyles = (disabled)=>({\n        border: 0,\n        background: \"rgba(0,0,0,0.4)\",\n        color: \"white\",\n        padding: 10,\n        textTransform: \"uppercase\",\n        opacity: disabled ? 0.3 : 1,\n        cursor: disabled ? \"not-allowed\" : \"pointer\"\n    });\nvar prevButtonDisabled = ({ cellAlign, currentSlide, slidesToShow, wrapAround })=>{\n    if (wrapAround) {\n        return false;\n    }\n    if (currentSlide === 0) {\n        return true;\n    }\n    if (cellAlign === \"right\" && currentSlide <= slidesToShow - 1) {\n        return true;\n    }\n    return false;\n};\nvar PreviousButton = ({ previousSlide, defaultControlsConfig: { prevButtonClassName, prevButtonStyle = {}, prevButtonText, prevButtonOnClick }, onUserNavigation, carouselId, previousDisabled: disabled })=>{\n    const handleClick = (event)=>{\n        prevButtonOnClick == null ? void 0 : prevButtonOnClick(event);\n        if (event.defaultPrevented) return;\n        onUserNavigation(event);\n        event.preventDefault();\n        previousSlide();\n    };\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n        className: prevButtonClassName,\n        style: __spreadValues(__spreadValues({}, defaultButtonStyles(disabled)), prevButtonStyle),\n        disabled,\n        onClick: handleClick,\n        \"aria-label\": \"previous\",\n        \"aria-controls\": `${carouselId}-slider-frame`,\n        type: \"button\",\n        children: prevButtonText || \"Prev\"\n    });\n};\nvar nextButtonDisabled = ({ cellAlign, currentSlide, slideCount, slidesToShow, wrapAround })=>{\n    if (wrapAround) {\n        return false;\n    }\n    if (currentSlide >= slideCount - 1) {\n        return true;\n    }\n    if (cellAlign === \"left\" && currentSlide >= slideCount - slidesToShow) {\n        return true;\n    }\n    return false;\n};\nvar NextButton = ({ nextSlide, defaultControlsConfig: { nextButtonClassName, nextButtonStyle = {}, nextButtonText, nextButtonOnClick }, carouselId, nextDisabled: disabled, onUserNavigation })=>{\n    const handleClick = (event)=>{\n        nextButtonOnClick == null ? void 0 : nextButtonOnClick(event);\n        if (event.defaultPrevented) return;\n        onUserNavigation(event);\n        event.preventDefault();\n        nextSlide();\n    };\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n        className: nextButtonClassName,\n        style: __spreadValues(__spreadValues({}, defaultButtonStyles(disabled)), nextButtonStyle),\n        disabled,\n        onClick: handleClick,\n        \"aria-label\": \"next\",\n        \"aria-controls\": `${carouselId}-slider-frame`,\n        type: \"button\",\n        children: nextButtonText || \"Next\"\n    });\n};\nvar getDotIndexes = (slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign)=>{\n    const dotIndexes = [];\n    const scrollSlides = slidesToScroll <= 0 ? 1 : slidesToScroll;\n    if (wrapAround) {\n        for(let i = 0; i < slideCount; i += scrollSlides){\n            dotIndexes.push(i);\n        }\n        return dotIndexes;\n    }\n    if (cellAlign === \"center\") {\n        for(let i = 0; i < slideCount - 1; i += scrollSlides){\n            dotIndexes.push(i);\n        }\n        if (slideCount > 0) {\n            dotIndexes.push(slideCount - 1);\n        }\n        return dotIndexes;\n    }\n    if (cellAlign === \"left\") {\n        if (slidesToShow >= slideCount) {\n            return [\n                0\n            ];\n        }\n        const lastPossibleIndexWithoutWhitespace = slideCount - slidesToShow;\n        for(let i = 0; i < lastPossibleIndexWithoutWhitespace; i += scrollSlides){\n            dotIndexes.push(i);\n        }\n        if (scrollMode === \"remainder\" /* remainder */ ) {\n            dotIndexes.push(lastPossibleIndexWithoutWhitespace);\n        } else {\n            dotIndexes.push(dotIndexes[dotIndexes.length - 1] + scrollSlides);\n        }\n        return dotIndexes;\n    }\n    if (cellAlign === \"right\") {\n        if (slidesToShow >= slideCount) {\n            return [\n                slideCount - 1\n            ];\n        }\n        const firstPossibleIndexWithoutWhitespace = slidesToShow - 1;\n        if (scrollMode === \"remainder\" /* remainder */ ) {\n            for(let i = firstPossibleIndexWithoutWhitespace; i < slideCount - 1; i += scrollSlides){\n                dotIndexes.push(i);\n            }\n            dotIndexes.push(slideCount - 1);\n        } else {\n            for(let i = slideCount - 1; i > firstPossibleIndexWithoutWhitespace; i -= scrollSlides){\n                dotIndexes.push(i);\n            }\n            dotIndexes.push(dotIndexes[dotIndexes.length - 1] - scrollSlides);\n            dotIndexes.reverse();\n        }\n        return dotIndexes;\n    }\n    return dotIndexes;\n};\nvar PagingDots = ({ pagingDotsIndices, defaultControlsConfig: { pagingDotsContainerClassName, pagingDotsClassName, pagingDotsStyle = {}, pagingDotsOnClick }, carouselId, currentSlide, onUserNavigation, slideCount, goToSlide, tabbed })=>{\n    const listStyles = {\n        position: \"relative\",\n        top: -10,\n        display: \"flex\",\n        margin: 0,\n        padding: 0,\n        listStyleType: \"none\"\n    };\n    const getButtonStyles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((active)=>({\n            cursor: \"pointer\",\n            opacity: active ? 1 : 0.5,\n            background: \"transparent\",\n            border: \"none\",\n            fill: \"black\"\n        }), []);\n    const currentSlideBounded = getBoundedIndex(currentSlide, slideCount);\n    if (!tabbed) return null;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        className: pagingDotsContainerClassName,\n        style: listStyles,\n        role: \"tablist\",\n        \"aria-label\": \"Choose slide to display.\",\n        children: pagingDotsIndices.map((slideIndex, i)=>{\n            const isActive = currentSlideBounded === slideIndex || // sets navigation dots active if the current slide falls in the current index range\n            currentSlideBounded < slideIndex && (i === 0 || currentSlideBounded > pagingDotsIndices[i - 1]);\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n                className: [\n                    \"paging-item\",\n                    pagingDotsClassName,\n                    isActive ? \"active\" : null\n                ].join(\" \"),\n                type: \"button\",\n                style: __spreadValues(__spreadValues({}, getButtonStyles(isActive)), pagingDotsStyle),\n                onClick: (event)=>{\n                    pagingDotsOnClick == null ? void 0 : pagingDotsOnClick(event);\n                    if (event.defaultPrevented) return;\n                    onUserNavigation(event);\n                    goToSlide(slideIndex);\n                },\n                \"aria-label\": `slide ${slideIndex + 1}`,\n                \"aria-selected\": isActive,\n                \"aria-controls\": `${carouselId}-slide-${slideIndex + 1}`,\n                role: \"tab\",\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"svg\", {\n                    className: \"paging-dot\",\n                    width: \"6\",\n                    height: \"6\",\n                    \"aria-hidden\": \"true\",\n                    focusable: \"false\",\n                    viewBox: \"0 0 6 6\",\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"circle\", {\n                        cx: \"3\",\n                        cy: \"3\",\n                        r: \"3\"\n                    })\n                })\n            }, slideIndex);\n        })\n    });\n};\n// src/hooks/use-tween.ts\n\nvar useTween = (durationMs, easingFunction, navigationNum, shouldInterrupt)=>{\n    const [normalizedTimeRaw, setNormalizedTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const startTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Date.now());\n    const rAF = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const isFirstRender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const lastNavigationNum = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const normalizedTime = lastNavigationNum.current === null || lastNavigationNum.current === navigationNum || shouldInterrupt ? normalizedTimeRaw : 0;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        lastNavigationNum.current = navigationNum;\n        if (isFirstRender.current) {\n            isFirstRender.current = false;\n            return;\n        }\n        if (shouldInterrupt) {\n            return;\n        }\n        startTime.current = Date.now();\n        setNormalizedTime(0);\n        const tick = ()=>{\n            rAF.current = requestAnimationFrame(()=>{\n                const currentTime = Date.now();\n                const normalizedTime2 = Math.min(1, (currentTime - startTime.current) / durationMs);\n                setNormalizedTime(normalizedTime2);\n                if (normalizedTime2 < 1) {\n                    tick();\n                } else {\n                    rAF.current = void 0;\n                }\n            });\n        };\n        tick();\n        return ()=>{\n            if (rAF.current !== void 0) {\n                cancelAnimationFrame(rAF.current);\n                setNormalizedTime(1);\n            }\n        };\n    }, [\n        navigationNum,\n        durationMs,\n        shouldInterrupt\n    ]);\n    return {\n        isAnimating: normalizedTime !== 1,\n        value: easingFunction(normalizedTime)\n    };\n};\n// src/slider-list.tsx\n\nvar getPercentOffsetForSlide = (currentSlide, slideCount, slidesToShow, cellAlign, wrapAround)=>{\n    const renderedSlideCount = wrapAround ? 3 * slideCount : slideCount;\n    const singleSlidePercentOfWhole = 100 / renderedSlideCount;\n    let slide0Offset = wrapAround ? -100 / 3 : 0;\n    if (cellAlign === \"right\" && slidesToShow > 1) {\n        const excessSlides = slidesToShow - 1;\n        slide0Offset += singleSlidePercentOfWhole * excessSlides;\n    }\n    if (cellAlign === \"center\" && slidesToShow > 1) {\n        const excessSlides = slidesToShow - 1;\n        const excessLeftSlides = excessSlides / 2;\n        slide0Offset += singleSlidePercentOfWhole * excessLeftSlides;\n    }\n    const currentSlideOffsetFrom0 = 100 / renderedSlideCount * currentSlide;\n    return slide0Offset - currentSlideOffsetFrom0;\n};\nvar SliderList = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ animation, animationDistance, cellAlign, children, currentSlide, disableAnimation, disableEdgeSwiping, draggedOffset, easing, edgeEasing, isDragging, scrollMode, slideCount, slidesToScroll, slidesToShow, speed, wrapAround, slideWidth, setIsAnimating }, forwardedRef)=>{\n    const renderedSlideCount = wrapAround ? 3 * slideCount : slideCount;\n    const listVisibleWidth = slideWidth ? `calc(${slideWidth} * ${renderedSlideCount})` : `${renderedSlideCount * 100 / slidesToShow}%`;\n    const percentOffsetForSlideProps = [\n        slideCount,\n        slidesToShow,\n        cellAlign,\n        wrapAround\n    ];\n    const dotIndexes = getDotIndexes(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);\n    let clampedDraggedOffset = `${draggedOffset}px`;\n    if (isDragging && disableEdgeSwiping && !wrapAround) {\n        const clampOffsets = [\n            dotIndexes[0],\n            dotIndexes[dotIndexes.length - 1]\n        ].map((index)=>getPercentOffsetForSlide(index, ...percentOffsetForSlideProps));\n        clampedDraggedOffset = `clamp(${clampOffsets[1]}%, ${draggedOffset}px, ${clampOffsets[0]}%)`;\n    }\n    const slideBasedOffset = getPercentOffsetForSlide(currentSlide, ...percentOffsetForSlideProps);\n    const isEdgeEasing = !disableEdgeSwiping && !wrapAround && (currentSlide === dotIndexes[0] && animationDistance < 0 || currentSlide === dotIndexes[dotIndexes.length - 1] && animationDistance > 0);\n    const { value: transition, isAnimating } = useTween(speed, !isEdgeEasing ? easing : edgeEasing, // animationDistance is assumed to be unique enough that it can be used to\n    // detect when a new animation should start. This is used in addition to\n    // currentSlide because some animations, such as those with edgeEasing, do\n    // not occur due to a change in value of currentSlide\n    currentSlide + animationDistance, isDragging || disableAnimation || animation === \"fade\");\n    let positioning;\n    if (isDragging || slideBasedOffset !== 0 || isAnimating) {\n        if (isDragging) {\n            positioning = `translateX(${clampedDraggedOffset})`;\n        } else {\n            const transitionOffset = isAnimating ? (1 - transition) * animationDistance : 0;\n            positioning = `translateX(calc(${slideBasedOffset}% - ${transitionOffset}px))`;\n        }\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setIsAnimating(isAnimating);\n    }, [\n        isAnimating,\n        setIsAnimating\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref: forwardedRef,\n        className: \"slider-list\",\n        style: {\n            width: listVisibleWidth,\n            textAlign: \"left\",\n            userSelect: \"auto\",\n            transform: positioning,\n            display: \"flex\"\n        },\n        children\n    });\n});\nSliderList.displayName = \"SliderList\";\n// src/controls.tsx\n\n// src/control-styles.ts\nvar commonStyles = {\n    position: \"absolute\",\n    display: \"flex\",\n    zIndex: 1,\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0\n};\nvar getControlContainerFlexStyles = (pos)=>{\n    let alignItems;\n    switch(pos){\n        case \"TopLeft\" /* TopLeft */ :\n        case \"TopCenter\" /* TopCenter */ :\n        case \"TopRight\" /* TopRight */ :\n            alignItems = \"flex-start\";\n            break;\n        case \"CenterLeft\" /* CenterLeft */ :\n        case \"CenterCenter\" /* CenterCenter */ :\n        case \"CenterRight\" /* CenterRight */ :\n            alignItems = \"center\";\n            break;\n        case \"BottomLeft\" /* BottomLeft */ :\n        case \"BottomCenter\" /* BottomCenter */ :\n        case \"BottomRight\" /* BottomRight */ :\n            alignItems = \"flex-end\";\n            break;\n    }\n    let justifyContent;\n    switch(pos){\n        case \"TopLeft\" /* TopLeft */ :\n        case \"CenterLeft\" /* CenterLeft */ :\n        case \"BottomLeft\" /* BottomLeft */ :\n            justifyContent = \"flex-start\";\n            break;\n        case \"TopCenter\" /* TopCenter */ :\n        case \"CenterCenter\" /* CenterCenter */ :\n        case \"BottomCenter\" /* BottomCenter */ :\n            justifyContent = \"center\";\n            break;\n        case \"TopRight\" /* TopRight */ :\n        case \"CenterRight\" /* CenterRight */ :\n        case \"BottomRight\" /* BottomRight */ :\n            justifyContent = \"flex-end\";\n            break;\n    }\n    return {\n        alignItems,\n        justifyContent\n    };\n};\nvar getControlContainerStyles = (pos)=>{\n    return __spreadValues(__spreadValues({}, getControlContainerFlexStyles(pos)), commonStyles);\n};\n// src/controls.tsx\n\nvar controlsMap = [\n    {\n        funcName: \"renderTopLeftControls\",\n        key: \"TopLeft\" /* TopLeft */ \n    },\n    {\n        funcName: \"renderTopCenterControls\",\n        key: \"TopCenter\" /* TopCenter */ \n    },\n    {\n        funcName: \"renderTopRightControls\",\n        key: \"TopRight\" /* TopRight */ \n    },\n    {\n        funcName: \"renderCenterLeftControls\",\n        key: \"CenterLeft\" /* CenterLeft */ \n    },\n    {\n        funcName: \"renderCenterCenterControls\",\n        key: \"CenterCenter\" /* CenterCenter */ \n    },\n    {\n        funcName: \"renderCenterRightControls\",\n        key: \"CenterRight\" /* CenterRight */ \n    },\n    {\n        funcName: \"renderBottomLeftControls\",\n        key: \"BottomLeft\" /* BottomLeft */ \n    },\n    {\n        funcName: \"renderBottomCenterControls\",\n        key: \"BottomCenter\" /* BottomCenter */ \n    },\n    {\n        funcName: \"renderBottomRightControls\",\n        key: \"BottomRight\" /* BottomRight */ \n    }\n];\nvar renderControls = (props, slideCount, currentSlide, goToSlide, nextSlide, prevSlide, slidesToScroll)=>{\n    if (props.withoutControls) {\n        return null;\n    }\n    const disableCheckProps = __spreadProps(__spreadValues({}, props), {\n        currentSlide,\n        slideCount\n    });\n    const nextDisabled = nextButtonDisabled(disableCheckProps);\n    const previousDisabled = prevButtonDisabled(disableCheckProps);\n    const pagingDotsIndices = getDotIndexes(slideCount, slidesToScroll, props.scrollMode, props.slidesToShow, props.wrapAround, props.cellAlign);\n    return controlsMap.map((control)=>{\n        var _a;\n        if (!props[control.funcName] || typeof props[control.funcName] !== \"function\") {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, control.funcName);\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n            style: __spreadProps(__spreadValues({}, getControlContainerStyles(control.key)), {\n                pointerEvents: \"none\"\n            }),\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n                className: [\n                    `slider-control-${control.key.toLowerCase()}`,\n                    props.defaultControlsConfig.containerClassName || \"\"\n                ].join(\" \").trim(),\n                style: {\n                    pointerEvents: \"auto\"\n                },\n                children: (_a = props[control.funcName]) == null ? void 0 : _a.call(props, {\n                    cellAlign: props.cellAlign,\n                    cellSpacing: props.cellSpacing,\n                    currentSlide,\n                    defaultControlsConfig: props.defaultControlsConfig || {},\n                    carouselId: props.carouselId,\n                    pagingDotsIndices,\n                    goToSlide,\n                    nextDisabled,\n                    nextSlide,\n                    onUserNavigation: props.onUserNavigation,\n                    previousDisabled,\n                    previousSlide: prevSlide,\n                    scrollMode: props.scrollMode,\n                    slideCount,\n                    slidesToScroll,\n                    slidesToShow: props.slidesToShow || 1,\n                    tabbed: props.tabbed,\n                    vertical: props.vertical,\n                    wrapAround: props.wrapAround\n                })\n            })\n        }, control.funcName);\n    });\n};\nvar controls_default = renderControls;\n// src/default-carousel-props.tsx\n\nvar easeOut = (t)=>__pow(t - 1, 3) + 1;\nvar defaultProps = {\n    adaptiveHeight: false,\n    adaptiveHeightAnimation: true,\n    afterSlide: ()=>{},\n    autoplay: false,\n    autoplayInterval: 3e3,\n    autoplayReverse: false,\n    beforeSlide: ()=>{},\n    cellAlign: \"left\",\n    cellSpacing: 0,\n    defaultControlsConfig: {},\n    disableAnimation: false,\n    disableEdgeSwiping: false,\n    dragging: true,\n    dragThreshold: 0.5,\n    easing: easeOut,\n    edgeEasing: easeOut,\n    enableKeyboardControls: false,\n    frameAriaLabel: \"Slider\",\n    keyCodeConfig: {\n        nextSlide: [\n            39,\n            68,\n            38,\n            87\n        ],\n        previousSlide: [\n            37,\n            65,\n            40,\n            83\n        ],\n        firstSlide: [\n            81\n        ],\n        lastSlide: [\n            69\n        ],\n        pause: [\n            32\n        ]\n    },\n    landmark: false,\n    onDragStart: ()=>{},\n    onDrag: ()=>{},\n    onDragEnd: ()=>{},\n    onUserNavigation: ()=>{},\n    pauseOnHover: true,\n    renderAnnounceSlideMessage: defaultRenderAnnounceSlideMessage,\n    renderBottomCenterControls: (props)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PagingDots, __spreadValues({}, props)),\n    renderCenterLeftControls: (props)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreviousButton, __spreadValues({}, props)),\n    renderCenterRightControls: (props)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NextButton, __spreadValues({}, props)),\n    scrollMode: \"page\" /* page */ ,\n    slidesToScroll: 1,\n    slidesToShow: 1,\n    speed: 500,\n    style: {},\n    swiping: true,\n    tabbed: true,\n    vertical: false,\n    withoutControls: false,\n    wrapAround: false,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {})\n};\nvar default_carousel_props_default = defaultProps;\n// src/hooks/use-frame-height.ts\n\n// src/hooks/use-state-with-ref.ts\n\nvar useStateWithRef = (initialState)=>{\n    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialState);\n    const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialState);\n    const setValueAndRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newValue)=>{\n        valueRef.current = newValue;\n        setValue(newValue);\n    }, []);\n    return [\n        value,\n        setValueAndRef,\n        valueRef\n    ];\n};\n// src/hooks/use-frame-height.ts\nvar useFrameHeight = (adaptiveHeight, slidesToShow, slideCount)=>{\n    const [visibleHeights, setVisibleHeights, visibleHeightsRef] = useStateWithRef([]);\n    const [initializedAdaptiveHeight, setInitializedAdaptiveHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const handleVisibleSlideHeightChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((slideIndex, height)=>{\n        const latestVisibleHeights = visibleHeightsRef.current;\n        let newVisibleHeights;\n        if (height === null) {\n            newVisibleHeights = latestVisibleHeights.filter((slideHeight)=>slideHeight.slideIndex !== slideIndex);\n        } else {\n            newVisibleHeights = [\n                ...latestVisibleHeights,\n                {\n                    slideIndex,\n                    height\n                }\n            ];\n        }\n        setVisibleHeights(newVisibleHeights);\n        if (newVisibleHeights.length >= Math.min(slideCount, Math.ceil(slidesToShow))) {\n            setInitializedAdaptiveHeight(true);\n        }\n    }, [\n        slideCount,\n        setVisibleHeights,\n        slidesToShow,\n        visibleHeightsRef\n    ]);\n    const frameHeight = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (adaptiveHeight) {\n            if (!initializedAdaptiveHeight) {\n                return \"auto\";\n            }\n            const maxHeight = Math.max(0, ...visibleHeights.map((height)=>height.height));\n            return `${maxHeight}px`;\n        } else {\n            return \"auto\";\n        }\n    }, [\n        adaptiveHeight,\n        initializedAdaptiveHeight,\n        visibleHeights\n    ]);\n    return {\n        handleVisibleSlideHeightChange,\n        frameHeight,\n        initializedAdaptiveHeight\n    };\n};\n// src/hooks/use-forward-ref.ts\n\nvar useForwardRef = (ref)=>{\n    const targetRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!ref) return;\n        if (typeof ref === \"function\") {\n            ref(targetRef.current);\n        } else {\n            ref.current = targetRef.current;\n        }\n    }, [\n        ref\n    ]);\n    return targetRef;\n};\n// src/carousel.tsx\n\nvar Carousel = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((rawProps, ref)=>{\n    const props = rawProps;\n    const internalCarouselId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const { adaptiveHeight, adaptiveHeightAnimation, afterSlide, animation, autoplay, autoplayInterval, autoplayReverse, beforeSlide, carouselId = internalCarouselId, cellAlign: propsCellAlign, cellSpacing, children, className, disableAnimation, dragging: desktopDraggingEnabled, dragThreshold: propsDragThreshold, enableKeyboardControls, frameAriaLabel, keyCodeConfig, landmark, onDrag, onDragEnd, onDragStart, onUserNavigation, pauseOnHover, renderAnnounceSlideMessage, scrollMode: propsScrollMode, slideIndex, slidesToScroll: propsSlidesToScroll, slidesToShow: propsSlidesToShow, slideWidth, speed, style, swiping: mobileDraggingEnabled, tabbed, wrapAround, zoomScale } = props;\n    const filteredSlides = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children).filter(Boolean);\n    const slideCount = filteredSlides.length;\n    const cellAlign = slideWidth || propsSlidesToScroll === \"auto\" ? \"left\" : propsCellAlign;\n    const scrollMode = propsSlidesToScroll === \"auto\" ? \"remainder\" /* remainder */  : propsScrollMode;\n    const [slideIOEntries, setSlideIOEntries] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(/* @__PURE__ */ new Map());\n    const visibleCount = Array.from(slideIOEntries).filter(([, visible])=>visible).length;\n    const [constantVisibleCount, setConstantVisibleCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(visibleCount);\n    const slidesToShow = slideWidth ? constantVisibleCount : propsSlidesToShow;\n    const slidesToScroll = animation === \"fade\" ? slidesToShow : propsSlidesToScroll === \"auto\" ? Math.max(constantVisibleCount, 1) : propsSlidesToScroll;\n    const [currentSlide, setCurrentSlide] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>getDefaultSlideIndex(slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode));\n    const [pause, setPause] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isDragging, setIsDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [dragDistance, setDragDistance] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [animationDistance, setAnimationDistance] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isAnimating, setIsAnimating] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const updateSlideIOEntry = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id, isFullyVisible)=>{\n        if (!!slideIOEntries.get(id) === isFullyVisible) return;\n        setSlideIOEntries((prev)=>{\n            const newMap = new Map(prev);\n            newMap.set(id, isFullyVisible);\n            return newMap;\n        });\n    }, [\n        slideIOEntries\n    ]);\n    const prevDragged = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isDragging) prevDragged.current = true;\n        if (!(isDragging || isAnimating)) {\n            if (!prevDragged.current) setConstantVisibleCount(visibleCount);\n            prevDragged.current = false;\n        }\n    }, [\n        isAnimating,\n        isDragging,\n        visibleCount\n    ]);\n    const prevXPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const preDragOffset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const sliderListRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const defaultCarouselRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const autoplayTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const autoplayLastTriggeredRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isMounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const setSliderListRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((node)=>{\n        if (node) {\n            node.querySelectorAll(\".slider-list img\").forEach((el)=>el.setAttribute(\"draggable\", \"false\"));\n        }\n        sliderListRef.current = node;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        isMounted.current = true;\n        return ()=>{\n            isMounted.current = false;\n        };\n    }, []);\n    const forwardedRef = useForwardRef(ref);\n    const carouselRef = forwardedRef || defaultCarouselRef;\n    const goToSlide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((targetSlideUnbounded)=>{\n        if (!sliderListRef.current || !carouselRef.current) return;\n        const targetSlideBounded = getBoundedIndex(targetSlideUnbounded, slideCount);\n        const slideChanged = targetSlideUnbounded !== currentSlide;\n        slideChanged && beforeSlide(currentSlide, targetSlideBounded);\n        const currentOffset = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;\n        const sliderWidth = sliderListRef.current.offsetWidth;\n        let targetOffset = getPercentOffsetForSlide(targetSlideBounded, slideCount, slidesToShow, cellAlign, wrapAround) / 100 * sliderWidth;\n        if (wrapAround) {\n            const slideSetWidth = sliderWidth / 3;\n            if (targetSlideUnbounded < 0) {\n                targetOffset += slideSetWidth;\n            }\n            if (targetSlideUnbounded >= slideCount) {\n                targetOffset -= slideSetWidth;\n            }\n        }\n        setAnimationDistance(targetOffset - currentOffset);\n        if (slideChanged) {\n            setCurrentSlide(targetSlideBounded);\n            const msToEndOfAnimation = !disableAnimation ? speed || 500 : 40;\n            setTimeout(()=>{\n                if (!isMounted.current) return;\n                afterSlide(targetSlideBounded);\n            }, msToEndOfAnimation);\n        }\n    }, [\n        afterSlide,\n        beforeSlide,\n        carouselRef,\n        cellAlign,\n        currentSlide,\n        disableAnimation,\n        speed,\n        slideCount,\n        slidesToShow,\n        wrapAround\n    ]);\n    const nextSlide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const nextSlideIndex = getNextMoveIndex(scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign);\n        if (currentSlide !== nextSlideIndex) {\n            goToSlide(nextSlideIndex);\n        }\n    }, [\n        cellAlign,\n        currentSlide,\n        goToSlide,\n        slidesToScroll,\n        scrollMode,\n        slideCount,\n        slidesToShow,\n        wrapAround\n    ]);\n    const prevSlide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const prevSlideIndex = getPrevMoveIndex(scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign);\n        if (currentSlide !== prevSlideIndex) {\n            goToSlide(prevSlideIndex);\n        }\n    }, [\n        cellAlign,\n        currentSlide,\n        goToSlide,\n        slidesToScroll,\n        scrollMode,\n        slidesToShow,\n        wrapAround\n    ]);\n    const prevMovedToSlideIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(slideIndex);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (slideIndex !== void 0 && slideIndex !== prevMovedToSlideIndex.current && !autoplayReverse) {\n            goToSlide(slideIndex);\n            prevMovedToSlideIndex.current = slideIndex;\n        }\n    }, [\n        slideIndex,\n        autoplayReverse,\n        goToSlide\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let pauseStarted = null;\n        if (pause) {\n            pauseStarted = Date.now();\n        }\n        return ()=>{\n            if (pauseStarted !== null && autoplayLastTriggeredRef.current !== null) {\n                autoplayLastTriggeredRef.current += Date.now() - pauseStarted;\n            }\n        };\n    }, [\n        pause\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (autoplay && !pause) {\n            const adjustedTimeoutMs = autoplayLastTriggeredRef.current !== null ? autoplayInterval - (Date.now() - autoplayLastTriggeredRef.current) : autoplayInterval;\n            autoplayTimeout.current = setTimeout(()=>{\n                autoplayLastTriggeredRef.current = Date.now();\n                if (autoplayReverse) {\n                    prevSlide();\n                } else {\n                    nextSlide();\n                }\n            }, adjustedTimeoutMs);\n        }\n        if (autoplay && pause) {\n            clearTimeout(autoplayTimeout.current);\n        }\n        return ()=>{\n            clearTimeout(autoplayTimeout.current);\n        };\n    }, [\n        pause,\n        autoplay,\n        autoplayInterval,\n        autoplayReverse,\n        prevSlide,\n        nextSlide\n    ]);\n    const onKeyDown = (event)=>{\n        let keyCommand = null;\n        Object.keys(keyCodeConfig).forEach((command)=>{\n            var _a;\n            if ((_a = keyCodeConfig[command]) == null ? void 0 : _a.includes(event.keyCode)) {\n                keyCommand = command;\n            }\n        });\n        if (keyCommand === null) return;\n        event.preventDefault();\n        event.stopPropagation();\n        switch(keyCommand){\n            case \"nextSlide\":\n                onUserNavigation(event);\n                nextSlide();\n                break;\n            case \"previousSlide\":\n                onUserNavigation(event);\n                prevSlide();\n                break;\n            case \"firstSlide\":\n            case \"lastSlide\":\n                {\n                    onUserNavigation(event);\n                    const dotIndices = getDotIndexes(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);\n                    if (keyCommand === \"firstSlide\") {\n                        goToSlide(dotIndices[0]);\n                    } else {\n                        goToSlide(dotIndices[dotIndices.length - 1]);\n                    }\n                    break;\n                }\n            case \"pause\":\n                setPause((p)=>!p);\n                break;\n        }\n    };\n    const dragPositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const handleDragEnd = (e)=>{\n        if (!isDragging || !carouselRef.current) return;\n        setIsDragging(false);\n        let distanceFromInertia = 0;\n        if (dragPositions.current.length > 1) {\n            const startMove = dragPositions.current[0];\n            const endMove = dragPositions.current[dragPositions.current.length - 1];\n            const timeOffset = endMove.time - startMove.time;\n            const goodInertiaFeelConstant = 9;\n            const goodFrictionFeelConstant = 0.92;\n            const initialVelocity = goodInertiaFeelConstant * Math.abs((endMove.pos - startMove.pos) / timeOffset);\n            let velocity = initialVelocity;\n            while(Math.abs(velocity) > 1){\n                distanceFromInertia += velocity;\n                velocity *= goodFrictionFeelConstant;\n            }\n        }\n        dragPositions.current = [];\n        const adjustedDragDistance = Math.abs(dragDistance) + Math.abs(distanceFromInertia);\n        onDragEnd(e);\n        prevXPosition.current = null;\n        setDragDistance(0);\n        const oneScrollWidth = carouselRef.current.offsetWidth * Math.min(1, slidesToScroll / slidesToShow);\n        const dragThreshold = oneScrollWidth * propsDragThreshold;\n        if (adjustedDragDistance < dragThreshold) {\n            goToSlide(currentSlide);\n            return;\n        }\n        const canMaintainVisualContinuity = slidesToShow >= 2 * slidesToScroll;\n        const timesToMove = canMaintainVisualContinuity ? 1 + Math.floor((adjustedDragDistance - dragThreshold) / oneScrollWidth) : 1;\n        let nextSlideIndex = currentSlide;\n        for(let index = 0; index < timesToMove; index += 1){\n            if (dragDistance > 0) {\n                nextSlideIndex = getNextMoveIndex(scrollMode, wrapAround, nextSlideIndex, slideCount, slidesToScroll, slidesToShow, cellAlign);\n            } else {\n                nextSlideIndex = getPrevMoveIndex(scrollMode, wrapAround, nextSlideIndex, slidesToScroll, slidesToShow, cellAlign);\n            }\n        }\n        if (nextSlideIndex !== currentSlide) {\n            onUserNavigation(e);\n        }\n        goToSlide(nextSlideIndex);\n    };\n    const onTouchStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (!mobileDraggingEnabled || !sliderListRef.current || !carouselRef.current) {\n            return;\n        }\n        setIsDragging(true);\n        preDragOffset.current = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;\n        onDragStart(e);\n    }, [\n        carouselRef,\n        onDragStart,\n        mobileDraggingEnabled\n    ]);\n    const handlePointerMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((xPosition)=>{\n        if (!isDragging) return;\n        const isFirstMove = prevXPosition.current === null;\n        const delta = prevXPosition.current !== null ? xPosition - prevXPosition.current : 0;\n        const nextDragDistance = dragDistance + delta;\n        const now = Date.now();\n        while(dragPositions.current.length > 0){\n            if (now - dragPositions.current[0].time <= 100) {\n                break;\n            }\n            dragPositions.current.shift();\n        }\n        dragPositions.current.push({\n            pos: nextDragDistance,\n            time: now\n        });\n        if (!isFirstMove) {\n            setDragDistance(nextDragDistance);\n        }\n        prevXPosition.current = xPosition;\n    }, [\n        isDragging,\n        dragDistance\n    ]);\n    const onTouchMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (!isDragging || !carouselRef.current) return;\n        onDragStart(e);\n        const moveValue = carouselRef.current.offsetWidth - e.touches[0].pageX;\n        handlePointerMove(moveValue);\n    }, [\n        isDragging,\n        carouselRef,\n        handlePointerMove,\n        onDragStart\n    ]);\n    const onMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (!desktopDraggingEnabled || !sliderListRef.current || !carouselRef.current) return;\n        setIsDragging(true);\n        preDragOffset.current = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;\n        onDragStart(e);\n    }, [\n        carouselRef,\n        desktopDraggingEnabled,\n        onDragStart\n    ]);\n    const onMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (!isDragging || !carouselRef.current) return;\n        onDrag(e);\n        const offsetX = e.clientX - carouselRef.current.getBoundingClientRect().left;\n        const moveValue = carouselRef.current.offsetWidth - offsetX;\n        handlePointerMove(moveValue);\n    }, [\n        carouselRef,\n        isDragging,\n        handlePointerMove,\n        onDrag\n    ]);\n    const onMouseUp = (e)=>{\n        e.preventDefault();\n        handleDragEnd(e);\n    };\n    const onMouseEnter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (pauseOnHover) {\n            setPause(true);\n        }\n    }, [\n        pauseOnHover\n    ]);\n    const onMouseLeave = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (pauseOnHover) {\n            setPause(false);\n        }\n    }, [\n        pauseOnHover\n    ]);\n    const { frameHeight, handleVisibleSlideHeightChange, initializedAdaptiveHeight } = useFrameHeight(adaptiveHeight, slidesToShow, slideCount);\n    const renderSlides = (typeOfSlide)=>{\n        const slides = filteredSlides.map((child, index)=>{\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(slide_default, {\n                id: `${typeOfSlide}-${index}`,\n                carouselId,\n                count: slideCount,\n                index,\n                isCurrentSlide: currentSlide === index,\n                typeOfSlide,\n                wrapAround,\n                cellSpacing,\n                animation,\n                speed,\n                zoomScale,\n                onVisibleSlideHeightChange: handleVisibleSlideHeightChange,\n                slideWidth,\n                updateIOEntry: updateSlideIOEntry,\n                adaptiveHeight,\n                initializedAdaptiveHeight,\n                carouselRef,\n                tabbed,\n                children: child\n            }, `${typeOfSlide}-${index}`);\n        });\n        return slides;\n    };\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", {\n        className: \"slider-container\",\n        style: {\n            position: \"relative\"\n        },\n        onMouseEnter,\n        onMouseLeave,\n        \"aria-label\": frameAriaLabel,\n        role: landmark ? \"region\" : \"group\",\n        \"aria-roledescription\": \"carousel\",\n        id: carouselId,\n        \"data-testid\": carouselId,\n        children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(announce_slide_default, {\n                ariaLive: autoplay && !pause ? \"off\" : \"polite\",\n                message: renderAnnounceSlideMessage({\n                    currentSlide,\n                    count: slideCount\n                })\n            }),\n            controls_default(__spreadProps(__spreadValues({}, props), {\n                carouselId\n            }), slideCount, currentSlide, goToSlide, nextSlide, prevSlide, slidesToScroll),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n                className: [\n                    \"slider-frame\",\n                    className || \"\"\n                ].join(\" \").trim(),\n                style: __spreadValues({\n                    overflow: \"hidden\",\n                    width: \"100%\",\n                    position: \"relative\",\n                    outline: \"none\",\n                    touchAction: \"pan-y\",\n                    height: frameHeight,\n                    transition: adaptiveHeightAnimation ? \"height 300ms ease-in-out\" : void 0,\n                    willChange: \"height\",\n                    userSelect: \"none\"\n                }, style),\n                tabIndex: enableKeyboardControls ? 0 : -1,\n                onKeyDown: enableKeyboardControls ? onKeyDown : void 0,\n                ref: carouselRef,\n                onMouseUp,\n                onMouseDown,\n                onMouseMove,\n                onMouseLeave: onMouseUp,\n                onTouchStart,\n                onTouchEnd: handleDragEnd,\n                onTouchMove,\n                id: `${carouselId}-slider-frame`,\n                \"data-testid\": `${carouselId}-slider-frame`,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(SliderList, {\n                    animationDistance,\n                    cellAlign,\n                    currentSlide,\n                    disableEdgeSwiping: props.disableEdgeSwiping,\n                    draggedOffset: preDragOffset.current - dragDistance,\n                    disableAnimation,\n                    easing: props.easing,\n                    edgeEasing: props.edgeEasing,\n                    isDragging,\n                    ref: setSliderListRef,\n                    scrollMode,\n                    animation,\n                    slideCount,\n                    slidesToScroll,\n                    slidesToShow,\n                    speed,\n                    slideWidth,\n                    wrapAround,\n                    setIsAnimating,\n                    children: [\n                        wrapAround ? renderSlides(\"prev-cloned\") : null,\n                        renderSlides(),\n                        wrapAround ? renderSlides(\"next-cloned\") : null\n                    ]\n                })\n            })\n        ]\n    });\n});\nCarousel.defaultProps = default_carousel_props_default;\nCarousel.displayName = \"Carousel\";\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbnVrYS1jYXJvdXNlbC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxhQUFhRixPQUFPRyxnQkFBZ0I7QUFDeEMsSUFBSUMsb0JBQW9CSixPQUFPSyx5QkFBeUI7QUFDeEQsSUFBSUMsc0JBQXNCTixPQUFPTyxxQkFBcUI7QUFDdEQsSUFBSUMsZUFBZVIsT0FBT1MsU0FBUyxDQUFDQyxjQUFjO0FBQ2xELElBQUlDLGVBQWVYLE9BQU9TLFNBQVMsQ0FBQ0csb0JBQW9CO0FBQ3hELElBQUlDLFFBQVFDLEtBQUtDLEdBQUc7QUFDcEIsSUFBSUMsa0JBQWtCLENBQUNDLEtBQUtDLEtBQUtDLFFBQVVELE9BQU9ELE1BQU1sQixVQUFVa0IsS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxpQkFBaUIsQ0FBQ0MsR0FBR0M7SUFDdkIsSUFBSyxJQUFJQyxRQUFRRCxLQUFNQSxDQUFBQSxJQUFJLENBQUMsR0FDMUIsSUFBSWpCLGFBQWFtQixJQUFJLENBQUNGLEdBQUdDLE9BQ3ZCVixnQkFBZ0JRLEdBQUdFLE1BQU1ELENBQUMsQ0FBQ0MsS0FBSztJQUNwQyxJQUFJcEIscUJBQ0YsS0FBSyxJQUFJb0IsUUFBUXBCLG9CQUFvQm1CLEdBQUk7UUFDdkMsSUFBSWQsYUFBYWdCLElBQUksQ0FBQ0YsR0FBR0MsT0FDdkJWLGdCQUFnQlEsR0FBR0UsTUFBTUQsQ0FBQyxDQUFDQyxLQUFLO0lBQ3BDO0lBQ0YsT0FBT0Y7QUFDVDtBQUNBLElBQUlJLGdCQUFnQixDQUFDSixHQUFHQyxJQUFNdkIsV0FBV3NCLEdBQUdwQixrQkFBa0JxQjtBQUU5RCxtQkFBbUI7QUFDbUg7QUFFdEksZ0JBQWdCO0FBSUQ7QUFFZiwrQ0FBK0M7QUFD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RjtnQkFDZGY7Z0JBQ0F3QixZQUFZekM7Z0JBQ1p3QjtnQkFDQXZXLElBQUksQ0FBQyxFQUFFRSxXQUFXLGFBQWEsQ0FBQztnQkFDaEMsZUFBZSxDQUFDLEVBQUVBLFdBQVcsYUFBYSxDQUFDO2dCQUMzQ0wsVUFBVSxhQUFhLEdBQUd5USx1REFBSUEsQ0FDNUIxRyxZQUNBO29CQUNFRTtvQkFDQXpHO29CQUNBakI7b0JBQ0E0SCxvQkFBb0JpQyxNQUFNakMsa0JBQWtCO29CQUM1Q0MsZUFBZTBJLGNBQWNwVixPQUFPLEdBQUcwVTtvQkFDdkNsSTtvQkFDQUcsUUFBUStCLE1BQU0vQixNQUFNO29CQUNwQkMsWUFBWThCLE1BQU05QixVQUFVO29CQUM1QkM7b0JBQ0FuSixLQUFLZ1M7b0JBQ0xoUTtvQkFDQXRFO29CQUNBdUU7b0JBQ0FDO29CQUNBQztvQkFDQXhFO29CQUNBSTtvQkFDQVY7b0JBQ0ErTDtvQkFDQXhLLFVBQVU7d0JBQ1J2QixhQUFhNFksYUFBYSxpQkFBaUI7d0JBQzNDQTt3QkFDQTVZLGFBQWE0WSxhQUFhLGlCQUFpQjtxQkFDNUM7Z0JBQ0g7WUFFSjtTQUVIO0lBQ0g7QUFFSjtBQUVGM0csU0FBU3ZELFlBQVksR0FBR3dCO0FBQ3hCK0IsU0FBU3RGLFdBQVcsR0FBRztBQVVyQixDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbXBsZS11aS1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL251a2EtY2Fyb3VzZWwvZGlzdC9pbmRleC5tanM/YTM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX3BvdyA9IE1hdGgucG93O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuXG4vLyBzcmMvY2Fyb3VzZWwudHN4XG5pbXBvcnQgUmVhY3Q1LCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q2LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTUsIHVzZVJlZiBhcyB1c2VSZWY2LCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazQsIHVzZUlkIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9zbGlkZS50c3hcbmltcG9ydCB7XG4gIHVzZVJlZiBhcyB1c2VSZWYyLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MlxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2hvb2tzL3VzZS1zbGlkZS1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXIudHNcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZVNsaWRlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAoZWxlbWVudFJlZiwgcm9vdFJlZiwgY2FsbGJhY2spID0+IHtcbiAgY29uc3QgW2VudHJ5LCBzZXRFbnRyeV0gPSB1c2VTdGF0ZSgpO1xuICBjb25zdCBjYWxsYmFja1JlZiA9IHVzZVJlZihjYWxsYmFjayk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tSZWYuY3VycmVudCA9IGNhbGxiYWNrO1xuICB9LCBbY2FsbGJhY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gZWxlbWVudFJlZiA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHJvb3QgPSByb290UmVmID09IG51bGwgPyB2b2lkIDAgOiByb290UmVmLmN1cnJlbnQ7XG4gICAgaWYgKCF3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgfHwgIW5vZGUgfHwgIXJvb3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAoZW50cmllcykgPT4ge1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5MikgPT4ge1xuICAgICAgICAgIHNldEVudHJ5KGVudHJ5Mik7XG4gICAgICAgICAgY2FsbGJhY2tSZWYuY3VycmVudChlbnRyeTIpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRocmVzaG9sZDogWzAuMDUsIDAuOTVdLFxuICAgICAgICByb290XG4gICAgICB9XG4gICAgKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUpO1xuICAgIHJldHVybiAoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0sIFtlbGVtZW50UmVmLCByb290UmVmXSk7XG4gIHJldHVybiBlbnRyeTtcbn07XG5cbi8vIHNyYy9zbGlkZS50c3hcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIGdldFNsaWRlV2lkdGggPSAoY291bnQsIHdyYXBBcm91bmQpID0+IGAke3dyYXBBcm91bmQgPyAxMDAgLyAoMyAqIGNvdW50KSA6IDEwMCAvIGNvdW50fSVgO1xudmFyIGdldFNsaWRlU3R5bGVzID0gKGNvdW50LCBpc0N1cnJlbnRTbGlkZSwgaXNWaXNpYmxlU2xpZGUsIHdyYXBBcm91bmQsIGNlbGxTcGFjaW5nLCBhbmltYXRpb24sIHNwZWVkLCB6b29tU2NhbGUsIGFkYXB0aXZlSGVpZ2h0LCBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0LCBzbGlkZVdpZHRoKSA9PiB7XG4gIGNvbnN0IHdpZHRoID0gc2xpZGVXaWR0aCAhPSBudWxsID8gc2xpZGVXaWR0aCA6IGdldFNsaWRlV2lkdGgoY291bnQsIHdyYXBBcm91bmQpO1xuICBjb25zdCB2aXNpYmxlU2xpZGVPcGFjaXR5ID0gaXNWaXNpYmxlU2xpZGUgPyAxIDogMDtcbiAgY29uc3QgYW5pbWF0aW9uU3BlZWQgPSBhbmltYXRpb24gPT09IFwiZmFkZVwiID8gMjAwIDogNTAwO1xuICBsZXQgaGVpZ2h0ID0gXCJhdXRvXCI7XG4gIGlmIChhZGFwdGl2ZUhlaWdodCkge1xuICAgIGlmIChpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBcIjEwMCVcIjtcbiAgICB9IGVsc2UgaWYgKGlzVmlzaWJsZVNsaWRlKSB7XG4gICAgICBoZWlnaHQgPSBcImF1dG9cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gXCIwXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHBhZGRpbmc6IGAwICR7Y2VsbFNwYWNpbmcgPyBjZWxsU3BhY2luZyAvIDIgOiAwfXB4YCxcbiAgICB0cmFuc2l0aW9uOiBhbmltYXRpb24gPyBgJHtzcGVlZCB8fCBhbmltYXRpb25TcGVlZH1tcyBlYXNlIDBzYCA6IHZvaWQgMCxcbiAgICB0cmFuc2Zvcm06IGFuaW1hdGlvbiA9PT0gXCJ6b29tXCIgPyBgc2NhbGUoJHtpc0N1cnJlbnRTbGlkZSAmJiBpc1Zpc2libGVTbGlkZSA/IDEgOiB6b29tU2NhbGUgfHwgMC44NX0pYCA6IHZvaWQgMCxcbiAgICBvcGFjaXR5OiBhbmltYXRpb24gPT09IFwiZmFkZVwiID8gdmlzaWJsZVNsaWRlT3BhY2l0eSA6IDFcbiAgfTtcbn07XG52YXIgZ2VuZXJhdGVJbmRleCA9IChpbmRleCwgY291bnQsIHR5cGVPZlNsaWRlKSA9PiB7XG4gIGlmICh0eXBlT2ZTbGlkZSA9PT0gXCJwcmV2LWNsb25lZFwiKSB7XG4gICAgcmV0dXJuIGluZGV4IC0gY291bnQ7XG4gIH1cbiAgaWYgKHR5cGVPZlNsaWRlID09PSBcIm5leHQtY2xvbmVkXCIpIHtcbiAgICByZXR1cm4gaW5kZXggKyBjb3VudDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xudmFyIFNsaWRlID0gKHtcbiAgY291bnQsXG4gIGNoaWxkcmVuLFxuICBpbmRleCxcbiAgaXNDdXJyZW50U2xpZGUsXG4gIHR5cGVPZlNsaWRlLFxuICB3cmFwQXJvdW5kLFxuICBjZWxsU3BhY2luZyxcbiAgc2xpZGVXaWR0aCxcbiAgYW5pbWF0aW9uLFxuICBzcGVlZCxcbiAgem9vbVNjYWxlLFxuICBvblZpc2libGVTbGlkZUhlaWdodENoYW5nZSxcbiAgYWRhcHRpdmVIZWlnaHQsXG4gIGluaXRpYWxpemVkQWRhcHRpdmVIZWlnaHQsXG4gIHVwZGF0ZUlPRW50cnksXG4gIGlkLFxuICBjYXJvdXNlbFJlZixcbiAgY2Fyb3VzZWxJZCxcbiAgdGFiYmVkXG59KSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgY3VzdG9tSW5kZXggPSB3cmFwQXJvdW5kID8gZ2VuZXJhdGVJbmRleChpbmRleCwgY291bnQsIHR5cGVPZlNsaWRlKSA6IGluZGV4O1xuICBjb25zdCBzbGlkZVJlZiA9IHVzZVJlZjIobnVsbCk7XG4gIGNvbnN0IGVudHJ5ID0gdXNlU2xpZGVJbnRlcnNlY3Rpb25PYnNlcnZlcihzbGlkZVJlZiwgY2Fyb3VzZWxSZWYsIChlbnRyeTIpID0+IHtcbiAgICB1cGRhdGVJT0VudHJ5KGlkLCAoZW50cnkyID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeTIuaW50ZXJzZWN0aW9uUmF0aW8pID49IDAuOTUpO1xuICB9KTtcbiAgY29uc3QgaXNWaXNpYmxlID0gISEoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IGVudHJ5LmlzSW50ZXJzZWN0aW5nKTtcbiAgY29uc3QgaXNGdWxseVZpc2libGUgPSAoKF9hID0gZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IGVudHJ5LmludGVyc2VjdGlvblJhdGlvKSAhPSBudWxsID8gX2EgOiAxKSA+PSAwLjk1O1xuICBjb25zdCBwcmV2SXNWaXNpYmxlUmVmID0gdXNlUmVmMihmYWxzZSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgY29uc3Qgbm9kZSA9IHNsaWRlUmVmLmN1cnJlbnQ7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIGNvbnN0IHNsaWRlSGVpZ2h0ID0gKF9hMiA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaGVpZ2h0O1xuICAgICAgY29uc3QgcHJldklzVmlzaWJsZSA9IHByZXZJc1Zpc2libGVSZWYuY3VycmVudDtcbiAgICAgIGlmIChpc1Zpc2libGUgJiYgIXByZXZJc1Zpc2libGUpIHtcbiAgICAgICAgb25WaXNpYmxlU2xpZGVIZWlnaHRDaGFuZ2UoY3VzdG9tSW5kZXgsIHNsaWRlSGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVmlzaWJsZSAmJiBwcmV2SXNWaXNpYmxlKSB7XG4gICAgICAgIG9uVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlKGN1c3RvbUluZGV4LCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHByZXZJc1Zpc2libGVSZWYuY3VycmVudCA9IGlzVmlzaWJsZTtcbiAgICB9XG4gIH0sIFtjdXN0b21JbmRleCwgaXNWaXNpYmxlLCBvblZpc2libGVTbGlkZUhlaWdodENoYW5nZV0pO1xuICBjb25zdCBjdXJyZW50U2xpZGVDbGFzcyA9IGlzQ3VycmVudFNsaWRlICYmIGlzRnVsbHlWaXNpYmxlID8gXCIgc2xpZGUtY3VycmVudFwiIDogXCJcIjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgXCJkaXZcIixcbiAgICBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHJlZjogc2xpZGVSZWZcbiAgICB9LCB7IGluZXJ0OiBpc0Z1bGx5VmlzaWJsZSA/IHZvaWQgMCA6IFwidHJ1ZVwiIH0pLCB7XG4gICAgICBjbGFzc05hbWU6IGBzbGlkZSR7Y3VycmVudFNsaWRlQ2xhc3N9JHt0eXBlT2ZTbGlkZSA/IGAgJHt0eXBlT2ZTbGlkZX1gIDogXCJcIn0ke2lzRnVsbHlWaXNpYmxlID8gXCIgc2xpZGUtdmlzaWJsZVwiIDogXCJcIn1gLFxuICAgICAgc3R5bGU6IGdldFNsaWRlU3R5bGVzKFxuICAgICAgICBjb3VudCxcbiAgICAgICAgaXNDdXJyZW50U2xpZGUsXG4gICAgICAgIGlzRnVsbHlWaXNpYmxlLFxuICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICBjZWxsU3BhY2luZyxcbiAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICBzcGVlZCxcbiAgICAgICAgem9vbVNjYWxlLFxuICAgICAgICBhZGFwdGl2ZUhlaWdodCxcbiAgICAgICAgaW5pdGlhbGl6ZWRBZGFwdGl2ZUhlaWdodCxcbiAgICAgICAgc2xpZGVXaWR0aFxuICAgICAgKSxcbiAgICAgIGlkOiB0eXBlT2ZTbGlkZSA/IHZvaWQgMCA6IGAke2Nhcm91c2VsSWR9LXNsaWRlLSR7aW5kZXggKyAxfWAsXG4gICAgICByb2xlOiB0YWJiZWQgPyBcInRhYnBhbmVsXCIgOiBcImdyb3VwXCIsXG4gICAgICBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IHRhYmJlZCA/IHZvaWQgMCA6IFwic2xpZGVcIixcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcbiAgKTtcbn07XG52YXIgc2xpZGVfZGVmYXVsdCA9IFNsaWRlO1xuXG4vLyBzcmMvYW5ub3VuY2Utc2xpZGUudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIHN0eWxlcyA9IHtcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgd2lkdGg6IFwiMXB4XCIsXG4gIGhlaWdodDogXCIxcHhcIixcbiAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gIHBhZGRpbmc6IDAsXG4gIG1hcmdpbjogXCItMXB4XCIsXG4gIGNsaXA6IFwicmVjdCgwLCAwLCAwLCAwKVwiLFxuICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICBib3JkZXI6IDBcbn07XG52YXIgQW5ub3VuY2VTbGlkZSA9ICh7XG4gIG1lc3NhZ2UsXG4gIGFyaWFMaXZlID0gXCJwb2xpdGVcIlxufSkgPT4gLyogQF9fUFVSRV9fICovIGpzeDIoXCJkaXZcIiwgeyBcImFyaWEtbGl2ZVwiOiBhcmlhTGl2ZSwgXCJhcmlhLWF0b21pY1wiOiBcInRydWVcIiwgc3R5bGU6IHN0eWxlcywgdGFiSW5kZXg6IC0xLCBjaGlsZHJlbjogbWVzc2FnZSB9KTtcbnZhciBkZWZhdWx0UmVuZGVyQW5ub3VuY2VTbGlkZU1lc3NhZ2UgPSAoe1xuICBjdXJyZW50U2xpZGUsXG4gIGNvdW50XG59KSA9PiBgU2xpZGUgJHtjdXJyZW50U2xpZGUgKyAxfSBvZiAke2NvdW50fWA7XG52YXIgYW5ub3VuY2Vfc2xpZGVfZGVmYXVsdCA9IEFubm91bmNlU2xpZGU7XG5cbi8vIHNyYy9zbGlkZXItbGlzdC50c3hcbmltcG9ydCBSZWFjdDMsIHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2RlZmF1bHQtY29udHJvbHMudHN4XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdHlwZXMudHNcbnZhciBBbGlnbm1lbnQgPSAvKiBAX19QVVJFX18gKi8gKChBbGlnbm1lbnQyKSA9PiB7XG4gIEFsaWdubWVudDJbXCJDZW50ZXJcIl0gPSBcImNlbnRlclwiO1xuICBBbGlnbm1lbnQyW1wiUmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gIEFsaWdubWVudDJbXCJMZWZ0XCJdID0gXCJsZWZ0XCI7XG4gIHJldHVybiBBbGlnbm1lbnQyO1xufSkoQWxpZ25tZW50IHx8IHt9KTtcbnZhciBEaXJlY3Rpb25zID0gLyogQF9fUFVSRV9fICovICgoRGlyZWN0aW9uczIpID0+IHtcbiAgRGlyZWN0aW9uczJbXCJOZXh0XCJdID0gXCJuZXh0XCI7XG4gIERpcmVjdGlvbnMyW1wiUHJldlwiXSA9IFwicHJldlwiO1xuICBEaXJlY3Rpb25zMltcIlVwXCJdID0gXCJ1cFwiO1xuICBEaXJlY3Rpb25zMltcIkRvd25cIl0gPSBcImRvd25cIjtcbiAgcmV0dXJuIERpcmVjdGlvbnMyO1xufSkoRGlyZWN0aW9ucyB8fCB7fSk7XG52YXIgUG9zaXRpb25zID0gLyogQF9fUFVSRV9fICovICgoUG9zaXRpb25zMikgPT4ge1xuICBQb3NpdGlvbnMyW1wiVG9wTGVmdFwiXSA9IFwiVG9wTGVmdFwiO1xuICBQb3NpdGlvbnMyW1wiVG9wQ2VudGVyXCJdID0gXCJUb3BDZW50ZXJcIjtcbiAgUG9zaXRpb25zMltcIlRvcFJpZ2h0XCJdID0gXCJUb3BSaWdodFwiO1xuICBQb3NpdGlvbnMyW1wiQ2VudGVyTGVmdFwiXSA9IFwiQ2VudGVyTGVmdFwiO1xuICBQb3NpdGlvbnMyW1wiQ2VudGVyQ2VudGVyXCJdID0gXCJDZW50ZXJDZW50ZXJcIjtcbiAgUG9zaXRpb25zMltcIkNlbnRlclJpZ2h0XCJdID0gXCJDZW50ZXJSaWdodFwiO1xuICBQb3NpdGlvbnMyW1wiQm90dG9tTGVmdFwiXSA9IFwiQm90dG9tTGVmdFwiO1xuICBQb3NpdGlvbnMyW1wiQm90dG9tQ2VudGVyXCJdID0gXCJCb3R0b21DZW50ZXJcIjtcbiAgUG9zaXRpb25zMltcIkJvdHRvbVJpZ2h0XCJdID0gXCJCb3R0b21SaWdodFwiO1xuICByZXR1cm4gUG9zaXRpb25zMjtcbn0pKFBvc2l0aW9ucyB8fCB7fSk7XG52YXIgU2Nyb2xsTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNjcm9sbE1vZGUyKSA9PiB7XG4gIFNjcm9sbE1vZGUyW1wicGFnZVwiXSA9IFwicGFnZVwiO1xuICBTY3JvbGxNb2RlMltcInJlbWFpbmRlclwiXSA9IFwicmVtYWluZGVyXCI7XG4gIHJldHVybiBTY3JvbGxNb2RlMjtcbn0pKFNjcm9sbE1vZGUgfHwge30pO1xuXG4vLyBzcmMvdXRpbHMudHNcbnZhciBnZXROZXh0TW92ZUluZGV4ID0gKHNjcm9sbE1vZGUsIHdyYXBBcm91bmQsIGN1cnJlbnRTbGlkZSwgc2xpZGVDb3VudCwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlc1RvU2hvdywgY2VsbEFsaWduKSA9PiB7XG4gIGlmICh3cmFwQXJvdW5kKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTbGlkZSArIHNsaWRlc1RvU2Nyb2xsO1xuICB9XG4gIGlmIChjdXJyZW50U2xpZGUgPj0gc2xpZGVDb3VudCAtIDEgfHwgY2VsbEFsaWduID09PSBcImxlZnRcIiAmJiBjdXJyZW50U2xpZGUgPj0gc2xpZGVDb3VudCAtIHNsaWRlc1RvU2hvdykge1xuICAgIHJldHVybiBjdXJyZW50U2xpZGU7XG4gIH1cbiAgaWYgKHNjcm9sbE1vZGUgPT09IFwicmVtYWluZGVyXCIgLyogcmVtYWluZGVyICovICYmIGNlbGxBbGlnbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oY3VycmVudFNsaWRlICsgc2xpZGVzVG9TY3JvbGwsIHNsaWRlQ291bnQgLSBzbGlkZXNUb1Nob3cpO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihjdXJyZW50U2xpZGUgKyBzbGlkZXNUb1Njcm9sbCwgc2xpZGVDb3VudCAtIDEpO1xufTtcbnZhciBnZXRQcmV2TW92ZUluZGV4ID0gKHNjcm9sbE1vZGUsIHdyYXBBcm91bmQsIGN1cnJlbnRTbGlkZSwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlc1RvU2hvdywgY2VsbEFsaWduKSA9PiB7XG4gIGlmICh3cmFwQXJvdW5kKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTbGlkZSAtIHNsaWRlc1RvU2Nyb2xsO1xuICB9XG4gIGlmIChjdXJyZW50U2xpZGUgPD0gMCB8fCBjZWxsQWxpZ24gPT09IFwicmlnaHRcIiAmJiBjdXJyZW50U2xpZGUgPD0gc2xpZGVzVG9TaG93IC0gMSkge1xuICAgIHJldHVybiBjdXJyZW50U2xpZGU7XG4gIH1cbiAgaWYgKHNjcm9sbE1vZGUgPT09IFwicmVtYWluZGVyXCIgLyogcmVtYWluZGVyICovICYmIGNlbGxBbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KGN1cnJlbnRTbGlkZSAtIHNsaWRlc1RvU2Nyb2xsLCBzbGlkZXNUb1Nob3cgLSAxKTtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoY3VycmVudFNsaWRlIC0gc2xpZGVzVG9TY3JvbGwsIDApO1xufTtcbnZhciBnZXREZWZhdWx0U2xpZGVJbmRleCA9IChzbGlkZUluZGV4LCBzbGlkZUNvdW50LCBzbGlkZXNUb1Nob3csIHNsaWRlc1RvU2Nyb2xsLCBjZWxsQWxpZ24sIGF1dG9wbGF5UmV2ZXJzZSwgc2Nyb2xsTW9kZSkgPT4ge1xuICBpZiAoc2xpZGVJbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHNsaWRlSW5kZXg7XG4gIH1cbiAgY29uc3QgZG90SW5kZXhlcyA9IGdldERvdEluZGV4ZXMoXG4gICAgc2xpZGVDb3VudCxcbiAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICBzY3JvbGxNb2RlLFxuICAgIHNsaWRlc1RvU2hvdyxcbiAgICBmYWxzZSxcbiAgICBjZWxsQWxpZ25cbiAgKTtcbiAgcmV0dXJuIGF1dG9wbGF5UmV2ZXJzZSA/IGRvdEluZGV4ZXNbZG90SW5kZXhlcy5sZW5ndGggLSAxXSA6IGRvdEluZGV4ZXNbMF07XG59O1xudmFyIGdldEJvdW5kZWRJbmRleCA9IChyYXdJbmRleCwgc2xpZGVDb3VudCkgPT4ge1xuICByZXR1cm4gKHJhd0luZGV4ICUgc2xpZGVDb3VudCArIHNsaWRlQ291bnQpICUgc2xpZGVDb3VudDtcbn07XG5cbi8vIHNyYy9kZWZhdWx0LWNvbnRyb2xzLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBkZWZhdWx0QnV0dG9uU3R5bGVzID0gKGRpc2FibGVkKSA9PiAoe1xuICBib3JkZXI6IDAsXG4gIGJhY2tncm91bmQ6IFwicmdiYSgwLDAsMCwwLjQpXCIsXG4gIGNvbG9yOiBcIndoaXRlXCIsXG4gIHBhZGRpbmc6IDEwLFxuICB0ZXh0VHJhbnNmb3JtOiBcInVwcGVyY2FzZVwiLFxuICBvcGFjaXR5OiBkaXNhYmxlZCA/IDAuMyA6IDEsXG4gIGN1cnNvcjogZGlzYWJsZWQgPyBcIm5vdC1hbGxvd2VkXCIgOiBcInBvaW50ZXJcIlxufSk7XG52YXIgcHJldkJ1dHRvbkRpc2FibGVkID0gKHtcbiAgY2VsbEFsaWduLFxuICBjdXJyZW50U2xpZGUsXG4gIHNsaWRlc1RvU2hvdyxcbiAgd3JhcEFyb3VuZFxufSkgPT4ge1xuICBpZiAod3JhcEFyb3VuZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY3VycmVudFNsaWRlID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNlbGxBbGlnbiA9PT0gXCJyaWdodFwiICYmIGN1cnJlbnRTbGlkZSA8PSBzbGlkZXNUb1Nob3cgLSAxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBQcmV2aW91c0J1dHRvbiA9ICh7XG4gIHByZXZpb3VzU2xpZGUsXG4gIGRlZmF1bHRDb250cm9sc0NvbmZpZzoge1xuICAgIHByZXZCdXR0b25DbGFzc05hbWUsXG4gICAgcHJldkJ1dHRvblN0eWxlID0ge30sXG4gICAgcHJldkJ1dHRvblRleHQsXG4gICAgcHJldkJ1dHRvbk9uQ2xpY2tcbiAgfSxcbiAgb25Vc2VyTmF2aWdhdGlvbixcbiAgY2Fyb3VzZWxJZCxcbiAgcHJldmlvdXNEaXNhYmxlZDogZGlzYWJsZWRcbn0pID0+IHtcbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICBwcmV2QnV0dG9uT25DbGljayA9PSBudWxsID8gdm9pZCAwIDogcHJldkJ1dHRvbk9uQ2xpY2soZXZlbnQpO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIG9uVXNlck5hdmlnYXRpb24oZXZlbnQpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcHJldmlvdXNTbGlkZSgpO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMoXG4gICAgXCJidXR0b25cIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IHByZXZCdXR0b25DbGFzc05hbWUsXG4gICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGRlZmF1bHRCdXR0b25TdHlsZXMoZGlzYWJsZWQpKSwgcHJldkJ1dHRvblN0eWxlKSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgICBcImFyaWEtbGFiZWxcIjogXCJwcmV2aW91c1wiLFxuICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IGAke2Nhcm91c2VsSWR9LXNsaWRlci1mcmFtZWAsXG4gICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgY2hpbGRyZW46IHByZXZCdXR0b25UZXh0IHx8IFwiUHJldlwiXG4gICAgfVxuICApO1xufTtcbnZhciBuZXh0QnV0dG9uRGlzYWJsZWQgPSAoe1xuICBjZWxsQWxpZ24sXG4gIGN1cnJlbnRTbGlkZSxcbiAgc2xpZGVDb3VudCxcbiAgc2xpZGVzVG9TaG93LFxuICB3cmFwQXJvdW5kXG59KSA9PiB7XG4gIGlmICh3cmFwQXJvdW5kKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjdXJyZW50U2xpZGUgPj0gc2xpZGVDb3VudCAtIDEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY2VsbEFsaWduID09PSBcImxlZnRcIiAmJiBjdXJyZW50U2xpZGUgPj0gc2xpZGVDb3VudCAtIHNsaWRlc1RvU2hvdykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgTmV4dEJ1dHRvbiA9ICh7XG4gIG5leHRTbGlkZSxcbiAgZGVmYXVsdENvbnRyb2xzQ29uZmlnOiB7XG4gICAgbmV4dEJ1dHRvbkNsYXNzTmFtZSxcbiAgICBuZXh0QnV0dG9uU3R5bGUgPSB7fSxcbiAgICBuZXh0QnV0dG9uVGV4dCxcbiAgICBuZXh0QnV0dG9uT25DbGlja1xuICB9LFxuICBjYXJvdXNlbElkLFxuICBuZXh0RGlzYWJsZWQ6IGRpc2FibGVkLFxuICBvblVzZXJOYXZpZ2F0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgbmV4dEJ1dHRvbk9uQ2xpY2sgPT0gbnVsbCA/IHZvaWQgMCA6IG5leHRCdXR0b25PbkNsaWNrKGV2ZW50KTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBvblVzZXJOYXZpZ2F0aW9uKGV2ZW50KTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIG5leHRTbGlkZSgpO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMoXG4gICAgXCJidXR0b25cIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IG5leHRCdXR0b25DbGFzc05hbWUsXG4gICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGRlZmF1bHRCdXR0b25TdHlsZXMoZGlzYWJsZWQpKSwgbmV4dEJ1dHRvblN0eWxlKSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgICBcImFyaWEtbGFiZWxcIjogXCJuZXh0XCIsXG4gICAgICBcImFyaWEtY29udHJvbHNcIjogYCR7Y2Fyb3VzZWxJZH0tc2xpZGVyLWZyYW1lYCxcbiAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICBjaGlsZHJlbjogbmV4dEJ1dHRvblRleHQgfHwgXCJOZXh0XCJcbiAgICB9XG4gICk7XG59O1xudmFyIGdldERvdEluZGV4ZXMgPSAoc2xpZGVDb3VudCwgc2xpZGVzVG9TY3JvbGwsIHNjcm9sbE1vZGUsIHNsaWRlc1RvU2hvdywgd3JhcEFyb3VuZCwgY2VsbEFsaWduKSA9PiB7XG4gIGNvbnN0IGRvdEluZGV4ZXMgPSBbXTtcbiAgY29uc3Qgc2Nyb2xsU2xpZGVzID0gc2xpZGVzVG9TY3JvbGwgPD0gMCA/IDEgOiBzbGlkZXNUb1Njcm9sbDtcbiAgaWYgKHdyYXBBcm91bmQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlQ291bnQ7IGkgKz0gc2Nyb2xsU2xpZGVzKSB7XG4gICAgICBkb3RJbmRleGVzLnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiBkb3RJbmRleGVzO1xuICB9XG4gIGlmIChjZWxsQWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlQ291bnQgLSAxOyBpICs9IHNjcm9sbFNsaWRlcykge1xuICAgICAgZG90SW5kZXhlcy5wdXNoKGkpO1xuICAgIH1cbiAgICBpZiAoc2xpZGVDb3VudCA+IDApIHtcbiAgICAgIGRvdEluZGV4ZXMucHVzaChzbGlkZUNvdW50IC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBkb3RJbmRleGVzO1xuICB9XG4gIGlmIChjZWxsQWxpZ24gPT09IFwibGVmdFwiKSB7XG4gICAgaWYgKHNsaWRlc1RvU2hvdyA+PSBzbGlkZUNvdW50KSB7XG4gICAgICByZXR1cm4gWzBdO1xuICAgIH1cbiAgICBjb25zdCBsYXN0UG9zc2libGVJbmRleFdpdGhvdXRXaGl0ZXNwYWNlID0gc2xpZGVDb3VudCAtIHNsaWRlc1RvU2hvdztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RQb3NzaWJsZUluZGV4V2l0aG91dFdoaXRlc3BhY2U7IGkgKz0gc2Nyb2xsU2xpZGVzKSB7XG4gICAgICBkb3RJbmRleGVzLnB1c2goaSk7XG4gICAgfVxuICAgIGlmIChzY3JvbGxNb2RlID09PSBcInJlbWFpbmRlclwiIC8qIHJlbWFpbmRlciAqLykge1xuICAgICAgZG90SW5kZXhlcy5wdXNoKGxhc3RQb3NzaWJsZUluZGV4V2l0aG91dFdoaXRlc3BhY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb3RJbmRleGVzLnB1c2goZG90SW5kZXhlc1tkb3RJbmRleGVzLmxlbmd0aCAtIDFdICsgc2Nyb2xsU2xpZGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvdEluZGV4ZXM7XG4gIH1cbiAgaWYgKGNlbGxBbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgaWYgKHNsaWRlc1RvU2hvdyA+PSBzbGlkZUNvdW50KSB7XG4gICAgICByZXR1cm4gW3NsaWRlQ291bnQgLSAxXTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb3NzaWJsZUluZGV4V2l0aG91dFdoaXRlc3BhY2UgPSBzbGlkZXNUb1Nob3cgLSAxO1xuICAgIGlmIChzY3JvbGxNb2RlID09PSBcInJlbWFpbmRlclwiIC8qIHJlbWFpbmRlciAqLykge1xuICAgICAgZm9yIChsZXQgaSA9IGZpcnN0UG9zc2libGVJbmRleFdpdGhvdXRXaGl0ZXNwYWNlOyBpIDwgc2xpZGVDb3VudCAtIDE7IGkgKz0gc2Nyb2xsU2xpZGVzKSB7XG4gICAgICAgIGRvdEluZGV4ZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIGRvdEluZGV4ZXMucHVzaChzbGlkZUNvdW50IC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBzbGlkZUNvdW50IC0gMTsgaSA+IGZpcnN0UG9zc2libGVJbmRleFdpdGhvdXRXaGl0ZXNwYWNlOyBpIC09IHNjcm9sbFNsaWRlcykge1xuICAgICAgICBkb3RJbmRleGVzLnB1c2goaSk7XG4gICAgICB9XG4gICAgICBkb3RJbmRleGVzLnB1c2goZG90SW5kZXhlc1tkb3RJbmRleGVzLmxlbmd0aCAtIDFdIC0gc2Nyb2xsU2xpZGVzKTtcbiAgICAgIGRvdEluZGV4ZXMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZG90SW5kZXhlcztcbiAgfVxuICByZXR1cm4gZG90SW5kZXhlcztcbn07XG52YXIgUGFnaW5nRG90cyA9ICh7XG4gIHBhZ2luZ0RvdHNJbmRpY2VzLFxuICBkZWZhdWx0Q29udHJvbHNDb25maWc6IHtcbiAgICBwYWdpbmdEb3RzQ29udGFpbmVyQ2xhc3NOYW1lLFxuICAgIHBhZ2luZ0RvdHNDbGFzc05hbWUsXG4gICAgcGFnaW5nRG90c1N0eWxlID0ge30sXG4gICAgcGFnaW5nRG90c09uQ2xpY2tcbiAgfSxcbiAgY2Fyb3VzZWxJZCxcbiAgY3VycmVudFNsaWRlLFxuICBvblVzZXJOYXZpZ2F0aW9uLFxuICBzbGlkZUNvdW50LFxuICBnb1RvU2xpZGUsXG4gIHRhYmJlZFxufSkgPT4ge1xuICBjb25zdCBsaXN0U3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgdG9wOiAtMTAsXG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgbWFyZ2luOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgbGlzdFN0eWxlVHlwZTogXCJub25lXCJcbiAgfTtcbiAgY29uc3QgZ2V0QnV0dG9uU3R5bGVzID0gdXNlQ2FsbGJhY2soXG4gICAgKGFjdGl2ZSkgPT4gKHtcbiAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICBvcGFjaXR5OiBhY3RpdmUgPyAxIDogMC41LFxuICAgICAgYmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLFxuICAgIFtdXG4gICk7XG4gIGNvbnN0IGN1cnJlbnRTbGlkZUJvdW5kZWQgPSBnZXRCb3VuZGVkSW5kZXgoY3VycmVudFNsaWRlLCBzbGlkZUNvdW50KTtcbiAgaWYgKCF0YWJiZWQpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogcGFnaW5nRG90c0NvbnRhaW5lckNsYXNzTmFtZSxcbiAgICAgIHN0eWxlOiBsaXN0U3R5bGVzLFxuICAgICAgcm9sZTogXCJ0YWJsaXN0XCIsXG4gICAgICBcImFyaWEtbGFiZWxcIjogXCJDaG9vc2Ugc2xpZGUgdG8gZGlzcGxheS5cIixcbiAgICAgIGNoaWxkcmVuOiBwYWdpbmdEb3RzSW5kaWNlcy5tYXAoKHNsaWRlSW5kZXgsIGkpID0+IHtcbiAgICAgICAgY29uc3QgaXNBY3RpdmUgPSBjdXJyZW50U2xpZGVCb3VuZGVkID09PSBzbGlkZUluZGV4IHx8IC8vIHNldHMgbmF2aWdhdGlvbiBkb3RzIGFjdGl2ZSBpZiB0aGUgY3VycmVudCBzbGlkZSBmYWxscyBpbiB0aGUgY3VycmVudCBpbmRleCByYW5nZVxuICAgICAgICBjdXJyZW50U2xpZGVCb3VuZGVkIDwgc2xpZGVJbmRleCAmJiAoaSA9PT0gMCB8fCBjdXJyZW50U2xpZGVCb3VuZGVkID4gcGFnaW5nRG90c0luZGljZXNbaSAtIDFdKTtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFxuICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgIFwicGFnaW5nLWl0ZW1cIixcbiAgICAgICAgICAgICAgcGFnaW5nRG90c0NsYXNzTmFtZSxcbiAgICAgICAgICAgICAgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbFxuICAgICAgICAgICAgXS5qb2luKFwiIFwiKSxcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGdldEJ1dHRvblN0eWxlcyhpc0FjdGl2ZSkpLCBwYWdpbmdEb3RzU3R5bGUpLFxuICAgICAgICAgICAgb25DbGljazogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIHBhZ2luZ0RvdHNPbkNsaWNrID09IG51bGwgPyB2b2lkIDAgOiBwYWdpbmdEb3RzT25DbGljayhldmVudCk7XG4gICAgICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgb25Vc2VyTmF2aWdhdGlvbihldmVudCk7XG4gICAgICAgICAgICAgIGdvVG9TbGlkZShzbGlkZUluZGV4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogYHNsaWRlICR7c2xpZGVJbmRleCArIDF9YCxcbiAgICAgICAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBpc0FjdGl2ZSxcbiAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBgJHtjYXJvdXNlbElkfS1zbGlkZS0ke3NsaWRlSW5kZXggKyAxfWAsXG4gICAgICAgICAgICByb2xlOiBcInRhYlwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzKFxuICAgICAgICAgICAgICBcInN2Z1wiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcInBhZ2luZy1kb3RcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogXCI2XCIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjZcIixcbiAgICAgICAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgICAgIGZvY3VzYWJsZTogXCJmYWxzZVwiLFxuICAgICAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDYgNlwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MyhcImNpcmNsZVwiLCB7IGN4OiBcIjNcIiwgY3k6IFwiM1wiLCByOiBcIjNcIiB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbGlkZUluZGV4XG4gICAgICAgICk7XG4gICAgICB9KVxuICAgIH1cbiAgKTtcbn07XG5cbi8vIHNyYy9ob29rcy91c2UtdHdlZW4udHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIsIHVzZVJlZiBhcyB1c2VSZWYzIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlVHdlZW4gPSAoZHVyYXRpb25NcywgZWFzaW5nRnVuY3Rpb24sIG5hdmlnYXRpb25OdW0sIHNob3VsZEludGVycnVwdCkgPT4ge1xuICBjb25zdCBbbm9ybWFsaXplZFRpbWVSYXcsIHNldE5vcm1hbGl6ZWRUaW1lXSA9IHVzZVN0YXRlMigxKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gdXNlUmVmMyhEYXRlLm5vdygpKTtcbiAgY29uc3QgckFGID0gdXNlUmVmMygpO1xuICBjb25zdCBpc0ZpcnN0UmVuZGVyID0gdXNlUmVmMyh0cnVlKTtcbiAgY29uc3QgbGFzdE5hdmlnYXRpb25OdW0gPSB1c2VSZWYzKG51bGwpO1xuICBjb25zdCBub3JtYWxpemVkVGltZSA9IGxhc3ROYXZpZ2F0aW9uTnVtLmN1cnJlbnQgPT09IG51bGwgfHwgbGFzdE5hdmlnYXRpb25OdW0uY3VycmVudCA9PT0gbmF2aWdhdGlvbk51bSB8fCBzaG91bGRJbnRlcnJ1cHQgPyBub3JtYWxpemVkVGltZVJhdyA6IDA7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGxhc3ROYXZpZ2F0aW9uTnVtLmN1cnJlbnQgPSBuYXZpZ2F0aW9uTnVtO1xuICAgIGlmIChpc0ZpcnN0UmVuZGVyLmN1cnJlbnQpIHtcbiAgICAgIGlzRmlyc3RSZW5kZXIuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkSW50ZXJydXB0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXJ0VGltZS5jdXJyZW50ID0gRGF0ZS5ub3coKTtcbiAgICBzZXROb3JtYWxpemVkVGltZSgwKTtcbiAgICBjb25zdCB0aWNrID0gKCkgPT4ge1xuICAgICAgckFGLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUaW1lMiA9IE1hdGgubWluKFxuICAgICAgICAgIDEsXG4gICAgICAgICAgKGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lLmN1cnJlbnQpIC8gZHVyYXRpb25Nc1xuICAgICAgICApO1xuICAgICAgICBzZXROb3JtYWxpemVkVGltZShub3JtYWxpemVkVGltZTIpO1xuICAgICAgICBpZiAobm9ybWFsaXplZFRpbWUyIDwgMSkge1xuICAgICAgICAgIHRpY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByQUYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aWNrKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChyQUYuY3VycmVudCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJBRi5jdXJyZW50KTtcbiAgICAgICAgc2V0Tm9ybWFsaXplZFRpbWUoMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW25hdmlnYXRpb25OdW0sIGR1cmF0aW9uTXMsIHNob3VsZEludGVycnVwdF0pO1xuICByZXR1cm4ge1xuICAgIGlzQW5pbWF0aW5nOiBub3JtYWxpemVkVGltZSAhPT0gMSxcbiAgICB2YWx1ZTogZWFzaW5nRnVuY3Rpb24obm9ybWFsaXplZFRpbWUpXG4gIH07XG59O1xuXG4vLyBzcmMvc2xpZGVyLWxpc3QudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIGdldFBlcmNlbnRPZmZzZXRGb3JTbGlkZSA9IChjdXJyZW50U2xpZGUsIHNsaWRlQ291bnQsIHNsaWRlc1RvU2hvdywgY2VsbEFsaWduLCB3cmFwQXJvdW5kKSA9PiB7XG4gIGNvbnN0IHJlbmRlcmVkU2xpZGVDb3VudCA9IHdyYXBBcm91bmQgPyAzICogc2xpZGVDb3VudCA6IHNsaWRlQ291bnQ7XG4gIGNvbnN0IHNpbmdsZVNsaWRlUGVyY2VudE9mV2hvbGUgPSAxMDAgLyByZW5kZXJlZFNsaWRlQ291bnQ7XG4gIGxldCBzbGlkZTBPZmZzZXQgPSB3cmFwQXJvdW5kID8gLTEwMCAvIDMgOiAwO1xuICBpZiAoY2VsbEFsaWduID09PSBcInJpZ2h0XCIgJiYgc2xpZGVzVG9TaG93ID4gMSkge1xuICAgIGNvbnN0IGV4Y2Vzc1NsaWRlcyA9IHNsaWRlc1RvU2hvdyAtIDE7XG4gICAgc2xpZGUwT2Zmc2V0ICs9IHNpbmdsZVNsaWRlUGVyY2VudE9mV2hvbGUgKiBleGNlc3NTbGlkZXM7XG4gIH1cbiAgaWYgKGNlbGxBbGlnbiA9PT0gXCJjZW50ZXJcIiAmJiBzbGlkZXNUb1Nob3cgPiAxKSB7XG4gICAgY29uc3QgZXhjZXNzU2xpZGVzID0gc2xpZGVzVG9TaG93IC0gMTtcbiAgICBjb25zdCBleGNlc3NMZWZ0U2xpZGVzID0gZXhjZXNzU2xpZGVzIC8gMjtcbiAgICBzbGlkZTBPZmZzZXQgKz0gc2luZ2xlU2xpZGVQZXJjZW50T2ZXaG9sZSAqIGV4Y2Vzc0xlZnRTbGlkZXM7XG4gIH1cbiAgY29uc3QgY3VycmVudFNsaWRlT2Zmc2V0RnJvbTAgPSAxMDAgLyByZW5kZXJlZFNsaWRlQ291bnQgKiBjdXJyZW50U2xpZGU7XG4gIHJldHVybiBzbGlkZTBPZmZzZXQgLSBjdXJyZW50U2xpZGVPZmZzZXRGcm9tMDtcbn07XG52YXIgU2xpZGVyTGlzdCA9IFJlYWN0My5mb3J3YXJkUmVmKFxuICAoe1xuICAgIGFuaW1hdGlvbixcbiAgICBhbmltYXRpb25EaXN0YW5jZSxcbiAgICBjZWxsQWxpZ24sXG4gICAgY2hpbGRyZW4sXG4gICAgY3VycmVudFNsaWRlLFxuICAgIGRpc2FibGVBbmltYXRpb24sXG4gICAgZGlzYWJsZUVkZ2VTd2lwaW5nLFxuICAgIGRyYWdnZWRPZmZzZXQsXG4gICAgZWFzaW5nLFxuICAgIGVkZ2VFYXNpbmcsXG4gICAgaXNEcmFnZ2luZyxcbiAgICBzY3JvbGxNb2RlLFxuICAgIHNsaWRlQ291bnQsXG4gICAgc2xpZGVzVG9TY3JvbGwsXG4gICAgc2xpZGVzVG9TaG93LFxuICAgIHNwZWVkLFxuICAgIHdyYXBBcm91bmQsXG4gICAgc2xpZGVXaWR0aCxcbiAgICBzZXRJc0FuaW1hdGluZ1xuICB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCByZW5kZXJlZFNsaWRlQ291bnQgPSB3cmFwQXJvdW5kID8gMyAqIHNsaWRlQ291bnQgOiBzbGlkZUNvdW50O1xuICAgIGNvbnN0IGxpc3RWaXNpYmxlV2lkdGggPSBzbGlkZVdpZHRoID8gYGNhbGMoJHtzbGlkZVdpZHRofSAqICR7cmVuZGVyZWRTbGlkZUNvdW50fSlgIDogYCR7cmVuZGVyZWRTbGlkZUNvdW50ICogMTAwIC8gc2xpZGVzVG9TaG93fSVgO1xuICAgIGNvbnN0IHBlcmNlbnRPZmZzZXRGb3JTbGlkZVByb3BzID0gW1xuICAgICAgc2xpZGVDb3VudCxcbiAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgIGNlbGxBbGlnbixcbiAgICAgIHdyYXBBcm91bmRcbiAgICBdO1xuICAgIGNvbnN0IGRvdEluZGV4ZXMgPSBnZXREb3RJbmRleGVzKFxuICAgICAgc2xpZGVDb3VudCxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgIHdyYXBBcm91bmQsXG4gICAgICBjZWxsQWxpZ25cbiAgICApO1xuICAgIGxldCBjbGFtcGVkRHJhZ2dlZE9mZnNldCA9IGAke2RyYWdnZWRPZmZzZXR9cHhgO1xuICAgIGlmIChpc0RyYWdnaW5nICYmIGRpc2FibGVFZGdlU3dpcGluZyAmJiAhd3JhcEFyb3VuZCkge1xuICAgICAgY29uc3QgY2xhbXBPZmZzZXRzID0gW1xuICAgICAgICBkb3RJbmRleGVzWzBdLFxuICAgICAgICBkb3RJbmRleGVzW2RvdEluZGV4ZXMubGVuZ3RoIC0gMV1cbiAgICAgIF0ubWFwKFxuICAgICAgICAoaW5kZXgpID0+IGdldFBlcmNlbnRPZmZzZXRGb3JTbGlkZShpbmRleCwgLi4ucGVyY2VudE9mZnNldEZvclNsaWRlUHJvcHMpXG4gICAgICApO1xuICAgICAgY2xhbXBlZERyYWdnZWRPZmZzZXQgPSBgY2xhbXAoJHtjbGFtcE9mZnNldHNbMV19JSwgJHtkcmFnZ2VkT2Zmc2V0fXB4LCAke2NsYW1wT2Zmc2V0c1swXX0lKWA7XG4gICAgfVxuICAgIGNvbnN0IHNsaWRlQmFzZWRPZmZzZXQgPSBnZXRQZXJjZW50T2Zmc2V0Rm9yU2xpZGUoXG4gICAgICBjdXJyZW50U2xpZGUsXG4gICAgICAuLi5wZXJjZW50T2Zmc2V0Rm9yU2xpZGVQcm9wc1xuICAgICk7XG4gICAgY29uc3QgaXNFZGdlRWFzaW5nID0gIWRpc2FibGVFZGdlU3dpcGluZyAmJiAhd3JhcEFyb3VuZCAmJiAoY3VycmVudFNsaWRlID09PSBkb3RJbmRleGVzWzBdICYmIGFuaW1hdGlvbkRpc3RhbmNlIDwgMCB8fCBjdXJyZW50U2xpZGUgPT09IGRvdEluZGV4ZXNbZG90SW5kZXhlcy5sZW5ndGggLSAxXSAmJiBhbmltYXRpb25EaXN0YW5jZSA+IDApO1xuICAgIGNvbnN0IHsgdmFsdWU6IHRyYW5zaXRpb24sIGlzQW5pbWF0aW5nIH0gPSB1c2VUd2VlbihcbiAgICAgIHNwZWVkLFxuICAgICAgIWlzRWRnZUVhc2luZyA/IGVhc2luZyA6IGVkZ2VFYXNpbmcsXG4gICAgICAvLyBhbmltYXRpb25EaXN0YW5jZSBpcyBhc3N1bWVkIHRvIGJlIHVuaXF1ZSBlbm91Z2ggdGhhdCBpdCBjYW4gYmUgdXNlZCB0b1xuICAgICAgLy8gZGV0ZWN0IHdoZW4gYSBuZXcgYW5pbWF0aW9uIHNob3VsZCBzdGFydC4gVGhpcyBpcyB1c2VkIGluIGFkZGl0aW9uIHRvXG4gICAgICAvLyBjdXJyZW50U2xpZGUgYmVjYXVzZSBzb21lIGFuaW1hdGlvbnMsIHN1Y2ggYXMgdGhvc2Ugd2l0aCBlZGdlRWFzaW5nLCBkb1xuICAgICAgLy8gbm90IG9jY3VyIGR1ZSB0byBhIGNoYW5nZSBpbiB2YWx1ZSBvZiBjdXJyZW50U2xpZGVcbiAgICAgIGN1cnJlbnRTbGlkZSArIGFuaW1hdGlvbkRpc3RhbmNlLFxuICAgICAgaXNEcmFnZ2luZyB8fCBkaXNhYmxlQW5pbWF0aW9uIHx8IGFuaW1hdGlvbiA9PT0gXCJmYWRlXCJcbiAgICApO1xuICAgIGxldCBwb3NpdGlvbmluZztcbiAgICBpZiAoaXNEcmFnZ2luZyB8fCBzbGlkZUJhc2VkT2Zmc2V0ICE9PSAwIHx8IGlzQW5pbWF0aW5nKSB7XG4gICAgICBpZiAoaXNEcmFnZ2luZykge1xuICAgICAgICBwb3NpdGlvbmluZyA9IGB0cmFuc2xhdGVYKCR7Y2xhbXBlZERyYWdnZWRPZmZzZXR9KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0cmFuc2l0aW9uT2Zmc2V0ID0gaXNBbmltYXRpbmcgPyAoMSAtIHRyYW5zaXRpb24pICogYW5pbWF0aW9uRGlzdGFuY2UgOiAwO1xuICAgICAgICBwb3NpdGlvbmluZyA9IGB0cmFuc2xhdGVYKGNhbGMoJHtzbGlkZUJhc2VkT2Zmc2V0fSUgLSAke3RyYW5zaXRpb25PZmZzZXR9cHgpKWA7XG4gICAgICB9XG4gICAgfVxuICAgIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgICAgc2V0SXNBbmltYXRpbmcoaXNBbmltYXRpbmcpO1xuICAgIH0sIFtpc0FuaW1hdGluZywgc2V0SXNBbmltYXRpbmddKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgICAgY2xhc3NOYW1lOiBcInNsaWRlci1saXN0XCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgd2lkdGg6IGxpc3RWaXNpYmxlV2lkdGgsXG4gICAgICAgICAgdGV4dEFsaWduOiBcImxlZnRcIixcbiAgICAgICAgICB1c2VyU2VsZWN0OiBcImF1dG9cIixcbiAgICAgICAgICB0cmFuc2Zvcm06IHBvc2l0aW9uaW5nLFxuICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcblNsaWRlckxpc3QuZGlzcGxheU5hbWUgPSBcIlNsaWRlckxpc3RcIjtcblxuLy8gc3JjL2NvbnRyb2xzLnRzeFxuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2NvbnRyb2wtc3R5bGVzLnRzXG52YXIgY29tbW9uU3R5bGVzID0ge1xuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICBkaXNwbGF5OiBcImZsZXhcIixcbiAgekluZGV4OiAxLFxuICB0b3A6IDAsXG4gIGxlZnQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgcmlnaHQ6IDBcbn07XG52YXIgZ2V0Q29udHJvbENvbnRhaW5lckZsZXhTdHlsZXMgPSAocG9zKSA9PiB7XG4gIGxldCBhbGlnbkl0ZW1zO1xuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgXCJUb3BMZWZ0XCIgLyogVG9wTGVmdCAqLzpcbiAgICBjYXNlIFwiVG9wQ2VudGVyXCIgLyogVG9wQ2VudGVyICovOlxuICAgIGNhc2UgXCJUb3BSaWdodFwiIC8qIFRvcFJpZ2h0ICovOlxuICAgICAgYWxpZ25JdGVtcyA9IFwiZmxleC1zdGFydFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkNlbnRlckxlZnRcIiAvKiBDZW50ZXJMZWZ0ICovOlxuICAgIGNhc2UgXCJDZW50ZXJDZW50ZXJcIiAvKiBDZW50ZXJDZW50ZXIgKi86XG4gICAgY2FzZSBcIkNlbnRlclJpZ2h0XCIgLyogQ2VudGVyUmlnaHQgKi86XG4gICAgICBhbGlnbkl0ZW1zID0gXCJjZW50ZXJcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJCb3R0b21MZWZ0XCIgLyogQm90dG9tTGVmdCAqLzpcbiAgICBjYXNlIFwiQm90dG9tQ2VudGVyXCIgLyogQm90dG9tQ2VudGVyICovOlxuICAgIGNhc2UgXCJCb3R0b21SaWdodFwiIC8qIEJvdHRvbVJpZ2h0ICovOlxuICAgICAgYWxpZ25JdGVtcyA9IFwiZmxleC1lbmRcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGxldCBqdXN0aWZ5Q29udGVudDtcbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlIFwiVG9wTGVmdFwiIC8qIFRvcExlZnQgKi86XG4gICAgY2FzZSBcIkNlbnRlckxlZnRcIiAvKiBDZW50ZXJMZWZ0ICovOlxuICAgIGNhc2UgXCJCb3R0b21MZWZ0XCIgLyogQm90dG9tTGVmdCAqLzpcbiAgICAgIGp1c3RpZnlDb250ZW50ID0gXCJmbGV4LXN0YXJ0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiVG9wQ2VudGVyXCIgLyogVG9wQ2VudGVyICovOlxuICAgIGNhc2UgXCJDZW50ZXJDZW50ZXJcIiAvKiBDZW50ZXJDZW50ZXIgKi86XG4gICAgY2FzZSBcIkJvdHRvbUNlbnRlclwiIC8qIEJvdHRvbUNlbnRlciAqLzpcbiAgICAgIGp1c3RpZnlDb250ZW50ID0gXCJjZW50ZXJcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJUb3BSaWdodFwiIC8qIFRvcFJpZ2h0ICovOlxuICAgIGNhc2UgXCJDZW50ZXJSaWdodFwiIC8qIENlbnRlclJpZ2h0ICovOlxuICAgIGNhc2UgXCJCb3R0b21SaWdodFwiIC8qIEJvdHRvbVJpZ2h0ICovOlxuICAgICAganVzdGlmeUNvbnRlbnQgPSBcImZsZXgtZW5kXCI7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4geyBhbGlnbkl0ZW1zLCBqdXN0aWZ5Q29udGVudCB9O1xufTtcbnZhciBnZXRDb250cm9sQ29udGFpbmVyU3R5bGVzID0gKHBvcykgPT4ge1xuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGdldENvbnRyb2xDb250YWluZXJGbGV4U3R5bGVzKHBvcykpLCBjb21tb25TdHlsZXMpO1xufTtcblxuLy8gc3JjL2NvbnRyb2xzLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDUgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBjb250cm9sc01hcCA9IFtcbiAgeyBmdW5jTmFtZTogXCJyZW5kZXJUb3BMZWZ0Q29udHJvbHNcIiwga2V5OiBcIlRvcExlZnRcIiAvKiBUb3BMZWZ0ICovIH0sXG4gIHsgZnVuY05hbWU6IFwicmVuZGVyVG9wQ2VudGVyQ29udHJvbHNcIiwga2V5OiBcIlRvcENlbnRlclwiIC8qIFRvcENlbnRlciAqLyB9LFxuICB7IGZ1bmNOYW1lOiBcInJlbmRlclRvcFJpZ2h0Q29udHJvbHNcIiwga2V5OiBcIlRvcFJpZ2h0XCIgLyogVG9wUmlnaHQgKi8gfSxcbiAgeyBmdW5jTmFtZTogXCJyZW5kZXJDZW50ZXJMZWZ0Q29udHJvbHNcIiwga2V5OiBcIkNlbnRlckxlZnRcIiAvKiBDZW50ZXJMZWZ0ICovIH0sXG4gIHsgZnVuY05hbWU6IFwicmVuZGVyQ2VudGVyQ2VudGVyQ29udHJvbHNcIiwga2V5OiBcIkNlbnRlckNlbnRlclwiIC8qIENlbnRlckNlbnRlciAqLyB9LFxuICB7IGZ1bmNOYW1lOiBcInJlbmRlckNlbnRlclJpZ2h0Q29udHJvbHNcIiwga2V5OiBcIkNlbnRlclJpZ2h0XCIgLyogQ2VudGVyUmlnaHQgKi8gfSxcbiAgeyBmdW5jTmFtZTogXCJyZW5kZXJCb3R0b21MZWZ0Q29udHJvbHNcIiwga2V5OiBcIkJvdHRvbUxlZnRcIiAvKiBCb3R0b21MZWZ0ICovIH0sXG4gIHsgZnVuY05hbWU6IFwicmVuZGVyQm90dG9tQ2VudGVyQ29udHJvbHNcIiwga2V5OiBcIkJvdHRvbUNlbnRlclwiIC8qIEJvdHRvbUNlbnRlciAqLyB9LFxuICB7IGZ1bmNOYW1lOiBcInJlbmRlckJvdHRvbVJpZ2h0Q29udHJvbHNcIiwga2V5OiBcIkJvdHRvbVJpZ2h0XCIgLyogQm90dG9tUmlnaHQgKi8gfVxuXTtcbnZhciByZW5kZXJDb250cm9scyA9IChwcm9wcywgc2xpZGVDb3VudCwgY3VycmVudFNsaWRlLCBnb1RvU2xpZGUsIG5leHRTbGlkZSwgcHJldlNsaWRlLCBzbGlkZXNUb1Njcm9sbCkgPT4ge1xuICBpZiAocHJvcHMud2l0aG91dENvbnRyb2xzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZGlzYWJsZUNoZWNrUHJvcHMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcyksIHtcbiAgICBjdXJyZW50U2xpZGUsXG4gICAgc2xpZGVDb3VudFxuICB9KTtcbiAgY29uc3QgbmV4dERpc2FibGVkID0gbmV4dEJ1dHRvbkRpc2FibGVkKGRpc2FibGVDaGVja1Byb3BzKTtcbiAgY29uc3QgcHJldmlvdXNEaXNhYmxlZCA9IHByZXZCdXR0b25EaXNhYmxlZChkaXNhYmxlQ2hlY2tQcm9wcyk7XG4gIGNvbnN0IHBhZ2luZ0RvdHNJbmRpY2VzID0gZ2V0RG90SW5kZXhlcyhcbiAgICBzbGlkZUNvdW50LFxuICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgIHByb3BzLnNjcm9sbE1vZGUsXG4gICAgcHJvcHMuc2xpZGVzVG9TaG93LFxuICAgIHByb3BzLndyYXBBcm91bmQsXG4gICAgcHJvcHMuY2VsbEFsaWduXG4gICk7XG4gIHJldHVybiBjb250cm9sc01hcC5tYXAoKGNvbnRyb2wpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFwcm9wc1tjb250cm9sLmZ1bmNOYW1lXSB8fCB0eXBlb2YgcHJvcHNbY29udHJvbC5mdW5jTmFtZV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g1KEZyYWdtZW50LCB7fSwgY29udHJvbC5mdW5jTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NShcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBnZXRDb250cm9sQ29udGFpbmVyU3R5bGVzKGNvbnRyb2wua2V5KSksIHtcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgICAgICB9KSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g1KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgIGBzbGlkZXItY29udHJvbC0ke2NvbnRyb2wua2V5LnRvTG93ZXJDYXNlKCl9YCxcbiAgICAgICAgICAgICAgcHJvcHMuZGVmYXVsdENvbnRyb2xzQ29uZmlnLmNvbnRhaW5lckNsYXNzTmFtZSB8fCBcIlwiXG4gICAgICAgICAgICBdLmpvaW4oXCIgXCIpLnRyaW0oKSxcbiAgICAgICAgICAgIHN0eWxlOiB7IHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogKF9hID0gcHJvcHNbY29udHJvbC5mdW5jTmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHByb3BzLCB7XG4gICAgICAgICAgICAgIGNlbGxBbGlnbjogcHJvcHMuY2VsbEFsaWduLFxuICAgICAgICAgICAgICBjZWxsU3BhY2luZzogcHJvcHMuY2VsbFNwYWNpbmcsXG4gICAgICAgICAgICAgIGN1cnJlbnRTbGlkZSxcbiAgICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xzQ29uZmlnOiBwcm9wcy5kZWZhdWx0Q29udHJvbHNDb25maWcgfHwge30sXG4gICAgICAgICAgICAgIGNhcm91c2VsSWQ6IHByb3BzLmNhcm91c2VsSWQsXG4gICAgICAgICAgICAgIHBhZ2luZ0RvdHNJbmRpY2VzLFxuICAgICAgICAgICAgICBnb1RvU2xpZGUsXG4gICAgICAgICAgICAgIG5leHREaXNhYmxlZCxcbiAgICAgICAgICAgICAgbmV4dFNsaWRlLFxuICAgICAgICAgICAgICBvblVzZXJOYXZpZ2F0aW9uOiBwcm9wcy5vblVzZXJOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICBwcmV2aW91c0Rpc2FibGVkLFxuICAgICAgICAgICAgICBwcmV2aW91c1NsaWRlOiBwcmV2U2xpZGUsXG4gICAgICAgICAgICAgIHNjcm9sbE1vZGU6IHByb3BzLnNjcm9sbE1vZGUsXG4gICAgICAgICAgICAgIHNsaWRlQ291bnQsXG4gICAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgICAgICAgICBzbGlkZXNUb1Nob3c6IHByb3BzLnNsaWRlc1RvU2hvdyB8fCAxLFxuICAgICAgICAgICAgICB0YWJiZWQ6IHByb3BzLnRhYmJlZCxcbiAgICAgICAgICAgICAgdmVydGljYWw6IHByb3BzLnZlcnRpY2FsLFxuICAgICAgICAgICAgICB3cmFwQXJvdW5kOiBwcm9wcy53cmFwQXJvdW5kXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGNvbnRyb2wuZnVuY05hbWVcbiAgICApO1xuICB9KTtcbn07XG52YXIgY29udHJvbHNfZGVmYXVsdCA9IHJlbmRlckNvbnRyb2xzO1xuXG4vLyBzcmMvZGVmYXVsdC1jYXJvdXNlbC1wcm9wcy50c3hcbmltcG9ydCB7IEZyYWdtZW50IGFzIEZyYWdtZW50MiwganN4IGFzIGpzeDYgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBlYXNlT3V0ID0gKHQpID0+IF9fcG93KHQgLSAxLCAzKSArIDE7XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBhZGFwdGl2ZUhlaWdodDogZmFsc2UsXG4gIGFkYXB0aXZlSGVpZ2h0QW5pbWF0aW9uOiB0cnVlLFxuICBhZnRlclNsaWRlOiAoKSA9PiB7XG4gIH0sXG4gIGF1dG9wbGF5OiBmYWxzZSxcbiAgYXV0b3BsYXlJbnRlcnZhbDogM2UzLFxuICBhdXRvcGxheVJldmVyc2U6IGZhbHNlLFxuICBiZWZvcmVTbGlkZTogKCkgPT4ge1xuICB9LFxuICBjZWxsQWxpZ246IFwibGVmdFwiLFxuICBjZWxsU3BhY2luZzogMCxcbiAgZGVmYXVsdENvbnRyb2xzQ29uZmlnOiB7fSxcbiAgZGlzYWJsZUFuaW1hdGlvbjogZmFsc2UsXG4gIGRpc2FibGVFZGdlU3dpcGluZzogZmFsc2UsXG4gIGRyYWdnaW5nOiB0cnVlLFxuICBkcmFnVGhyZXNob2xkOiAwLjUsXG4gIGVhc2luZzogZWFzZU91dCxcbiAgZWRnZUVhc2luZzogZWFzZU91dCxcbiAgZW5hYmxlS2V5Ym9hcmRDb250cm9sczogZmFsc2UsXG4gIGZyYW1lQXJpYUxhYmVsOiBcIlNsaWRlclwiLFxuICBrZXlDb2RlQ29uZmlnOiB7XG4gICAgbmV4dFNsaWRlOiBbMzksIDY4LCAzOCwgODddLFxuICAgIHByZXZpb3VzU2xpZGU6IFszNywgNjUsIDQwLCA4M10sXG4gICAgZmlyc3RTbGlkZTogWzgxXSxcbiAgICBsYXN0U2xpZGU6IFs2OV0sXG4gICAgcGF1c2U6IFszMl1cbiAgfSxcbiAgbGFuZG1hcms6IGZhbHNlLFxuICBvbkRyYWdTdGFydDogKCkgPT4ge1xuICB9LFxuICBvbkRyYWc6ICgpID0+IHtcbiAgfSxcbiAgb25EcmFnRW5kOiAoKSA9PiB7XG4gIH0sXG4gIG9uVXNlck5hdmlnYXRpb246ICgpID0+IHtcbiAgfSxcbiAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuICByZW5kZXJBbm5vdW5jZVNsaWRlTWVzc2FnZTogZGVmYXVsdFJlbmRlckFubm91bmNlU2xpZGVNZXNzYWdlLFxuICByZW5kZXJCb3R0b21DZW50ZXJDb250cm9sczogKHByb3BzKSA9PiAvKiBAX19QVVJFX18gKi8ganN4NihQYWdpbmdEb3RzLCBfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpKSxcbiAgcmVuZGVyQ2VudGVyTGVmdENvbnRyb2xzOiAocHJvcHMpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3g2KFByZXZpb3VzQnV0dG9uLCBfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpKSxcbiAgcmVuZGVyQ2VudGVyUmlnaHRDb250cm9sczogKHByb3BzKSA9PiAvKiBAX19QVVJFX18gKi8ganN4NihOZXh0QnV0dG9uLCBfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpKSxcbiAgc2Nyb2xsTW9kZTogXCJwYWdlXCIgLyogcGFnZSAqLyxcbiAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gIHNsaWRlc1RvU2hvdzogMSxcbiAgc3BlZWQ6IDUwMCxcbiAgc3R5bGU6IHt9LFxuICBzd2lwaW5nOiB0cnVlLFxuICB0YWJiZWQ6IHRydWUsXG4gIHZlcnRpY2FsOiBmYWxzZSxcbiAgd2l0aG91dENvbnRyb2xzOiBmYWxzZSxcbiAgd3JhcEFyb3VuZDogZmFsc2UsXG4gIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NihGcmFnbWVudDIsIHt9KVxufTtcbnZhciBkZWZhdWx0X2Nhcm91c2VsX3Byb3BzX2RlZmF1bHQgPSBkZWZhdWx0UHJvcHM7XG5cbi8vIHNyYy9ob29rcy91c2UtZnJhbWUtaGVpZ2h0LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazMsIHVzZU1lbW8sIHVzZVN0YXRlIGFzIHVzZVN0YXRlNCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvaG9va3MvdXNlLXN0YXRlLXdpdGgtcmVmLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZVJlZiBhcyB1c2VSZWY0LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTMgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VTdGF0ZVdpdGhSZWYgPSAoaW5pdGlhbFN0YXRlKSA9PiB7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUzKGluaXRpYWxTdGF0ZSk7XG4gIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmNChpbml0aWFsU3RhdGUpO1xuICBjb25zdCBzZXRWYWx1ZUFuZFJlZiA9IHVzZUNhbGxiYWNrMigobmV3VmFsdWUpID0+IHtcbiAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV3VmFsdWU7XG4gICAgc2V0VmFsdWUobmV3VmFsdWUpO1xuICB9LCBbXSk7XG4gIHJldHVybiBbdmFsdWUsIHNldFZhbHVlQW5kUmVmLCB2YWx1ZVJlZl07XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlLWZyYW1lLWhlaWdodC50c1xudmFyIHVzZUZyYW1lSGVpZ2h0ID0gKGFkYXB0aXZlSGVpZ2h0LCBzbGlkZXNUb1Nob3csIHNsaWRlQ291bnQpID0+IHtcbiAgY29uc3QgW3Zpc2libGVIZWlnaHRzLCBzZXRWaXNpYmxlSGVpZ2h0cywgdmlzaWJsZUhlaWdodHNSZWZdID0gdXNlU3RhdGVXaXRoUmVmKFtdKTtcbiAgY29uc3QgW2luaXRpYWxpemVkQWRhcHRpdmVIZWlnaHQsIHNldEluaXRpYWxpemVkQWRhcHRpdmVIZWlnaHRdID0gdXNlU3RhdGU0KGZhbHNlKTtcbiAgY29uc3QgaGFuZGxlVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlID0gdXNlQ2FsbGJhY2szKFxuICAgIChzbGlkZUluZGV4LCBoZWlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGxhdGVzdFZpc2libGVIZWlnaHRzID0gdmlzaWJsZUhlaWdodHNSZWYuY3VycmVudDtcbiAgICAgIGxldCBuZXdWaXNpYmxlSGVpZ2h0cztcbiAgICAgIGlmIChoZWlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgbmV3VmlzaWJsZUhlaWdodHMgPSBsYXRlc3RWaXNpYmxlSGVpZ2h0cy5maWx0ZXIoXG4gICAgICAgICAgKHNsaWRlSGVpZ2h0KSA9PiBzbGlkZUhlaWdodC5zbGlkZUluZGV4ICE9PSBzbGlkZUluZGV4XG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWaXNpYmxlSGVpZ2h0cyA9IFsuLi5sYXRlc3RWaXNpYmxlSGVpZ2h0cywgeyBzbGlkZUluZGV4LCBoZWlnaHQgfV07XG4gICAgICB9XG4gICAgICBzZXRWaXNpYmxlSGVpZ2h0cyhuZXdWaXNpYmxlSGVpZ2h0cyk7XG4gICAgICBpZiAobmV3VmlzaWJsZUhlaWdodHMubGVuZ3RoID49IE1hdGgubWluKHNsaWRlQ291bnQsIE1hdGguY2VpbChzbGlkZXNUb1Nob3cpKSkge1xuICAgICAgICBzZXRJbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0KHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3NsaWRlQ291bnQsIHNldFZpc2libGVIZWlnaHRzLCBzbGlkZXNUb1Nob3csIHZpc2libGVIZWlnaHRzUmVmXVxuICApO1xuICBjb25zdCBmcmFtZUhlaWdodCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChhZGFwdGl2ZUhlaWdodCkge1xuICAgICAgaWYgKCFpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBcImF1dG9cIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IE1hdGgubWF4KFxuICAgICAgICAwLFxuICAgICAgICAuLi52aXNpYmxlSGVpZ2h0cy5tYXAoKGhlaWdodCkgPT4gaGVpZ2h0LmhlaWdodClcbiAgICAgICk7XG4gICAgICByZXR1cm4gYCR7bWF4SGVpZ2h0fXB4YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiYXV0b1wiO1xuICAgIH1cbiAgfSwgW2FkYXB0aXZlSGVpZ2h0LCBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0LCB2aXNpYmxlSGVpZ2h0c10pO1xuICByZXR1cm4ge1xuICAgIGhhbmRsZVZpc2libGVTbGlkZUhlaWdodENoYW5nZSxcbiAgICBmcmFtZUhlaWdodCxcbiAgICBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0XG4gIH07XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlLWZvcndhcmQtcmVmLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NSwgdXNlUmVmIGFzIHVzZVJlZjUgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VGb3J3YXJkUmVmID0gKHJlZikgPT4ge1xuICBjb25zdCB0YXJnZXRSZWYgPSB1c2VSZWY1KG51bGwpO1xuICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICBpZiAoIXJlZilcbiAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZWYodGFyZ2V0UmVmLmN1cnJlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IHRhcmdldFJlZi5jdXJyZW50O1xuICAgIH1cbiAgfSwgW3JlZl0pO1xuICByZXR1cm4gdGFyZ2V0UmVmO1xufTtcblxuLy8gc3JjL2Nhcm91c2VsLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDcsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBDYXJvdXNlbCA9IFJlYWN0NS5mb3J3YXJkUmVmKFxuICAocmF3UHJvcHMsIHJlZikgPT4ge1xuICAgIGNvbnN0IHByb3BzID0gcmF3UHJvcHM7XG4gICAgY29uc3QgaW50ZXJuYWxDYXJvdXNlbElkID0gdXNlSWQoKTtcbiAgICBjb25zdCB7XG4gICAgICBhZGFwdGl2ZUhlaWdodCxcbiAgICAgIGFkYXB0aXZlSGVpZ2h0QW5pbWF0aW9uLFxuICAgICAgYWZ0ZXJTbGlkZSxcbiAgICAgIGFuaW1hdGlvbixcbiAgICAgIGF1dG9wbGF5LFxuICAgICAgYXV0b3BsYXlJbnRlcnZhbCxcbiAgICAgIGF1dG9wbGF5UmV2ZXJzZSxcbiAgICAgIGJlZm9yZVNsaWRlLFxuICAgICAgY2Fyb3VzZWxJZCA9IGludGVybmFsQ2Fyb3VzZWxJZCxcbiAgICAgIGNlbGxBbGlnbjogcHJvcHNDZWxsQWxpZ24sXG4gICAgICBjZWxsU3BhY2luZyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgZGlzYWJsZUFuaW1hdGlvbixcbiAgICAgIGRyYWdnaW5nOiBkZXNrdG9wRHJhZ2dpbmdFbmFibGVkLFxuICAgICAgZHJhZ1RocmVzaG9sZDogcHJvcHNEcmFnVGhyZXNob2xkLFxuICAgICAgZW5hYmxlS2V5Ym9hcmRDb250cm9scyxcbiAgICAgIGZyYW1lQXJpYUxhYmVsLFxuICAgICAga2V5Q29kZUNvbmZpZyxcbiAgICAgIGxhbmRtYXJrLFxuICAgICAgb25EcmFnLFxuICAgICAgb25EcmFnRW5kLFxuICAgICAgb25EcmFnU3RhcnQsXG4gICAgICBvblVzZXJOYXZpZ2F0aW9uLFxuICAgICAgcGF1c2VPbkhvdmVyLFxuICAgICAgcmVuZGVyQW5ub3VuY2VTbGlkZU1lc3NhZ2UsXG4gICAgICBzY3JvbGxNb2RlOiBwcm9wc1Njcm9sbE1vZGUsXG4gICAgICBzbGlkZUluZGV4LFxuICAgICAgc2xpZGVzVG9TY3JvbGw6IHByb3BzU2xpZGVzVG9TY3JvbGwsXG4gICAgICBzbGlkZXNUb1Nob3c6IHByb3BzU2xpZGVzVG9TaG93LFxuICAgICAgc2xpZGVXaWR0aCxcbiAgICAgIHNwZWVkLFxuICAgICAgc3R5bGUsXG4gICAgICBzd2lwaW5nOiBtb2JpbGVEcmFnZ2luZ0VuYWJsZWQsXG4gICAgICB0YWJiZWQsXG4gICAgICB3cmFwQXJvdW5kLFxuICAgICAgem9vbVNjYWxlXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IGZpbHRlcmVkU2xpZGVzID0gUmVhY3Q1LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBzbGlkZUNvdW50ID0gZmlsdGVyZWRTbGlkZXMubGVuZ3RoO1xuICAgIGNvbnN0IGNlbGxBbGlnbiA9IHNsaWRlV2lkdGggfHwgcHJvcHNTbGlkZXNUb1Njcm9sbCA9PT0gXCJhdXRvXCIgPyBcImxlZnRcIiA6IHByb3BzQ2VsbEFsaWduO1xuICAgIGNvbnN0IHNjcm9sbE1vZGUgPSBwcm9wc1NsaWRlc1RvU2Nyb2xsID09PSBcImF1dG9cIiA/IFwicmVtYWluZGVyXCIgLyogcmVtYWluZGVyICovIDogcHJvcHNTY3JvbGxNb2RlO1xuICAgIGNvbnN0IFtzbGlkZUlPRW50cmllcywgc2V0U2xpZGVJT0VudHJpZXNdID0gdXNlU3RhdGU1KFxuICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICAgICk7XG4gICAgY29uc3QgdmlzaWJsZUNvdW50ID0gQXJyYXkuZnJvbShzbGlkZUlPRW50cmllcykuZmlsdGVyKFxuICAgICAgKFssIHZpc2libGVdKSA9PiB2aXNpYmxlXG4gICAgKS5sZW5ndGg7XG4gICAgY29uc3QgW2NvbnN0YW50VmlzaWJsZUNvdW50LCBzZXRDb25zdGFudFZpc2libGVDb3VudF0gPSB1c2VTdGF0ZTUodmlzaWJsZUNvdW50KTtcbiAgICBjb25zdCBzbGlkZXNUb1Nob3cgPSBzbGlkZVdpZHRoID8gY29uc3RhbnRWaXNpYmxlQ291bnQgOiBwcm9wc1NsaWRlc1RvU2hvdztcbiAgICBjb25zdCBzbGlkZXNUb1Njcm9sbCA9IGFuaW1hdGlvbiA9PT0gXCJmYWRlXCIgPyBzbGlkZXNUb1Nob3cgOiBwcm9wc1NsaWRlc1RvU2Nyb2xsID09PSBcImF1dG9cIiA/IE1hdGgubWF4KGNvbnN0YW50VmlzaWJsZUNvdW50LCAxKSA6IHByb3BzU2xpZGVzVG9TY3JvbGw7XG4gICAgY29uc3QgW2N1cnJlbnRTbGlkZSwgc2V0Q3VycmVudFNsaWRlXSA9IHVzZVN0YXRlNShcbiAgICAgICgpID0+IGdldERlZmF1bHRTbGlkZUluZGV4KFxuICAgICAgICBzbGlkZUluZGV4LFxuICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICBzbGlkZXNUb1Nob3csXG4gICAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgICBjZWxsQWxpZ24sXG4gICAgICAgIGF1dG9wbGF5UmV2ZXJzZSxcbiAgICAgICAgc2Nyb2xsTW9kZVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3QgW3BhdXNlLCBzZXRQYXVzZV0gPSB1c2VTdGF0ZTUoZmFsc2UpO1xuICAgIGNvbnN0IFtpc0RyYWdnaW5nLCBzZXRJc0RyYWdnaW5nXSA9IHVzZVN0YXRlNShmYWxzZSk7XG4gICAgY29uc3QgW2RyYWdEaXN0YW5jZSwgc2V0RHJhZ0Rpc3RhbmNlXSA9IHVzZVN0YXRlNSgwKTtcbiAgICBjb25zdCBbYW5pbWF0aW9uRGlzdGFuY2UsIHNldEFuaW1hdGlvbkRpc3RhbmNlXSA9IHVzZVN0YXRlNSgwKTtcbiAgICBjb25zdCBbaXNBbmltYXRpbmcsIHNldElzQW5pbWF0aW5nXSA9IHVzZVN0YXRlNShmYWxzZSk7XG4gICAgY29uc3QgdXBkYXRlU2xpZGVJT0VudHJ5ID0gdXNlQ2FsbGJhY2s0KFxuICAgICAgKGlkLCBpc0Z1bGx5VmlzaWJsZSkgPT4ge1xuICAgICAgICBpZiAoISFzbGlkZUlPRW50cmllcy5nZXQoaWQpID09PSBpc0Z1bGx5VmlzaWJsZSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldFNsaWRlSU9FbnRyaWVzKChwcmV2KSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3TWFwID0gbmV3IE1hcChwcmV2KTtcbiAgICAgICAgICBuZXdNYXAuc2V0KGlkLCBpc0Z1bGx5VmlzaWJsZSk7XG4gICAgICAgICAgcmV0dXJuIG5ld01hcDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgW3NsaWRlSU9FbnRyaWVzXVxuICAgICk7XG4gICAgY29uc3QgcHJldkRyYWdnZWQgPSB1c2VSZWY2KGZhbHNlKTtcbiAgICB1c2VFZmZlY3Q2KCgpID0+IHtcbiAgICAgIGlmIChpc0RyYWdnaW5nKVxuICAgICAgICBwcmV2RHJhZ2dlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGlmICghKGlzRHJhZ2dpbmcgfHwgaXNBbmltYXRpbmcpKSB7XG4gICAgICAgIGlmICghcHJldkRyYWdnZWQuY3VycmVudClcbiAgICAgICAgICBzZXRDb25zdGFudFZpc2libGVDb3VudCh2aXNpYmxlQ291bnQpO1xuICAgICAgICBwcmV2RHJhZ2dlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSwgW2lzQW5pbWF0aW5nLCBpc0RyYWdnaW5nLCB2aXNpYmxlQ291bnRdKTtcbiAgICBjb25zdCBwcmV2WFBvc2l0aW9uID0gdXNlUmVmNihudWxsKTtcbiAgICBjb25zdCBwcmVEcmFnT2Zmc2V0ID0gdXNlUmVmNigwKTtcbiAgICBjb25zdCBzbGlkZXJMaXN0UmVmID0gdXNlUmVmNihudWxsKTtcbiAgICBjb25zdCBkZWZhdWx0Q2Fyb3VzZWxSZWYgPSB1c2VSZWY2KG51bGwpO1xuICAgIGNvbnN0IGF1dG9wbGF5VGltZW91dCA9IHVzZVJlZjYoKTtcbiAgICBjb25zdCBhdXRvcGxheUxhc3RUcmlnZ2VyZWRSZWYgPSB1c2VSZWY2KG51bGwpO1xuICAgIGNvbnN0IGlzTW91bnRlZCA9IHVzZVJlZjYodHJ1ZSk7XG4gICAgY29uc3Qgc2V0U2xpZGVyTGlzdFJlZiA9IHVzZUNhbGxiYWNrNCgobm9kZSkgPT4ge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiLnNsaWRlci1saXN0IGltZ1wiKS5mb3JFYWNoKChlbCkgPT4gZWwuc2V0QXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIsIFwiZmFsc2VcIikpO1xuICAgICAgfVxuICAgICAgc2xpZGVyTGlzdFJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0NigoKSA9PiB7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZm9yd2FyZGVkUmVmID0gdXNlRm9yd2FyZFJlZihyZWYpO1xuICAgIGNvbnN0IGNhcm91c2VsUmVmID0gZm9yd2FyZGVkUmVmIHx8IGRlZmF1bHRDYXJvdXNlbFJlZjtcbiAgICBjb25zdCBnb1RvU2xpZGUgPSB1c2VDYWxsYmFjazQoXG4gICAgICAodGFyZ2V0U2xpZGVVbmJvdW5kZWQpID0+IHtcbiAgICAgICAgaWYgKCFzbGlkZXJMaXN0UmVmLmN1cnJlbnQgfHwgIWNhcm91c2VsUmVmLmN1cnJlbnQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB0YXJnZXRTbGlkZUJvdW5kZWQgPSBnZXRCb3VuZGVkSW5kZXgoXG4gICAgICAgICAgdGFyZ2V0U2xpZGVVbmJvdW5kZWQsXG4gICAgICAgICAgc2xpZGVDb3VudFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBzbGlkZUNoYW5nZWQgPSB0YXJnZXRTbGlkZVVuYm91bmRlZCAhPT0gY3VycmVudFNsaWRlO1xuICAgICAgICBzbGlkZUNoYW5nZWQgJiYgYmVmb3JlU2xpZGUoY3VycmVudFNsaWRlLCB0YXJnZXRTbGlkZUJvdW5kZWQpO1xuICAgICAgICBjb25zdCBjdXJyZW50T2Zmc2V0ID0gc2xpZGVyTGlzdFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBjYXJvdXNlbFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGNvbnN0IHNsaWRlcldpZHRoID0gc2xpZGVyTGlzdFJlZi5jdXJyZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBsZXQgdGFyZ2V0T2Zmc2V0ID0gZ2V0UGVyY2VudE9mZnNldEZvclNsaWRlKFxuICAgICAgICAgIHRhcmdldFNsaWRlQm91bmRlZCxcbiAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgICAgICBjZWxsQWxpZ24sXG4gICAgICAgICAgd3JhcEFyb3VuZFxuICAgICAgICApIC8gMTAwICogc2xpZGVyV2lkdGg7XG4gICAgICAgIGlmICh3cmFwQXJvdW5kKSB7XG4gICAgICAgICAgY29uc3Qgc2xpZGVTZXRXaWR0aCA9IHNsaWRlcldpZHRoIC8gMztcbiAgICAgICAgICBpZiAodGFyZ2V0U2xpZGVVbmJvdW5kZWQgPCAwKSB7XG4gICAgICAgICAgICB0YXJnZXRPZmZzZXQgKz0gc2xpZGVTZXRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRhcmdldFNsaWRlVW5ib3VuZGVkID49IHNsaWRlQ291bnQpIHtcbiAgICAgICAgICAgIHRhcmdldE9mZnNldCAtPSBzbGlkZVNldFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRBbmltYXRpb25EaXN0YW5jZSh0YXJnZXRPZmZzZXQgLSBjdXJyZW50T2Zmc2V0KTtcbiAgICAgICAgaWYgKHNsaWRlQ2hhbmdlZCkge1xuICAgICAgICAgIHNldEN1cnJlbnRTbGlkZSh0YXJnZXRTbGlkZUJvdW5kZWQpO1xuICAgICAgICAgIGNvbnN0IG1zVG9FbmRPZkFuaW1hdGlvbiA9ICFkaXNhYmxlQW5pbWF0aW9uID8gc3BlZWQgfHwgNTAwIDogNDA7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzTW91bnRlZC5jdXJyZW50KVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhZnRlclNsaWRlKHRhcmdldFNsaWRlQm91bmRlZCk7XG4gICAgICAgICAgfSwgbXNUb0VuZE9mQW5pbWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgYWZ0ZXJTbGlkZSxcbiAgICAgICAgYmVmb3JlU2xpZGUsXG4gICAgICAgIGNhcm91c2VsUmVmLFxuICAgICAgICBjZWxsQWxpZ24sXG4gICAgICAgIGN1cnJlbnRTbGlkZSxcbiAgICAgICAgZGlzYWJsZUFuaW1hdGlvbixcbiAgICAgICAgc3BlZWQsXG4gICAgICAgIHNsaWRlQ291bnQsXG4gICAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgICAgd3JhcEFyb3VuZFxuICAgICAgXVxuICAgICk7XG4gICAgY29uc3QgbmV4dFNsaWRlID0gdXNlQ2FsbGJhY2s0KCgpID0+IHtcbiAgICAgIGNvbnN0IG5leHRTbGlkZUluZGV4ID0gZ2V0TmV4dE1vdmVJbmRleChcbiAgICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgICAgd3JhcEFyb3VuZCxcbiAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgc2xpZGVzVG9TaG93LFxuICAgICAgICBjZWxsQWxpZ25cbiAgICAgICk7XG4gICAgICBpZiAoY3VycmVudFNsaWRlICE9PSBuZXh0U2xpZGVJbmRleCkge1xuICAgICAgICBnb1RvU2xpZGUobmV4dFNsaWRlSW5kZXgpO1xuICAgICAgfVxuICAgIH0sIFtcbiAgICAgIGNlbGxBbGlnbixcbiAgICAgIGN1cnJlbnRTbGlkZSxcbiAgICAgIGdvVG9TbGlkZSxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgIHNsaWRlQ291bnQsXG4gICAgICBzbGlkZXNUb1Nob3csXG4gICAgICB3cmFwQXJvdW5kXG4gICAgXSk7XG4gICAgY29uc3QgcHJldlNsaWRlID0gdXNlQ2FsbGJhY2s0KCgpID0+IHtcbiAgICAgIGNvbnN0IHByZXZTbGlkZUluZGV4ID0gZ2V0UHJldk1vdmVJbmRleChcbiAgICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgICAgd3JhcEFyb3VuZCxcbiAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgc2xpZGVzVG9TaG93LFxuICAgICAgICBjZWxsQWxpZ25cbiAgICAgICk7XG4gICAgICBpZiAoY3VycmVudFNsaWRlICE9PSBwcmV2U2xpZGVJbmRleCkge1xuICAgICAgICBnb1RvU2xpZGUocHJldlNsaWRlSW5kZXgpO1xuICAgICAgfVxuICAgIH0sIFtcbiAgICAgIGNlbGxBbGlnbixcbiAgICAgIGN1cnJlbnRTbGlkZSxcbiAgICAgIGdvVG9TbGlkZSxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgIHdyYXBBcm91bmRcbiAgICBdKTtcbiAgICBjb25zdCBwcmV2TW92ZWRUb1NsaWRlSW5kZXggPSB1c2VSZWY2KHNsaWRlSW5kZXgpO1xuICAgIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgICAgaWYgKHNsaWRlSW5kZXggIT09IHZvaWQgMCAmJiBzbGlkZUluZGV4ICE9PSBwcmV2TW92ZWRUb1NsaWRlSW5kZXguY3VycmVudCAmJiAhYXV0b3BsYXlSZXZlcnNlKSB7XG4gICAgICAgIGdvVG9TbGlkZShzbGlkZUluZGV4KTtcbiAgICAgICAgcHJldk1vdmVkVG9TbGlkZUluZGV4LmN1cnJlbnQgPSBzbGlkZUluZGV4O1xuICAgICAgfVxuICAgIH0sIFtzbGlkZUluZGV4LCBhdXRvcGxheVJldmVyc2UsIGdvVG9TbGlkZV0pO1xuICAgIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgICAgbGV0IHBhdXNlU3RhcnRlZCA9IG51bGw7XG4gICAgICBpZiAocGF1c2UpIHtcbiAgICAgICAgcGF1c2VTdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChwYXVzZVN0YXJ0ZWQgIT09IG51bGwgJiYgYXV0b3BsYXlMYXN0VHJpZ2dlcmVkUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBhdXRvcGxheUxhc3RUcmlnZ2VyZWRSZWYuY3VycmVudCArPSBEYXRlLm5vdygpIC0gcGF1c2VTdGFydGVkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIFtwYXVzZV0pO1xuICAgIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgICAgaWYgKGF1dG9wbGF5ICYmICFwYXVzZSkge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFRpbWVvdXRNcyA9IGF1dG9wbGF5TGFzdFRyaWdnZXJlZFJlZi5jdXJyZW50ICE9PSBudWxsID8gYXV0b3BsYXlJbnRlcnZhbCAtIChEYXRlLm5vdygpIC0gYXV0b3BsYXlMYXN0VHJpZ2dlcmVkUmVmLmN1cnJlbnQpIDogYXV0b3BsYXlJbnRlcnZhbDtcbiAgICAgICAgYXV0b3BsYXlUaW1lb3V0LmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBhdXRvcGxheUxhc3RUcmlnZ2VyZWRSZWYuY3VycmVudCA9IERhdGUubm93KCk7XG4gICAgICAgICAgaWYgKGF1dG9wbGF5UmV2ZXJzZSkge1xuICAgICAgICAgICAgcHJldlNsaWRlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRTbGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgYWRqdXN0ZWRUaW1lb3V0TXMpO1xuICAgICAgfVxuICAgICAgaWYgKGF1dG9wbGF5ICYmIHBhdXNlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhdXRvcGxheVRpbWVvdXQuY3VycmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoYXV0b3BsYXlUaW1lb3V0LmN1cnJlbnQpO1xuICAgICAgfTtcbiAgICB9LCBbXG4gICAgICBwYXVzZSxcbiAgICAgIGF1dG9wbGF5LFxuICAgICAgYXV0b3BsYXlJbnRlcnZhbCxcbiAgICAgIGF1dG9wbGF5UmV2ZXJzZSxcbiAgICAgIHByZXZTbGlkZSxcbiAgICAgIG5leHRTbGlkZVxuICAgIF0pO1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgbGV0IGtleUNvbW1hbmQgPSBudWxsO1xuICAgICAgT2JqZWN0LmtleXMoa2V5Q29kZUNvbmZpZykuZm9yRWFjaChcbiAgICAgICAgKGNvbW1hbmQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgaWYgKChfYSA9IGtleUNvZGVDb25maWdbY29tbWFuZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhldmVudC5rZXlDb2RlKSkge1xuICAgICAgICAgICAga2V5Q29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKGtleUNvbW1hbmQgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHN3aXRjaCAoa2V5Q29tbWFuZCkge1xuICAgICAgICBjYXNlIFwibmV4dFNsaWRlXCI6XG4gICAgICAgICAgb25Vc2VyTmF2aWdhdGlvbihldmVudCk7XG4gICAgICAgICAgbmV4dFNsaWRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwcmV2aW91c1NsaWRlXCI6XG4gICAgICAgICAgb25Vc2VyTmF2aWdhdGlvbihldmVudCk7XG4gICAgICAgICAgcHJldlNsaWRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmaXJzdFNsaWRlXCI6XG4gICAgICAgIGNhc2UgXCJsYXN0U2xpZGVcIjoge1xuICAgICAgICAgIG9uVXNlck5hdmlnYXRpb24oZXZlbnQpO1xuICAgICAgICAgIGNvbnN0IGRvdEluZGljZXMgPSBnZXREb3RJbmRleGVzKFxuICAgICAgICAgICAgc2xpZGVDb3VudCxcbiAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgICAgICAgc2Nyb2xsTW9kZSxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgICAgICAgIHdyYXBBcm91bmQsXG4gICAgICAgICAgICBjZWxsQWxpZ25cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChrZXlDb21tYW5kID09PSBcImZpcnN0U2xpZGVcIikge1xuICAgICAgICAgICAgZ29Ub1NsaWRlKGRvdEluZGljZXNbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnb1RvU2xpZGUoZG90SW5kaWNlc1tkb3RJbmRpY2VzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBhdXNlXCI6XG4gICAgICAgICAgc2V0UGF1c2UoKHApID0+ICFwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRyYWdQb3NpdGlvbnMgPSB1c2VSZWY2KFtdKTtcbiAgICBjb25zdCBoYW5kbGVEcmFnRW5kID0gKGUpID0+IHtcbiAgICAgIGlmICghaXNEcmFnZ2luZyB8fCAhY2Fyb3VzZWxSZWYuY3VycmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgc2V0SXNEcmFnZ2luZyhmYWxzZSk7XG4gICAgICBsZXQgZGlzdGFuY2VGcm9tSW5lcnRpYSA9IDA7XG4gICAgICBpZiAoZHJhZ1Bvc2l0aW9ucy5jdXJyZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRNb3ZlID0gZHJhZ1Bvc2l0aW9ucy5jdXJyZW50WzBdO1xuICAgICAgICBjb25zdCBlbmRNb3ZlID0gZHJhZ1Bvc2l0aW9ucy5jdXJyZW50W2RyYWdQb3NpdGlvbnMuY3VycmVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgdGltZU9mZnNldCA9IGVuZE1vdmUudGltZSAtIHN0YXJ0TW92ZS50aW1lO1xuICAgICAgICBjb25zdCBnb29kSW5lcnRpYUZlZWxDb25zdGFudCA9IDk7XG4gICAgICAgIGNvbnN0IGdvb2RGcmljdGlvbkZlZWxDb25zdGFudCA9IDAuOTI7XG4gICAgICAgIGNvbnN0IGluaXRpYWxWZWxvY2l0eSA9IGdvb2RJbmVydGlhRmVlbENvbnN0YW50ICogTWF0aC5hYnMoKGVuZE1vdmUucG9zIC0gc3RhcnRNb3ZlLnBvcykgLyB0aW1lT2Zmc2V0KTtcbiAgICAgICAgbGV0IHZlbG9jaXR5ID0gaW5pdGlhbFZlbG9jaXR5O1xuICAgICAgICB3aGlsZSAoTWF0aC5hYnModmVsb2NpdHkpID4gMSkge1xuICAgICAgICAgIGRpc3RhbmNlRnJvbUluZXJ0aWEgKz0gdmVsb2NpdHk7XG4gICAgICAgICAgdmVsb2NpdHkgKj0gZ29vZEZyaWN0aW9uRmVlbENvbnN0YW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkcmFnUG9zaXRpb25zLmN1cnJlbnQgPSBbXTtcbiAgICAgIGNvbnN0IGFkanVzdGVkRHJhZ0Rpc3RhbmNlID0gTWF0aC5hYnMoZHJhZ0Rpc3RhbmNlKSArIE1hdGguYWJzKGRpc3RhbmNlRnJvbUluZXJ0aWEpO1xuICAgICAgb25EcmFnRW5kKGUpO1xuICAgICAgcHJldlhQb3NpdGlvbi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHNldERyYWdEaXN0YW5jZSgwKTtcbiAgICAgIGNvbnN0IG9uZVNjcm9sbFdpZHRoID0gY2Fyb3VzZWxSZWYuY3VycmVudC5vZmZzZXRXaWR0aCAqIE1hdGgubWluKDEsIHNsaWRlc1RvU2Nyb2xsIC8gc2xpZGVzVG9TaG93KTtcbiAgICAgIGNvbnN0IGRyYWdUaHJlc2hvbGQgPSBvbmVTY3JvbGxXaWR0aCAqIHByb3BzRHJhZ1RocmVzaG9sZDtcbiAgICAgIGlmIChhZGp1c3RlZERyYWdEaXN0YW5jZSA8IGRyYWdUaHJlc2hvbGQpIHtcbiAgICAgICAgZ29Ub1NsaWRlKGN1cnJlbnRTbGlkZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbk1haW50YWluVmlzdWFsQ29udGludWl0eSA9IHNsaWRlc1RvU2hvdyA+PSAyICogc2xpZGVzVG9TY3JvbGw7XG4gICAgICBjb25zdCB0aW1lc1RvTW92ZSA9IGNhbk1haW50YWluVmlzdWFsQ29udGludWl0eSA/IDEgKyBNYXRoLmZsb29yKChhZGp1c3RlZERyYWdEaXN0YW5jZSAtIGRyYWdUaHJlc2hvbGQpIC8gb25lU2Nyb2xsV2lkdGgpIDogMTtcbiAgICAgIGxldCBuZXh0U2xpZGVJbmRleCA9IGN1cnJlbnRTbGlkZTtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aW1lc1RvTW92ZTsgaW5kZXggKz0gMSkge1xuICAgICAgICBpZiAoZHJhZ0Rpc3RhbmNlID4gMCkge1xuICAgICAgICAgIG5leHRTbGlkZUluZGV4ID0gZ2V0TmV4dE1vdmVJbmRleChcbiAgICAgICAgICAgIHNjcm9sbE1vZGUsXG4gICAgICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICAgICAgbmV4dFNsaWRlSW5kZXgsXG4gICAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGwsXG4gICAgICAgICAgICBzbGlkZXNUb1Nob3csXG4gICAgICAgICAgICBjZWxsQWxpZ25cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRTbGlkZUluZGV4ID0gZ2V0UHJldk1vdmVJbmRleChcbiAgICAgICAgICAgIHNjcm9sbE1vZGUsXG4gICAgICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICAgICAgbmV4dFNsaWRlSW5kZXgsXG4gICAgICAgICAgICBzbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgICAgIHNsaWRlc1RvU2hvdyxcbiAgICAgICAgICAgIGNlbGxBbGlnblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXh0U2xpZGVJbmRleCAhPT0gY3VycmVudFNsaWRlKSB7XG4gICAgICAgIG9uVXNlck5hdmlnYXRpb24oZSk7XG4gICAgICB9XG4gICAgICBnb1RvU2xpZGUobmV4dFNsaWRlSW5kZXgpO1xuICAgIH07XG4gICAgY29uc3Qgb25Ub3VjaFN0YXJ0ID0gdXNlQ2FsbGJhY2s0KFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgaWYgKCFtb2JpbGVEcmFnZ2luZ0VuYWJsZWQgfHwgIXNsaWRlckxpc3RSZWYuY3VycmVudCB8fCAhY2Fyb3VzZWxSZWYuY3VycmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRJc0RyYWdnaW5nKHRydWUpO1xuICAgICAgICBwcmVEcmFnT2Zmc2V0LmN1cnJlbnQgPSBzbGlkZXJMaXN0UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIGNhcm91c2VsUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgb25EcmFnU3RhcnQoZSk7XG4gICAgICB9LFxuICAgICAgW2Nhcm91c2VsUmVmLCBvbkRyYWdTdGFydCwgbW9iaWxlRHJhZ2dpbmdFbmFibGVkXVxuICAgICk7XG4gICAgY29uc3QgaGFuZGxlUG9pbnRlck1vdmUgPSB1c2VDYWxsYmFjazQoXG4gICAgICAoeFBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGlmICghaXNEcmFnZ2luZylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGlzRmlyc3RNb3ZlID0gcHJldlhQb3NpdGlvbi5jdXJyZW50ID09PSBudWxsO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHByZXZYUG9zaXRpb24uY3VycmVudCAhPT0gbnVsbCA/IHhQb3NpdGlvbiAtIHByZXZYUG9zaXRpb24uY3VycmVudCA6IDA7XG4gICAgICAgIGNvbnN0IG5leHREcmFnRGlzdGFuY2UgPSBkcmFnRGlzdGFuY2UgKyBkZWx0YTtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKGRyYWdQb3NpdGlvbnMuY3VycmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKG5vdyAtIGRyYWdQb3NpdGlvbnMuY3VycmVudFswXS50aW1lIDw9IDEwMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRyYWdQb3NpdGlvbnMuY3VycmVudC5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGRyYWdQb3NpdGlvbnMuY3VycmVudC5wdXNoKHsgcG9zOiBuZXh0RHJhZ0Rpc3RhbmNlLCB0aW1lOiBub3cgfSk7XG4gICAgICAgIGlmICghaXNGaXJzdE1vdmUpIHtcbiAgICAgICAgICBzZXREcmFnRGlzdGFuY2UobmV4dERyYWdEaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlhQb3NpdGlvbi5jdXJyZW50ID0geFBvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIFtpc0RyYWdnaW5nLCBkcmFnRGlzdGFuY2VdXG4gICAgKTtcbiAgICBjb25zdCBvblRvdWNoTW92ZSA9IHVzZUNhbGxiYWNrNChcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGlmICghaXNEcmFnZ2luZyB8fCAhY2Fyb3VzZWxSZWYuY3VycmVudClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIG9uRHJhZ1N0YXJ0KGUpO1xuICAgICAgICBjb25zdCBtb3ZlVmFsdWUgPSBjYXJvdXNlbFJlZi5jdXJyZW50Lm9mZnNldFdpZHRoIC0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICBoYW5kbGVQb2ludGVyTW92ZShtb3ZlVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIFtpc0RyYWdnaW5nLCBjYXJvdXNlbFJlZiwgaGFuZGxlUG9pbnRlck1vdmUsIG9uRHJhZ1N0YXJ0XVxuICAgICk7XG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSB1c2VDYWxsYmFjazQoXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBpZiAoIWRlc2t0b3BEcmFnZ2luZ0VuYWJsZWQgfHwgIXNsaWRlckxpc3RSZWYuY3VycmVudCB8fCAhY2Fyb3VzZWxSZWYuY3VycmVudClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldElzRHJhZ2dpbmcodHJ1ZSk7XG4gICAgICAgIHByZURyYWdPZmZzZXQuY3VycmVudCA9IHNsaWRlckxpc3RSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gY2Fyb3VzZWxSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICBvbkRyYWdTdGFydChlKTtcbiAgICAgIH0sXG4gICAgICBbY2Fyb3VzZWxSZWYsIGRlc2t0b3BEcmFnZ2luZ0VuYWJsZWQsIG9uRHJhZ1N0YXJ0XVxuICAgICk7XG4gICAgY29uc3Qgb25Nb3VzZU1vdmUgPSB1c2VDYWxsYmFjazQoXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBpZiAoIWlzRHJhZ2dpbmcgfHwgIWNhcm91c2VsUmVmLmN1cnJlbnQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvbkRyYWcoZSk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBlLmNsaWVudFggLSBjYXJvdXNlbFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGNvbnN0IG1vdmVWYWx1ZSA9IGNhcm91c2VsUmVmLmN1cnJlbnQub2Zmc2V0V2lkdGggLSBvZmZzZXRYO1xuICAgICAgICBoYW5kbGVQb2ludGVyTW92ZShtb3ZlVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIFtjYXJvdXNlbFJlZiwgaXNEcmFnZ2luZywgaGFuZGxlUG9pbnRlck1vdmUsIG9uRHJhZ11cbiAgICApO1xuICAgIGNvbnN0IG9uTW91c2VVcCA9IChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBoYW5kbGVEcmFnRW5kKGUpO1xuICAgIH07XG4gICAgY29uc3Qgb25Nb3VzZUVudGVyID0gdXNlQ2FsbGJhY2s0KCgpID0+IHtcbiAgICAgIGlmIChwYXVzZU9uSG92ZXIpIHtcbiAgICAgICAgc2V0UGF1c2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfSwgW3BhdXNlT25Ib3Zlcl0pO1xuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9IHVzZUNhbGxiYWNrNCgoKSA9PiB7XG4gICAgICBpZiAocGF1c2VPbkhvdmVyKSB7XG4gICAgICAgIHNldFBhdXNlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LCBbcGF1c2VPbkhvdmVyXSk7XG4gICAgY29uc3Qge1xuICAgICAgZnJhbWVIZWlnaHQsXG4gICAgICBoYW5kbGVWaXNpYmxlU2xpZGVIZWlnaHRDaGFuZ2UsXG4gICAgICBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0XG4gICAgfSA9IHVzZUZyYW1lSGVpZ2h0KGFkYXB0aXZlSGVpZ2h0LCBzbGlkZXNUb1Nob3csIHNsaWRlQ291bnQpO1xuICAgIGNvbnN0IHJlbmRlclNsaWRlcyA9ICh0eXBlT2ZTbGlkZSkgPT4ge1xuICAgICAgY29uc3Qgc2xpZGVzID0gZmlsdGVyZWRTbGlkZXMubWFwKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFxuICAgICAgICAgIHNsaWRlX2RlZmF1bHQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IGAke3R5cGVPZlNsaWRlfS0ke2luZGV4fWAsXG4gICAgICAgICAgICBjYXJvdXNlbElkLFxuICAgICAgICAgICAgY291bnQ6IHNsaWRlQ291bnQsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGlzQ3VycmVudFNsaWRlOiBjdXJyZW50U2xpZGUgPT09IGluZGV4LFxuICAgICAgICAgICAgdHlwZU9mU2xpZGUsXG4gICAgICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICAgICAgY2VsbFNwYWNpbmcsXG4gICAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAgICBzcGVlZCxcbiAgICAgICAgICAgIHpvb21TY2FsZSxcbiAgICAgICAgICAgIG9uVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlOiBoYW5kbGVWaXNpYmxlU2xpZGVIZWlnaHRDaGFuZ2UsXG4gICAgICAgICAgICBzbGlkZVdpZHRoLFxuICAgICAgICAgICAgdXBkYXRlSU9FbnRyeTogdXBkYXRlU2xpZGVJT0VudHJ5LFxuICAgICAgICAgICAgYWRhcHRpdmVIZWlnaHQsXG4gICAgICAgICAgICBpbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0LFxuICAgICAgICAgICAgY2Fyb3VzZWxSZWYsXG4gICAgICAgICAgICB0YWJiZWQsXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGAke3R5cGVPZlNsaWRlfS0ke2luZGV4fWBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNsaWRlcztcbiAgICB9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJzbGlkZXItY29udGFpbmVyXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRW50ZXIsXG4gICAgICAgIG9uTW91c2VMZWF2ZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGZyYW1lQXJpYUxhYmVsLFxuICAgICAgICByb2xlOiBsYW5kbWFyayA/IFwicmVnaW9uXCIgOiBcImdyb3VwXCIsXG4gICAgICAgIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJjYXJvdXNlbFwiLFxuICAgICAgICBpZDogY2Fyb3VzZWxJZCxcbiAgICAgICAgXCJkYXRhLXRlc3RpZFwiOiBjYXJvdXNlbElkLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFxuICAgICAgICAgICAgYW5ub3VuY2Vfc2xpZGVfZGVmYXVsdCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYXJpYUxpdmU6IGF1dG9wbGF5ICYmICFwYXVzZSA/IFwib2ZmXCIgOiBcInBvbGl0ZVwiLFxuICAgICAgICAgICAgICBtZXNzYWdlOiByZW5kZXJBbm5vdW5jZVNsaWRlTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICAgICAgICAgIGNvdW50OiBzbGlkZUNvdW50XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBjb250cm9sc19kZWZhdWx0KFxuICAgICAgICAgICAgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpLCB7IGNhcm91c2VsSWQgfSksXG4gICAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICAgICAgZ29Ub1NsaWRlLFxuICAgICAgICAgICAgbmV4dFNsaWRlLFxuICAgICAgICAgICAgcHJldlNsaWRlLFxuICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGxcbiAgICAgICAgICApLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBbXCJzbGlkZXItZnJhbWVcIiwgY2xhc3NOYW1lIHx8IFwiXCJdLmpvaW4oXCIgXCIpLnRyaW0oKSxcbiAgICAgICAgICAgICAgc3R5bGU6IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICB0b3VjaEFjdGlvbjogXCJwYW4teVwiLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZnJhbWVIZWlnaHQsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYWRhcHRpdmVIZWlnaHRBbmltYXRpb24gPyBcImhlaWdodCAzMDBtcyBlYXNlLWluLW91dFwiIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIHdpbGxDaGFuZ2U6IFwiaGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgdXNlclNlbGVjdDogXCJub25lXCJcbiAgICAgICAgICAgICAgfSwgc3R5bGUpLFxuICAgICAgICAgICAgICB0YWJJbmRleDogZW5hYmxlS2V5Ym9hcmRDb250cm9scyA/IDAgOiAtMSxcbiAgICAgICAgICAgICAgb25LZXlEb3duOiBlbmFibGVLZXlib2FyZENvbnRyb2xzID8gb25LZXlEb3duIDogdm9pZCAwLFxuICAgICAgICAgICAgICByZWY6IGNhcm91c2VsUmVmLFxuICAgICAgICAgICAgICBvbk1vdXNlVXAsXG4gICAgICAgICAgICAgIG9uTW91c2VEb3duLFxuICAgICAgICAgICAgICBvbk1vdXNlTW92ZSxcbiAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlVXAsXG4gICAgICAgICAgICAgIG9uVG91Y2hTdGFydCxcbiAgICAgICAgICAgICAgb25Ub3VjaEVuZDogaGFuZGxlRHJhZ0VuZCxcbiAgICAgICAgICAgICAgb25Ub3VjaE1vdmUsXG4gICAgICAgICAgICAgIGlkOiBgJHtjYXJvdXNlbElkfS1zbGlkZXItZnJhbWVgLFxuICAgICAgICAgICAgICBcImRhdGEtdGVzdGlkXCI6IGAke2Nhcm91c2VsSWR9LXNsaWRlci1mcmFtZWAsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgICAgICAgICAgICBTbGlkZXJMaXN0LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgY2VsbEFsaWduLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFNsaWRlLFxuICAgICAgICAgICAgICAgICAgZGlzYWJsZUVkZ2VTd2lwaW5nOiBwcm9wcy5kaXNhYmxlRWRnZVN3aXBpbmcsXG4gICAgICAgICAgICAgICAgICBkcmFnZ2VkT2Zmc2V0OiBwcmVEcmFnT2Zmc2V0LmN1cnJlbnQgLSBkcmFnRGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlQW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgZWFzaW5nOiBwcm9wcy5lYXNpbmcsXG4gICAgICAgICAgICAgICAgICBlZGdlRWFzaW5nOiBwcm9wcy5lZGdlRWFzaW5nLFxuICAgICAgICAgICAgICAgICAgaXNEcmFnZ2luZyxcbiAgICAgICAgICAgICAgICAgIHJlZjogc2V0U2xpZGVyTGlzdFJlZixcbiAgICAgICAgICAgICAgICAgIHNjcm9sbE1vZGUsXG4gICAgICAgICAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGwsXG4gICAgICAgICAgICAgICAgICBzbGlkZXNUb1Nob3csXG4gICAgICAgICAgICAgICAgICBzcGVlZCxcbiAgICAgICAgICAgICAgICAgIHNsaWRlV2lkdGgsXG4gICAgICAgICAgICAgICAgICB3cmFwQXJvdW5kLFxuICAgICAgICAgICAgICAgICAgc2V0SXNBbmltYXRpbmcsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICB3cmFwQXJvdW5kID8gcmVuZGVyU2xpZGVzKFwicHJldi1jbG9uZWRcIikgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJTbGlkZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgd3JhcEFyb3VuZCA/IHJlbmRlclNsaWRlcyhcIm5leHQtY2xvbmVkXCIpIDogbnVsbFxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5DYXJvdXNlbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0X2Nhcm91c2VsX3Byb3BzX2RlZmF1bHQ7XG5DYXJvdXNlbC5kaXNwbGF5TmFtZSA9IFwiQ2Fyb3VzZWxcIjtcbmV4cG9ydCB7XG4gIEFsaWdubWVudCxcbiAgRGlyZWN0aW9ucyxcbiAgTmV4dEJ1dHRvbixcbiAgUGFnaW5nRG90cyxcbiAgUG9zaXRpb25zLFxuICBQcmV2aW91c0J1dHRvbixcbiAgU2Nyb2xsTW9kZSxcbiAgQ2Fyb3VzZWwgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZlByb3BzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fZ2V0T3duUHJvcERlc2NzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fZ2V0T3duUHJvcFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fcHJvcElzRW51bSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19wb3ciLCJNYXRoIiwicG93IiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3NwcmVhZFZhbHVlcyIsImEiLCJiIiwicHJvcCIsImNhbGwiLCJfX3NwcmVhZFByb3BzIiwiUmVhY3Q1IiwidXNlRWZmZWN0IiwidXNlRWZmZWN0NiIsInVzZVN0YXRlIiwidXNlU3RhdGU1IiwidXNlUmVmIiwidXNlUmVmNiIsInVzZUNhbGxiYWNrIiwidXNlQ2FsbGJhY2s0IiwidXNlSWQiLCJ1c2VSZWYyIiwidXNlRWZmZWN0MiIsInVzZVNsaWRlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbGVtZW50UmVmIiwicm9vdFJlZiIsImNhbGxiYWNrIiwiZW50cnkiLCJzZXRFbnRyeSIsImNhbGxiYWNrUmVmIiwiY3VycmVudCIsIm5vZGUiLCJyb290Iiwid2luZG93IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlciIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkyIiwidGhyZXNob2xkIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJqc3giLCJnZXRTbGlkZVdpZHRoIiwiY291bnQiLCJ3cmFwQXJvdW5kIiwiZ2V0U2xpZGVTdHlsZXMiLCJpc0N1cnJlbnRTbGlkZSIsImlzVmlzaWJsZVNsaWRlIiwiY2VsbFNwYWNpbmciLCJhbmltYXRpb24iLCJzcGVlZCIsInpvb21TY2FsZSIsImFkYXB0aXZlSGVpZ2h0IiwiaW5pdGlhbGl6ZWRBZGFwdGl2ZUhlaWdodCIsInNsaWRlV2lkdGgiLCJ3aWR0aCIsInZpc2libGVTbGlkZU9wYWNpdHkiLCJhbmltYXRpb25TcGVlZCIsImhlaWdodCIsInBhZGRpbmciLCJ0cmFuc2l0aW9uIiwidHJhbnNmb3JtIiwib3BhY2l0eSIsImdlbmVyYXRlSW5kZXgiLCJpbmRleCIsInR5cGVPZlNsaWRlIiwiU2xpZGUiLCJjaGlsZHJlbiIsIm9uVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlIiwidXBkYXRlSU9FbnRyeSIsImlkIiwiY2Fyb3VzZWxSZWYiLCJjYXJvdXNlbElkIiwidGFiYmVkIiwiX2EiLCJjdXN0b21JbmRleCIsInNsaWRlUmVmIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJpc1Zpc2libGUiLCJpc0ludGVyc2VjdGluZyIsImlzRnVsbHlWaXNpYmxlIiwicHJldklzVmlzaWJsZVJlZiIsIl9hMiIsInNsaWRlSGVpZ2h0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicHJldklzVmlzaWJsZSIsImN1cnJlbnRTbGlkZUNsYXNzIiwicmVmIiwiaW5lcnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsInJvbGUiLCJzbGlkZV9kZWZhdWx0IiwianN4MiIsInN0eWxlcyIsInBvc2l0aW9uIiwib3ZlcmZsb3ciLCJtYXJnaW4iLCJjbGlwIiwid2hpdGVTcGFjZSIsImJvcmRlciIsIkFubm91bmNlU2xpZGUiLCJtZXNzYWdlIiwiYXJpYUxpdmUiLCJ0YWJJbmRleCIsImRlZmF1bHRSZW5kZXJBbm5vdW5jZVNsaWRlTWVzc2FnZSIsImN1cnJlbnRTbGlkZSIsImFubm91bmNlX3NsaWRlX2RlZmF1bHQiLCJSZWFjdDMiLCJ1c2VFZmZlY3Q0IiwiQWxpZ25tZW50IiwiQWxpZ25tZW50MiIsIkRpcmVjdGlvbnMiLCJEaXJlY3Rpb25zMiIsIlBvc2l0aW9ucyIsIlBvc2l0aW9uczIiLCJTY3JvbGxNb2RlIiwiU2Nyb2xsTW9kZTIiLCJnZXROZXh0TW92ZUluZGV4Iiwic2Nyb2xsTW9kZSIsInNsaWRlQ291bnQiLCJzbGlkZXNUb1Njcm9sbCIsInNsaWRlc1RvU2hvdyIsImNlbGxBbGlnbiIsIm1pbiIsImdldFByZXZNb3ZlSW5kZXgiLCJtYXgiLCJnZXREZWZhdWx0U2xpZGVJbmRleCIsInNsaWRlSW5kZXgiLCJhdXRvcGxheVJldmVyc2UiLCJkb3RJbmRleGVzIiwiZ2V0RG90SW5kZXhlcyIsImxlbmd0aCIsImdldEJvdW5kZWRJbmRleCIsInJhd0luZGV4IiwianN4MyIsImRlZmF1bHRCdXR0b25TdHlsZXMiLCJkaXNhYmxlZCIsImJhY2tncm91bmQiLCJjb2xvciIsInRleHRUcmFuc2Zvcm0iLCJjdXJzb3IiLCJwcmV2QnV0dG9uRGlzYWJsZWQiLCJQcmV2aW91c0J1dHRvbiIsInByZXZpb3VzU2xpZGUiLCJkZWZhdWx0Q29udHJvbHNDb25maWciLCJwcmV2QnV0dG9uQ2xhc3NOYW1lIiwicHJldkJ1dHRvblN0eWxlIiwicHJldkJ1dHRvblRleHQiLCJwcmV2QnV0dG9uT25DbGljayIsIm9uVXNlck5hdmlnYXRpb24iLCJwcmV2aW91c0Rpc2FibGVkIiwiaGFuZGxlQ2xpY2siLCJldmVudCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwcmV2ZW50RGVmYXVsdCIsIm9uQ2xpY2siLCJ0eXBlIiwibmV4dEJ1dHRvbkRpc2FibGVkIiwiTmV4dEJ1dHRvbiIsIm5leHRTbGlkZSIsIm5leHRCdXR0b25DbGFzc05hbWUiLCJuZXh0QnV0dG9uU3R5bGUiLCJuZXh0QnV0dG9uVGV4dCIsIm5leHRCdXR0b25PbkNsaWNrIiwibmV4dERpc2FibGVkIiwic2Nyb2xsU2xpZGVzIiwiaSIsInB1c2giLCJsYXN0UG9zc2libGVJbmRleFdpdGhvdXRXaGl0ZXNwYWNlIiwiZmlyc3RQb3NzaWJsZUluZGV4V2l0aG91dFdoaXRlc3BhY2UiLCJyZXZlcnNlIiwiUGFnaW5nRG90cyIsInBhZ2luZ0RvdHNJbmRpY2VzIiwicGFnaW5nRG90c0NvbnRhaW5lckNsYXNzTmFtZSIsInBhZ2luZ0RvdHNDbGFzc05hbWUiLCJwYWdpbmdEb3RzU3R5bGUiLCJwYWdpbmdEb3RzT25DbGljayIsImdvVG9TbGlkZSIsImxpc3RTdHlsZXMiLCJ0b3AiLCJkaXNwbGF5IiwibGlzdFN0eWxlVHlwZSIsImdldEJ1dHRvblN0eWxlcyIsImFjdGl2ZSIsImZpbGwiLCJjdXJyZW50U2xpZGVCb3VuZGVkIiwibWFwIiwiaXNBY3RpdmUiLCJqb2luIiwiZm9jdXNhYmxlIiwidmlld0JveCIsImN4IiwiY3kiLCJyIiwidXNlRWZmZWN0MyIsInVzZVN0YXRlMiIsInVzZVJlZjMiLCJ1c2VUd2VlbiIsImR1cmF0aW9uTXMiLCJlYXNpbmdGdW5jdGlvbiIsIm5hdmlnYXRpb25OdW0iLCJzaG91bGRJbnRlcnJ1cHQiLCJub3JtYWxpemVkVGltZVJhdyIsInNldE5vcm1hbGl6ZWRUaW1lIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJBRiIsImlzRmlyc3RSZW5kZXIiLCJsYXN0TmF2aWdhdGlvbk51bSIsIm5vcm1hbGl6ZWRUaW1lIiwidGljayIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImN1cnJlbnRUaW1lIiwibm9ybWFsaXplZFRpbWUyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpc0FuaW1hdGluZyIsImpzeDQiLCJnZXRQZXJjZW50T2Zmc2V0Rm9yU2xpZGUiLCJyZW5kZXJlZFNsaWRlQ291bnQiLCJzaW5nbGVTbGlkZVBlcmNlbnRPZldob2xlIiwic2xpZGUwT2Zmc2V0IiwiZXhjZXNzU2xpZGVzIiwiZXhjZXNzTGVmdFNsaWRlcyIsImN1cnJlbnRTbGlkZU9mZnNldEZyb20wIiwiU2xpZGVyTGlzdCIsImZvcndhcmRSZWYiLCJhbmltYXRpb25EaXN0YW5jZSIsImRpc2FibGVBbmltYXRpb24iLCJkaXNhYmxlRWRnZVN3aXBpbmciLCJkcmFnZ2VkT2Zmc2V0IiwiZWFzaW5nIiwiZWRnZUVhc2luZyIsImlzRHJhZ2dpbmciLCJzZXRJc0FuaW1hdGluZyIsImZvcndhcmRlZFJlZiIsImxpc3RWaXNpYmxlV2lkdGgiLCJwZXJjZW50T2Zmc2V0Rm9yU2xpZGVQcm9wcyIsImNsYW1wZWREcmFnZ2VkT2Zmc2V0IiwiY2xhbXBPZmZzZXRzIiwic2xpZGVCYXNlZE9mZnNldCIsImlzRWRnZUVhc2luZyIsInBvc2l0aW9uaW5nIiwidHJhbnNpdGlvbk9mZnNldCIsInRleHRBbGlnbiIsInVzZXJTZWxlY3QiLCJkaXNwbGF5TmFtZSIsIkZyYWdtZW50IiwiY29tbW9uU3R5bGVzIiwiekluZGV4IiwibGVmdCIsImJvdHRvbSIsInJpZ2h0IiwiZ2V0Q29udHJvbENvbnRhaW5lckZsZXhTdHlsZXMiLCJwb3MiLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJnZXRDb250cm9sQ29udGFpbmVyU3R5bGVzIiwianN4NSIsImNvbnRyb2xzTWFwIiwiZnVuY05hbWUiLCJyZW5kZXJDb250cm9scyIsInByb3BzIiwicHJldlNsaWRlIiwid2l0aG91dENvbnRyb2xzIiwiZGlzYWJsZUNoZWNrUHJvcHMiLCJjb250cm9sIiwicG9pbnRlckV2ZW50cyIsInRvTG93ZXJDYXNlIiwiY29udGFpbmVyQ2xhc3NOYW1lIiwidHJpbSIsInZlcnRpY2FsIiwiY29udHJvbHNfZGVmYXVsdCIsIkZyYWdtZW50MiIsImpzeDYiLCJlYXNlT3V0IiwidCIsImRlZmF1bHRQcm9wcyIsImFkYXB0aXZlSGVpZ2h0QW5pbWF0aW9uIiwiYWZ0ZXJTbGlkZSIsImF1dG9wbGF5IiwiYXV0b3BsYXlJbnRlcnZhbCIsImJlZm9yZVNsaWRlIiwiZHJhZ2dpbmciLCJkcmFnVGhyZXNob2xkIiwiZW5hYmxlS2V5Ym9hcmRDb250cm9scyIsImZyYW1lQXJpYUxhYmVsIiwia2V5Q29kZUNvbmZpZyIsImZpcnN0U2xpZGUiLCJsYXN0U2xpZGUiLCJwYXVzZSIsImxhbmRtYXJrIiwib25EcmFnU3RhcnQiLCJvbkRyYWciLCJvbkRyYWdFbmQiLCJwYXVzZU9uSG92ZXIiLCJyZW5kZXJBbm5vdW5jZVNsaWRlTWVzc2FnZSIsInJlbmRlckJvdHRvbUNlbnRlckNvbnRyb2xzIiwicmVuZGVyQ2VudGVyTGVmdENvbnRyb2xzIiwicmVuZGVyQ2VudGVyUmlnaHRDb250cm9scyIsInN3aXBpbmciLCJkZWZhdWx0X2Nhcm91c2VsX3Byb3BzX2RlZmF1bHQiLCJ1c2VDYWxsYmFjazMiLCJ1c2VNZW1vIiwidXNlU3RhdGU0IiwidXNlQ2FsbGJhY2syIiwidXNlUmVmNCIsInVzZVN0YXRlMyIsInVzZVN0YXRlV2l0aFJlZiIsImluaXRpYWxTdGF0ZSIsInNldFZhbHVlIiwidmFsdWVSZWYiLCJzZXRWYWx1ZUFuZFJlZiIsIm5ld1ZhbHVlIiwidXNlRnJhbWVIZWlnaHQiLCJ2aXNpYmxlSGVpZ2h0cyIsInNldFZpc2libGVIZWlnaHRzIiwidmlzaWJsZUhlaWdodHNSZWYiLCJzZXRJbml0aWFsaXplZEFkYXB0aXZlSGVpZ2h0IiwiaGFuZGxlVmlzaWJsZVNsaWRlSGVpZ2h0Q2hhbmdlIiwibGF0ZXN0VmlzaWJsZUhlaWdodHMiLCJuZXdWaXNpYmxlSGVpZ2h0cyIsImZpbHRlciIsImNlaWwiLCJmcmFtZUhlaWdodCIsIm1heEhlaWdodCIsInVzZUVmZmVjdDUiLCJ1c2VSZWY1IiwidXNlRm9yd2FyZFJlZiIsInRhcmdldFJlZiIsImpzeDciLCJqc3hzIiwiQ2Fyb3VzZWwiLCJyYXdQcm9wcyIsImludGVybmFsQ2Fyb3VzZWxJZCIsInByb3BzQ2VsbEFsaWduIiwiZGVza3RvcERyYWdnaW5nRW5hYmxlZCIsInByb3BzRHJhZ1RocmVzaG9sZCIsInByb3BzU2Nyb2xsTW9kZSIsInByb3BzU2xpZGVzVG9TY3JvbGwiLCJwcm9wc1NsaWRlc1RvU2hvdyIsIm1vYmlsZURyYWdnaW5nRW5hYmxlZCIsImZpbHRlcmVkU2xpZGVzIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiQm9vbGVhbiIsInNsaWRlSU9FbnRyaWVzIiwic2V0U2xpZGVJT0VudHJpZXMiLCJNYXAiLCJ2aXNpYmxlQ291bnQiLCJBcnJheSIsImZyb20iLCJ2aXNpYmxlIiwiY29uc3RhbnRWaXNpYmxlQ291bnQiLCJzZXRDb25zdGFudFZpc2libGVDb3VudCIsInNldEN1cnJlbnRTbGlkZSIsInNldFBhdXNlIiwic2V0SXNEcmFnZ2luZyIsImRyYWdEaXN0YW5jZSIsInNldERyYWdEaXN0YW5jZSIsInNldEFuaW1hdGlvbkRpc3RhbmNlIiwidXBkYXRlU2xpZGVJT0VudHJ5IiwiZ2V0IiwicHJldiIsIm5ld01hcCIsInNldCIsInByZXZEcmFnZ2VkIiwicHJldlhQb3NpdGlvbiIsInByZURyYWdPZmZzZXQiLCJzbGlkZXJMaXN0UmVmIiwiZGVmYXVsdENhcm91c2VsUmVmIiwiYXV0b3BsYXlUaW1lb3V0IiwiYXV0b3BsYXlMYXN0VHJpZ2dlcmVkUmVmIiwiaXNNb3VudGVkIiwic2V0U2xpZGVyTGlzdFJlZiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJlbCIsInNldEF0dHJpYnV0ZSIsInRhcmdldFNsaWRlVW5ib3VuZGVkIiwidGFyZ2V0U2xpZGVCb3VuZGVkIiwic2xpZGVDaGFuZ2VkIiwiY3VycmVudE9mZnNldCIsInNsaWRlcldpZHRoIiwib2Zmc2V0V2lkdGgiLCJ0YXJnZXRPZmZzZXQiLCJzbGlkZVNldFdpZHRoIiwibXNUb0VuZE9mQW5pbWF0aW9uIiwic2V0VGltZW91dCIsIm5leHRTbGlkZUluZGV4IiwicHJldlNsaWRlSW5kZXgiLCJwcmV2TW92ZWRUb1NsaWRlSW5kZXgiLCJwYXVzZVN0YXJ0ZWQiLCJhZGp1c3RlZFRpbWVvdXRNcyIsImNsZWFyVGltZW91dCIsIm9uS2V5RG93biIsImtleUNvbW1hbmQiLCJrZXlzIiwiY29tbWFuZCIsImluY2x1ZGVzIiwia2V5Q29kZSIsInN0b3BQcm9wYWdhdGlvbiIsImRvdEluZGljZXMiLCJwIiwiZHJhZ1Bvc2l0aW9ucyIsImhhbmRsZURyYWdFbmQiLCJlIiwiZGlzdGFuY2VGcm9tSW5lcnRpYSIsInN0YXJ0TW92ZSIsImVuZE1vdmUiLCJ0aW1lT2Zmc2V0IiwidGltZSIsImdvb2RJbmVydGlhRmVlbENvbnN0YW50IiwiZ29vZEZyaWN0aW9uRmVlbENvbnN0YW50IiwiaW5pdGlhbFZlbG9jaXR5IiwiYWJzIiwidmVsb2NpdHkiLCJhZGp1c3RlZERyYWdEaXN0YW5jZSIsIm9uZVNjcm9sbFdpZHRoIiwiY2FuTWFpbnRhaW5WaXN1YWxDb250aW51aXR5IiwidGltZXNUb01vdmUiLCJmbG9vciIsIm9uVG91Y2hTdGFydCIsImhhbmRsZVBvaW50ZXJNb3ZlIiwieFBvc2l0aW9uIiwiaXNGaXJzdE1vdmUiLCJkZWx0YSIsIm5leHREcmFnRGlzdGFuY2UiLCJzaGlmdCIsIm9uVG91Y2hNb3ZlIiwibW92ZVZhbHVlIiwidG91Y2hlcyIsInBhZ2VYIiwib25Nb3VzZURvd24iLCJvbk1vdXNlTW92ZSIsIm9mZnNldFgiLCJjbGllbnRYIiwib25Nb3VzZVVwIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwicmVuZGVyU2xpZGVzIiwic2xpZGVzIiwiY2hpbGQiLCJvdXRsaW5lIiwidG91Y2hBY3Rpb24iLCJ3aWxsQ2hhbmdlIiwib25Ub3VjaEVuZCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nuka-carousel/dist/index.mjs\n");

/***/ })

};
;